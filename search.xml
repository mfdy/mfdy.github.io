<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[2019年牛客多校第1场 赛后总结]]></title>
    <url>%2F2019%2F07%2F18%2FACM%2FCompetition%20Summary%2F2019%E5%B9%B4%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A1%E7%AC%AC1%E5%9C%BA%E8%B5%9B%E5%90%8E%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[2019年牛客多校第1场 赛后总结 A题 ：Equivalent Prefixes&emsp;题意：就是给你两个有n个不同数的串，然后保证1-p区间内任选一个区间，使得区间中最小值的下标相同，找到最大的p值 &emsp;思路：我的思路是设置两个单调栈，然后每次的第i个数判断大小，放到栈顶（比它大的数弹出栈），当两个栈容量不同时，即不成立。 代码如下: 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 5e5 + 5;int a[maxn], b[maxn];stack&lt;int&gt;s1, s2;int main(void)&#123; int n; while (~scanf("%d", &amp;n)) &#123; for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;a[i]); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;b[i]); while (s1.size()) s1.pop(); while (s2.size()) s2.pop(); int ans = 1; s1.push(a[1]); s2.push(b[1]); for (int i = 2; i &lt;= n; i++) &#123; while (s1.size() &amp;&amp; s1.top() &gt; a[i]) s1.pop(); s1.push(a[i]); while (s2.size() &amp;&amp; s2.top() &gt; b[i]) s2.pop(); s2.push(b[i]); if (s1.size() != s2.size()) break; ans = i; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; B题：Integration&emsp;题意：已知$ \int_{0}^{∞} \frac{1}{1 + x_{2} } dx = \frac{\pi}{2}$，求$\frac{1}{\pi } \int_{0}^{∞} \frac{1}{\prod_{i=1}^{n}(a_{i}^{2} + x^{2})}dx $ 这道题强行唤醒我的数学…但最终以失败告终…看了好几个巨巨的博客……这里感谢这位大佬的博客：2019牛客网暑期多校第一场B题 $ \frac{1}{\prod_{i=1}^{n}(a_{i}^{2} + x^{2})}\,=\,\frac{c_{1} }{a_{1}^{2} + x^{2} }\,+\,\frac{c_{2} }{a_{2}^{2} + x^{2} }\,+…+\frac{c_{n} }{a_{n}^{2} + x^{2} } \\ \, \\\qquad\quad\quad\;\;\, = \frac{c_{1}\cdot \prod_{i\neq 1 }(a_{i}^{2} + x^{2}) + …+c_{i}\cdot \prod_{j\neq i }(a_{j}^{2} + x^{2}) + … + +c_{n}\cdot \prod_{i\neq n }(a_{i}^{2} + x^{2})}{\prod_{i=1}^{n}(a_{i}^{2} + x^{2})}$ 我们可以得到: $\sum_{i = 1}^{n}C_{i}\cdot \prod_{j\neq i}(a_{i}^{2} + x^{2})\,=\,1$ 由数学归纳法，可得：$C_{i}\,=\,\frac{1}{\prod_{j\neq i}(a_{j}^{2}-a_{i}^{2})}$ 又因为$\int_{0}^{∞} \frac{1}{1 + x_{2} } dx = \frac{\pi}{2}$ $ \frac{1}{\pi } \int_{0}^{∞} \frac{1}{\prod_{i=1}^{n}(a_{i}^{2} + x^{2})}dx\,=\,\frac{1}{\pi }\sum_{i=1}^{n}\int_{0}^{∞}\frac{C_{i} }{a_{i}^{2}+x^{2} }dx $$ \\\,\\ \qquad\qquad\qquad\qquad\;=\,\frac{1}{\pi }\sum_{i=1}^{n}C_{i}\int_{0}^{∞}\frac{1}{a_{i}^{2}+x^{2} }dx $$ \\\,\\ \qquad\qquad\qquad\qquad\;=\,\frac{1}{\pi }\sum_{i=1}^{n}\frac{c_{i} }{a_{i} }\cdot \frac{\pi}{2} $$ \\\,\\ \qquad\qquad\qquad\qquad\;=\,\sum_{i=1}^{n}\frac{c_{i} }{2a_{i} } $$ \\\,\\ \qquad\qquad\qquad\qquad\;=\,\frac{1}{2}\sum_{i=1}^{n}\frac{1}{ {a_{i} }\cdot \prod_{j\neq i}(a_{j}^{2}-a_{i}^{2})} $ 然后进行逆元，费马小定理 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int mod = 1e9 + 7;const int maxn = 1e3 + 10;ll a[maxn];ll qpow(ll a, ll b)&#123; ll res = 1; while (b) &#123; if (b &amp; 1) res = res * a % mod; a = a * a % mod; b &gt;&gt;= 1; &#125; return res;&#125;int main(void)&#123; int n; while (~scanf("%d", &amp;n)) &#123; for (int i = 1; i &lt;= n; i++) scanf("%lld", &amp;a[i]); ll ans = 0; for (int i = 1; i &lt;= n; i++) &#123; ll res = 1; for (int j = 1; j &lt;= n; j++) &#123; if (i == j) continue; res *= (a[j] * a[j] % mod - a[i] * a[i] % mod); res %= mod; &#125; ans += qpow(2 * a[i] % mod * res % mod, mod - 2); &#125; ans = (ans % mod + mod) % mod; cout &lt;&lt; ans &lt;&lt; endl; &#125;&#125; E题：ABBA&emsp;题意：有n个＂AB＂,m个＂BA＂，问能结合成多少个序列．这个要求是AB和BA的顺序不变，即A和B的相对位置不变，BA中可以穿插AB，反之亦然 那么我们采用dp，dp[i][j]表示放置i个A和j个B方案数也就是说我们当前串也就是后面添加A还是添加B的情况 12dp[i][j] += dp[i - 1][j];dp[i][j] += dp[i][j - 1]; &emsp;当i ≤ n时，A可以随便放；&emsp;当j ≤ m时，B可以随便放；&emsp;当i &gt; n，如果放A，AB的数量要小于等于n，i - j是至少有多少个AB, i - j ≤ n；&emsp;当j &gt; m，如果放B，BA的数量要小于等于m，j - i是至少有多少个BA, j - i ≤ m;即 12if(i - j &lt;= n) d[i][j] += d[i - 1][j];if(j - i &lt;= m) d[i][j] += d[i][j - 1]]; 最终代码如下(PS: 用于数据组过多，memset会卡T，跟缓冲区有关) 1234567891011121314151617181920212223242526272829#include&lt;bits/stdc++.h&gt;using namespace std; const int mod = 1e9 + 7;const int maxn = 2e3 + 10;int dp[maxn][maxn]; int main(void)&#123; int n, m; while (~scanf("%d%d", &amp;n, &amp;m)) &#123; for (int i = 0; i &lt;= n + m; i++) for (int j = 0; j &lt;= m + n; j++) dp[i][j] = 0; dp[0][0] = 1; for (int i = 0; i &lt;= n + m; i++) &#123; for (int j = 0; j &lt;= m + n; j++) &#123; if (i - j &lt; n) dp[i + 1][j] = (dp[i][j] + dp[i + 1][j]) % mod; if (j - i &lt; m) dp[i][j + 1] = (dp[i][j] + dp[i][j + 1]) % mod; &#125; &#125; printf("%d\n", dp[n + m][n + m]); &#125; return 0;&#125; F题：Random Point in Triangle&emsp;题意：求三角形内部一个点连三个顶点形成的最大三角形面积的期望，再乘一个36 &emsp;答案是 11/2 倍三角形 ABC 的面积 123456789101112131415161718192021#include&lt;bits/stdc++.h&gt;using namespace std;struct point&#123; long long x, y;&#125;a, b, c;point AB, BC;int main(void)&#123; while (cin &gt;&gt; a.x &gt;&gt; a.y &gt;&gt; b.x &gt;&gt; b.y &gt;&gt; c.x &gt;&gt; c.y) &#123; AB.x = b.x - a.x; AB.y = b.y - a.y; BC.x = c.x - b.x; BC.y = c.y - b.y; printf("%lld\n",abs((AB.x * BC.y - AB.y * BC.x)) * 11); &#125; return 0;&#125; J题 ：Fraction Comparision&emsp;题意：判断x/a和y/b的大小，其中1 ≤ x, y ≤ 1018， 1 ≤ a, b ≤ 109 签到题，这道题我们直接用的大整数写的，判断x * b和y * a，没什么好说的 其实出题人是想考察数学方面知识的，官方题解是这样的： 先把 $\frac{x}{a}$ 写成 $[\frac{x}{a}] + \frac{x\,mod\,a}{a}$ 先比整数部分，分数部分分子分母都在 109 范围内，交叉相乘比较 于是乎，上一下官方题解： 1234567891011121314151617181920212223242526272829#include &lt;bits/stdc++.h&gt;static std::pair&lt;uint64_t, uint64_t&gt; fcompare(uint64_t x, uint32_t a, uint64_t y, uint32_t b) &#123; uint64_t p = x / a; // p &lt;= (x / a) &lt; p + 1 uint64_t q = y / b; // q &lt;= (y / b) &lt; q + 1 if (p != q) &#123; return &#123;p, q&#125;; &#125; x %= a; y %= b; return &#123;x * b, y * a&#125;;&#125;int main(void)&#123; std::ios::sync_with_stdio(false); uint64_t x, y; uint32_t a, b; while (std::cin &gt;&gt; x &gt;&gt; a &gt;&gt; y &gt;&gt; b) &#123; auto result = fcompare(x, a, y, b); if (result.first == result.second) puts("="); else if (result.first &lt; result.second) puts("&lt;"); else puts("&gt;"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>多校训练</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>多校训练</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树形DP入门]]></title>
    <url>%2F2019%2F07%2F17%2FACM%2FDP%2F%E6%A0%91%E5%BD%A2DP%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[树形DP没有上司的舞会 [POJ - 2342] 某大学有N个职员，编号为1~N。他们之间有从属关系，也就是说他们的关系就像一棵以校长为根的树，父结点就是子结点的直接上司。现在有个周年庆宴会，宴会每邀请来一个职员都会增加一定的快乐指数Ri，但是呢，如果某个职员的上司来参加舞会了，那么这个职员就无论如何也不肯来参加舞会了。所以，请你编程计算，邀请哪些职员可以使快乐指数最大，求最大的快乐指数。 Input 第一行一个整数N。(1]]></content>
      <categories>
        <category>ACM</category>
        <category>DP</category>
        <category>树形DP</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>DP</tag>
        <tag>树形DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[状压DP &nbsp;Hiho-1044 &nbsp;状态压缩]]></title>
    <url>%2F2019%2F07%2F13%2FACM%2FDP%2F%E7%8A%B6%E5%8E%8BDP%20Hiho-1044%20%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9%2F</url>
    <content type="text"><![CDATA[状态压缩[HihoCoder - 1044] 小Hi和小Ho在兑换到了喜欢的奖品之后，便继续起了他们的美国之行，思来想去，他们决定乘坐火车前往下一座城市——那座城市即将举行美食节！ 但是不幸的是，小Hi和小Ho并没有能够买到很好的火车票——他们只能够乘坐最为破旧的火车进行他们的旅程。 不仅如此，因为美食节的吸引，许多人纷纷踏上了和小Hi小Ho一样的旅程，于是有相当多的人遭遇到了和小Hi小Ho一样的情况——这导致这辆车上的人非常非常的多，以至于都没有足够的位置能让每一个人都有地方坐下来。 小Hi和小Ho本着礼让他们的心情——当然还因为本来他们买的就是站票，老老实实的呆在两节车厢的结合处。他们本以为就能够这样安稳抵达目的地，但事与愿违，他们这节车厢的乘务员是一个强迫症，每隔一小会总是要清扫一次卫生，而时值深夜，大家都早已入睡，这种行为总是会惊醒一些人。而一旦相邻的一些乘客被惊醒了大多数的话，就会同乘务员吵起来，弄得大家都睡不好。 将这一切看在眼里的小Hi与小Ho决定利用他们的算法知识，来帮助这个有着强迫症的乘务员——在不与乘客吵起来的前提下尽可能多的清扫垃圾。 小Hi和小Ho所处的车厢可以被抽象成连成一列的N个位置，按顺序分别编号为1..N，每个位置上都有且仅有一名乘客在休息。同时每个位置上都有一些垃圾需要被清理，其中第i个位置的垃圾数量为Wi。乘务员可以选择其中一些位置进行清理，但是值得注意的是，一旦有编号连续的M个位置中有超过Q个的位置都在这一次清理中被选中的话（即这M个位置上的乘客有至少Q+1个被惊醒了），就会发生令人不愉快的口角。而小Hi和小Ho的任务是，计算选择哪些位置进行清理，在不发生口角的情况下，清扫尽可能多的垃圾。 Input 每个测试点（输入文件）有且仅有一组测试数据。 每组测试数据的第一行为三个正整数N、M和Q，意义如前文所述。 每组测试数据的第二行为N个整数，分别为W1到WN，代表每一个位置上的垃圾数目。 对于100%的数据，满足N&lt;=1000, 2&lt;=M&lt;=10,1&lt;=Q&lt;=M, Wi&lt;=100 Output 对于每组测试数据，输出一个整数Ans，表示在不发生口角的情况下，乘务员最多可以清扫的垃圾数目。 Sample Input 125 2 136 9 80 69 85 Sample Output 1201 题解 这道题我们需要存储当前位置i开始往前m个位置的状态 在递推式dp[i][j] = max(dp[i - 1][j &gt;&gt; 1], dp[i - 1][(j &gt;&gt; 1) + (1 &lt;&lt; m - 1)]) + w[i]中dp[i - 1][j &gt;&gt; 1]、dp[i - 1][(j &gt;&gt; 1) + (1 &lt;&lt; m - 1)]) + w[i]为再往前一个节点为0或者1的状态 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1010;int dp[maxn][1050];int w[maxn];int n, m, q;int sum(int j)&#123; int sum = 0; while (j) &#123; if (j &amp; 1) sum++; j &gt;&gt;= 1; &#125; return sum;&#125;int main(void)&#123; memset(dp, 0, sizeof(dp)); cin &gt;&gt; n &gt;&gt; m &gt;&gt; q; for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;w[i]); for (int i = 1; i &lt;= n; i++) &#123; for (int j = 0; j &lt; 1 &lt;&lt; m; j++) &#123; if (sum(j) &gt; q) continue; if (j &amp; 1) dp[i][j] = max(dp[i - 1][j &gt;&gt; 1], dp[i - 1][(j &gt;&gt; 1) + (1 &lt;&lt; m - 1)]) + w[i]; else dp[i][j] = max(dp[i - 1][j &gt;&gt; 1], dp[i - 1][(j &gt;&gt; 1) + (1 &lt;&lt; m - 1)]); &#125; &#125; int sum = -1; for (int i = 0; i &lt; 1 &lt;&lt; m; i++) sum = max(sum, dp[n][i]); cout &lt;&lt; sum &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>DP</category>
        <category>状压DP</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>DP</tag>
        <tag>状压DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python面向对象程序设计]]></title>
    <url>%2F2019%2F05%2F16%2FPython%2FPython%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[Python面向对象程序设计 本文章总结了董付国老师的Pthon程序设计(第2版)书的内容，仅供个人学习使用，如有侵权，立刻删除 by：mfdy ■ Python完全采用了面向对象程序设计的思想，是真正面向对象的高级动态编程语言，完全支持面向对象的基本功能，如封装、继承、多态以及对基类方法的覆盖或重写。 ■ Python中对象的概念很广泛，Python中的一切内容都可以称为对象，除了数字、字符串、列表、元组、字典、集合、range对象、zip对象等等，函数也是对象，类也是对象。 ■ 创建类时用变量形式表示的对象属性称为数据成员或成员属性，用函数形式表示的对象行为称为成员方法，成员属性和成员方法统称为类的成员。 6.1 类的定义与使用6.1.1 类定义语法Python使用class关键字来定义类，class关键字之后是一个空格，然后是类的名字，再然后是一个冒号，最后换行并定义类的内部实现。 定义了类之后，可以用来实例化对象，并通过“对象名.成员”的方式来访问其中的数据成员或成员方法。 1234567class Car: def infor(self): print("This is a Car")&gt;&gt; car = Car()&gt;&gt; car.infor()This is a Car Python提供了一个关键字“pass”，类似于空语句，可以用在类和函数的定义中或者选择结构中。当暂时没有确定如何实现功能，或者为以后的软件升级预留空间，或者其他类型功能时，可以使用该关键字来“占位”。 12]]></content>
      <categories>
        <category>Python</category>
        <category>面向对象</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python函数设计与使用]]></title>
    <url>%2F2019%2F05%2F15%2FPython%2FPython%E5%87%BD%E6%95%B0%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Python函数设计与使用 本文章总结了董付国老师的Pthon程序设计(第2版)书的内容，仅供个人学习使用，如有侵权，立刻删除 by：mfdy 5.1 函数定义与调用&emsp;■ 将可能需要反复执行的代码封装为函数，并在需要该功能的地方进行调用，不仅可以实现代码复用，更重要的是可以保证代码的一致性，只需要修改该函数代码则所有调用均受到影响。&emsp;■ 设计函数时，应注意提高模块的内聚性，同时降低模块之间的隐式耦合。&emsp;■ 在实际项目开发中，往往会把一些通用的函数封装到一个模块中，并把这个通用模块文件放到顶层文件夹中，这样更方便管理。 在Python中，定义函数的语法如下： 123def 函数名([参数列表]): '''注释''' 函数体 注意事项： 函数形参不需要声明类型，也不需要指定函数返回值类型 即使该函数不需要接受任何参数，也需要保留圆括号 括号后面的冒号不可少 需要有缩进 Python允许嵌套定义函数 例如：求斐波那契中小于参数n的所有值 12345678def fib(n): '''accept an integer n. return ……''' a, b = 1, 1 while a &lt; n: print(a, end=' ') a, b = b, a + b print() 递归调用：函数的递归调用是函数调用的一种特殊情况，函数调用自己，自己再调用自己，自己再调用自己，…，当某个条件得到满足的时候就不再调用了，然后再一层一层地返回直到该函数的第一次调用。 例：普通递归求斐波那契数列的第n项值 1234567def fib(n): if (n &lt;= 1): return 1 return fib(n - 1) + fib(n - 2)&gt;&gt;&gt; fib(7)21 5.2 形参与实参&emsp;&emsp;函数定义时括弧内为形参，一个函数可以没有形参，但是括弧必须要有，表示该函数不接受参数。&emsp;&emsp;函数调用时向其传递实参，将实参的值或引用传递给形参。&emsp;&emsp;在定义函数时，对参数个数并没有限制，如果有多个形参，需要使用逗号进行分割。 对于绝大多数情况下，在函数内部直接修改形参的值不会影响实参。 12345678def addone(a): print(a, end = ' ') a += 1 print(a, end = ' ')a = 3addone(a)print(a) 运行结果为: 3 4 3 但在有些情况下，可以通过特殊的方式在函数内部修改实参的值. &emsp;&emsp;即如果传递给函数的是可变序列，并且在函数内部使用下标或可变序列自身的方法增加、删除元素或修改元素时，修改后的结果是可以反映到函数之外的，实参也得到相应的修改。 修改列表元素值 123456def modify(v): v[0] = v[0]+1a = [2]modify(a)&gt;&gt;&gt; a[3] 为列表增加元素 123456def modify(v, item): v.append(item)a = [2]modify(a, 3)&gt;&gt;&gt; a[2, 3] 修改字典元素值或为字典增加元素 123456def modify(d): d['age'] = 38a = &#123;'name':'Dong', 'age':37, 'sex':'Male'&#125;modify(a)&gt;&gt;&gt; a&#123;'name': 'Dong', 'age': 38, 'sex': 'Male'&#125; 5.3 参数类型在Python中，函数参数有很多种：可以为普通参数、默认值参数、关键参数、可变长度参数等等。 Python在定义函数时不需要指定形参的类型，完全由调用者传递的实参类型以及Python解释器的理解和推断来决定，类似于重载和泛型。 Python函数定义时也不需要指定函数的类型，这将由函数中的return语句来决定，如果没有return语句或者return没有得到执行，则认为返回空值None。 Python支持对函数参数和返回值类型的标注，但实际上并不起任何作用，只是看起来方便。 1234567891011121314151617def test(x:int, y:int) -&gt; int: '''x and y must be integers, return an integer x+y''' assert isinstance(x, int), 'x must be integer' assert isinstance(y, int), 'y must be integer' z = x + y assert isinstance(z, int), 'must return an integer' return z&gt;&gt;&gt; test(1, 2)3&gt;&gt;&gt; test(2, 3.0)Traceback (most recent call last): File "1.py", line 9, in &lt;module&gt; print(test(2, 3.0)) File "D:1.py", line 4, in test assert isinstance(y, int), 'y must be integer'AssertionError: y must be integer 位置参数是比较常用的形式，调用函数时实参和形参的顺序必须严格一致，并且实参和形参的数量必须相同。 5.3.1 默认值参数 默认值参数必须出现在函数参数列表的最右端，且任何一个默认值参数右边不能有非默认值参数。 调用带有默认值参数的函数时，可以不对默认值参数进行赋值，也可以赋值 5.4 return语句5.5 变量作用域5.6 lambda表达式]]></content>
      <categories>
        <category>Python</category>
        <category>函数</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python字符串与正则表达式]]></title>
    <url>%2F2019%2F05%2F14%2FPython%2FPython%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8E%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Python字符串与正则表达式 &emsp;&emsp;UTF-8对全世界所有国家需要用到的字符进行了编码，以1个字节表示英语字符(兼容ASCII)，以3个字节表示中文，还有些语言的符号使用2个字节（例如俄语和希腊语符号）或4个字节。&emsp;&emsp;GB2312是我国制定的中文编码，使用1个字节表示英语，2个字节表示中文；GBK是GB2312的扩充，而CP936是微软在GBK基础上开发的编码方式。GB2312、GBK和CP936都是使用2个字节表示中文。 &emsp;&emsp;不同编码格式之间相差很大，采用不同的编码格式意味着不同的表示和存储形式，把同一字符存入文件时，写入的内容可能会不同，在试图理解其内容时必须了解编码规则并进行正确的解码。如果解码方法不正确就无法还原信息，从这个角度来讲，字符串编码也具有加密的效果。 &emsp;&emsp;Python 3.x完全支持中文字符，默认使用UTF8编码格式，无论是一个数字、英文字母，还是一个汉字，都按一个字符对待和处理。 12345678910s = '中国山东烟台'&gt;&gt;&gt; len(s)6s = '中国山东烟台ABCDE' &gt;&gt;&gt; len(s)姓名 = '张三' &gt;&gt;&gt; print(姓名)张三 4.1 字符串&emsp;&emsp;在Python中，字符串属于不可变序列类型，除了支持序列通用方法（包括分片操作）以外，还支持特有的字符串操作方法。 12345678910111213teststring = 'good'&gt;&gt;&gt; id(teststring)3056036964032teststring[0] = 'w'Traceback (most recent call last): File "1.py", line 3, in &lt;module&gt; teststring[0] = 'w'TypeError: 'str' object does not support item assignmentteststring = 'well'&gt;&gt;&gt; id(teststring)3056036964200 Python字符串驻留机制：对于短字符串，将其赋值给多个不同的对象时，内存中只有一个副本，多个对象共享该副本。长字符串不遵守驻留机制。 123456789a = '1234'b = '1234'&gt;&gt;&gt; id(a) == id(b)Truea = '1234' * 50b = '1234' * 50&gt;&gt;&gt; id(a) == id(b)False 4.1.1 字符串的格式化‘%&emsp;[-]&emsp;[+]&emsp;[0]&emsp;[m]&emsp;[.n]&emsp;格式字符&emsp;’%&emsp;x1 &emsp; 2 &emsp; 3 &emsp; 4 &emsp; 5 &emsp; 6 &emsp;&emsp;&emsp;7&emsp;&emsp;&emsp; 8 &emsp; 9 格式标志，表示格式开始 指定左对齐输出 对正数加正号 指定空位填0 指定最小宽度 指定精度 指定类型 格式运算符 待转换的表达式 格式字符 说明 格式字符 说明 %s 字符串 (采用str()的显示) %x 十六进制整数 %r 字符串 (采用repr()的显示) %e 指数 (基底写为e) %c 单个字符 %E 指数 (基底写为E) %b 二进制整数 %f、%F 浮点数 %d 十进制整数 %g 指数(e)或浮点数 (根据显示长度) %i 十进制整数 %G 指数(E)或浮点数 (根据显示长度) %o 八进制整数 %% 字符”%” 1234567891011121314151617181920212223242526272829303132x = 1235so="%o" % x&gt;&gt;&gt; so"2323"sh = "%x" % x&gt;&gt;&gt; sh"4d3"se = "%e" % x&gt;&gt;&gt; se"1.235000e+03"&gt;&gt;&gt; chr(ord("3")+1)"4"&gt;&gt;&gt; "%s" % 65"65"&gt;&gt;&gt; "%s" % 65333"65333"&gt;&gt;&gt; "%d" % "555"TypeError: %d format: a number is required, not str&gt;&gt;&gt; int('555')555&gt;&gt;&gt; '%s' % [1, 2, 3]'[1, 2, 3]'&gt;&gt;&gt; str((1, 2, 3))'(1, 2, 3)'&gt;&gt;&gt; '%d, %c' % (65, 65)'65, A' 另外，也可使用format方法进行格式化其中，格式化字符串的函数为 str.format() 123456789101112&gt;&gt;&gt; print("The number &#123;0:,&#125; in hex is: &#123;0:#x&#125;, the number &#123;1&#125; in oct is &#123;1:#o&#125;".format(5555,55))The number 5,555 in hex is: 0x15b3, the number 55 in oct is 0o67&gt;&gt;&gt; print("The number &#123;1:,&#125; in hex is: &#123;1:#x&#125;, the number &#123;0&#125; in oct is &#123;0:#o&#125;".format(5555,55))The number 55 in hex is: 0x37, the number 5555 in oct is 0o12663&gt;&gt;&gt; print("my name is &#123;name&#125;, my age is &#123;age&#125;, and my QQ is &#123;qq&#125;".format(name = "mfdy",age = 65524,qq = "123456789"))my name is mfdy, my age is 65524, and my QQ is 123456789position = (5,8,13)&gt;&gt;&gt; print("X:&#123;0[0]&#125;;Y:&#123;0[1]&#125;;Z:&#123;0[2]&#125;".format(position))X:5;Y:8;Z:13 1234567891011121314151617weather = [("Monday","rain"),("Tuesday","sunny"),("Wednesday", "sunny"),("Thursday","rain"),("Friday","Cloudy")]formatter = "Weather of '&#123;0[0]&#125;' is '&#123;0[1]&#125;'".formatfor item in map(formatter,weather): print(item)for item in weather: print(formatter(item))Weather of 'Monday' is 'rain'Weather of 'Tuesday' is 'sunny'Weather of 'Wednesday' is 'sunny'Weather of 'Thursday' is 'rain'Weather of 'Friday' is 'Cloudy'Weather of 'Monday' is 'rain'Weather of 'Tuesday' is 'sunny'Weather of 'Wednesday' is 'sunny'Weather of 'Thursday' is 'rain'Weather of 'Friday' is 'Cloudy' 4.1.2 字符串常用方法find( )、rfind()、index()、rindex()、count() find()和rfind方法分别用来查找一个字符串在另一个字符串指定范围（默认是整个字符串）中首次和最后一次出现的位置，如果不存在则返回-1。 &emsp;&emsp;find()和rifnd() 一个从左往右，一个从右往左 函数原型： 1str.find(str, beg=0, end=len(string)) str — 指定检索的字符串beg — 开始索引，默认为0。end — 结束索引，默认为字符串的长度。 123456789101112&gt;&gt;&gt; s = "apple,peach,banana,peach,pear"# 返回首次出现的位置&gt;&gt;&gt; s.find("peach")6# 从指定位置开始查找&gt;&gt;&gt; s.find("peach", 7)19# 在指定范围中查找&gt;&gt;&gt; s.find("peach", 7, 20)-1&gt;&gt;&gt; s.rfind('p')25 index()和rindex()方法用来返回一个字符串在另一个字符串指定范围中首次和最后一次出现的位置，如果不存在则抛出异常。 123456789101112&gt;&gt;&gt; s.index('p')1&gt;&gt;&gt; s.index('pe')6&gt;&gt;&gt; s.index('pear')25&gt;&gt;&gt; s.index('ppp')Traceback (most recent call last): File "1.py", line 1, in &lt;module&gt; s.index('ppp')ValueError: substring not found count()方法用来返回一个字符串在另一个字符串中出现的次数。 123456&gt;&gt;&gt; s.count('p')5&gt;&gt;&gt; s.count('pp')1&gt;&gt;&gt; s.count('ppp')0 split()、rsplit()、partition()、rpartition() split()和rsplit()方法分别用来以指定字符为分隔符，将字符串左端和右端开始将其分割成多个字符串，并返回包含分割结果的列表。 1str.split(str="", num=string.count(str)) &emsp;str — 分隔符，默认为所有的空字符，包括空格、换行(\n)、制表符(\t)等。&emsp;num — 分割次数。默认为 -1, 即分隔所有。 split()和rsplit()方法，如果不指定分隔符，则字符串中的任何空白符号（包括空格、换行符、制表符等等）都将被认为是分隔符，返回包含最终分割结果的列表。 1234567891011s = 'hello world \n\n My name is Dong '&gt;&gt;&gt; s.split()['hello', 'world', 'My', 'name', 'is', 'Dong']s = '\n\nhello world \n\n\n My name is Dong '&gt;&gt;&gt; s.split()['hello', 'world', 'My', 'name', 'is', 'Dong']s = '\n\nhello\t\t world \n\n\n My name\t is Dong '&gt;&gt;&gt; s.split()['hello', 'world', 'My', 'name', 'is', 'Dong'] split()和rsplit()方法还允许指定最大分割次数 1234567891011121314&gt;&gt;&gt; s = '\n\nhello\t\t world \n\n\n My name is Dong '&gt;&gt;&gt; s.split(None, 1)['hello', 'world \n\n\n My name is Dong ']&gt;&gt;&gt; s.rsplit(None, 1)['\n\nhello\t\t world \n\n\n My name is', 'Dong']&gt;&gt;&gt; s.split(None, 2)['hello', 'world', 'My name is Dong ']&gt;&gt;&gt; s.rsplit(None, 2)['\n\nhello\t\t world \n\n\n My name', 'is', 'Dong']['hello', 'world', 'My', 'name', 'is', 'Dong']&gt;&gt;&gt; s.split(maxsplit = 6)['hello', 'world', 'My', 'name', 'is', 'Dong']&gt;&gt;&gt; s.split(maxsplit = 100)['hello', 'world', 'My', 'name', 'is', 'Dong'] 调用split()方法并且不传递任何参数时，将使用任何空白字符作为分隔符，把连续多个空白字符看作一个；明确传递参数指定split()使用的分隔符时，情况略有不同。 1234567891011# 每个逗号都被作为独立的分隔符&gt;&gt;&gt; 'a,,,bb,,ccc'.split(',')['a', '', '', 'bb', '', 'ccc']# 每个制表符都被作为独立的分隔符&gt;&gt;&gt; 'a\t\t\tbb\t\tccc'.split('\t')['a', '', '', 'bb', '', 'ccc']# 连续多个制表符被作为一个分隔符&gt;&gt;&gt; 'a\t\t\tbb\t\tccc'.split()['a', 'bb', 'ccc'] partition()和rpartition()用来以指定字符串为分隔符将原字符串分割为3部分，即分隔符前的字符串、分隔符字符串、分隔符后的字符串，如果指定的分隔符不在原字符串中，则返回原字符串和两个空字符串。 123456789101112131415&gt;&gt;&gt; s = "apple,peach,banana,pear"# 从左侧使用逗号进行切分&gt;&gt;&gt; s.partition(',')('apple', ',', 'peach,banana,pear')# 从右侧使用逗号进行切分&gt;&gt;&gt; s.rpartition(',')('apple,peach,banana', ',', 'pear')# 使用字符串作为分隔符&gt;&gt;&gt; s.rpartition('banana')('apple,peach,', 'banana', ',pear')&gt;&gt;&gt; 'abababab'.partition('a')('', 'a', 'bababab')&gt;&gt;&gt; 'abababab'.rpartition('a')('ababab', 'a', 'b') 字符串连接join() 12345li = ["apple", "peach", "banana", "pear"]sep = ","s = sep.join(li)&gt;&gt;&gt; s"apple,peach,banana,pear" lower()、upper()、capitalize()、title()、swapcase() 将字符串传华为小写、大写字符串、将字符串首字母变成大写、将每个单词的首字母变为大写以及大小写互换 1234567891011121314151617181920s = "What is Your Name?"# 返回小写字符串&gt;&gt;&gt; s.lower()'what is your name?'# 返回大写字符串&gt;&gt;&gt; s.upper()'WHAT IS YOUR NAME?'# 字符串首字符大写&gt;&gt;&gt; s.capitalize()'What is your name?'# 每个单词的首字母大写&gt;&gt;&gt; s.title()'What Is Your Name?'# 大小写互换&gt;&gt;&gt; s.swapcase()'wHAT IS yOUR nAME?' replace()，类似于“查找与替换”功能 1234s = "123,123"s2 = s.replace("123", "456")&gt;&gt;&gt; s2456,456 例：测试用户输入中是否有敏感词，如果有就把敏感词替换为3个星号*。 1234567words = ('测试', '非法', '暴力', '话')text = '这句话里含有非法内容'for word in words: if word in text: text = text.replace(word, '***')&gt;&gt;&gt; text'这句***里含有***内容' maketrans()、translate() 字符串对象的maketrans()方法用来生成字符映射表，而translate()方法用来根据映射表中定义的对应关系转换字符串并替换其中的字符，使用这两个方法的组合可以同时处理多个不同的字符，replace()方法则无法满足这一要求。 123456# 创建映射表，将字符"abcdef123"一一对应地转换为"uvwxyz@#$"table = ''.maketrans('abcdef123', 'uvwxyz@#$')s = "Python is a greate programming language. I like it!"# 按映射表进行替换&gt;&gt;&gt; s.translate(table)'Python is u gryuty progrumming lunguugy. I liky it!' strip()、rstrip()、lstrip() 分别用来删除两端、右端或者左端的空白字符或连续的指定字符 &emsp;&emsp;删除空白字符1234&gt;&gt;&gt; s = " abc "s2 = s.strip()&gt;&gt;&gt; s2"abc" &emsp;&emsp;删除空白字符12&gt;&gt;&gt; '\n\nhello world \n\n'.strip()'hello world' &emsp;&emsp;删除指定字符1234&gt;&gt;&gt; "aaaassddf".strip("a")"ssddf"&gt;&gt;&gt; "aaaassddf".strip("af")"ssdd" &emsp;&emsp;删除字符串右端指定字符12&gt;&gt;&gt; "aaaassddfaaa".rstrip("a")'aaaassddf' &emsp;&emsp;删除字符串左端指定字符12&gt;&gt;&gt; "aaaassddfaaa".lstrip("a")'ssddfaaa' 要注意的是，这三个函数的参数指定的字符串并不作为一个整体对待，而是在原字符串的两侧、右侧、左侧删除参数字符串中包含的所有字符，一层一层地从外往里扒 eval()：把任意字符串传化为Python表达式并求值 1234567891011121314151617181920&gt;&gt;&gt; eval("3+4")7a = 3b = 5&gt;&gt;&gt; eval('a+b')8import math&gt;&gt;&gt; eval('help(math.sqrt)')Help on built-in function sqrt in module math:sqrt(x, /) Return the square root of x.None&gt;&gt;&gt; eval('math.sqrt(3)')1.7320508075688772&gt;&gt;&gt; eval('aa')NameError: name 'aa' is not defined 但也需要注意的是，eval函数十分的危险 12345# 打开记事本a = "__import__('os').startfile(r'C:\Windows\notepad.exe')"&gt;&gt;&gt; eval(a)&gt;&gt;&gt; eval("__import__('os').system('md testtest')") 关键词in 1234567891011# 测试一个字符中是否存在于另一个字符串中&gt;&gt;&gt; "a" in "abcde"True&gt;&gt;&gt; 'ab' in 'abcde'True# 关键字in左边的字符串作为一个整体对待&gt;&gt;&gt; 'ac' in 'abcde'False&gt;&gt;&gt; "j" in "abcde"False startswith()、endswith()，判断字符串是否以指定字符串开始或结束 12str.startswith(str, beg=0, end=len(string))str.endswith(str, beg=0, end=len(string)) &emsp;str — 检测的字符串。&emsp;strbeg — 可选参数用于设置字符串检测的起始位置。&emsp;strend — 可选参数用于设置字符串检测的结束位置。 123456789101112s = 'Beautiful is better than ugly.'# 检测整个字符串&gt;&gt;&gt; s.startswith('Be')True# 指定检测范围起始位置&gt;&gt;&gt; s.startswith('Be', 5)False# 指定检测范围起始和结束位置&gt;&gt;&gt; s.startswith('Be', 0, 5)True&gt;&gt;&gt; import os&gt;&gt;&gt; [filename for filename in os.listdir(r'c:\\') if filename.endswith(('.bmp','.jpg','.gif'))] center()、ljust()、rjust()，返回指定宽度的新字符串，原字符串居中、左对齐或右对齐出现在新字符串中，如果指定宽度大于字符串长度，则使用指定的字符（默认为空格）进行填充。 12345678&gt;&gt;&gt; 'Hello world!'.center(20) #居中对齐，以空格进行填充' Hello world! '&gt;&gt;&gt; 'Hello world!'.center(20, '=') #居中对齐，以字符=进行填充'====Hello world!===='&gt;&gt;&gt; 'Hello world!'.ljust(20, '=') #左对齐'Hello world!========'&gt;&gt;&gt; 'Hello world!'.rjust(20, '=') #右对齐'========Hello world!' zfill()返回指定宽度的字符串，在左侧以字符0进行填充。 12345678# 在左侧填充数字字符0&gt;&gt;&gt; 'abc'.zfill(5)'00abc'# 指定宽度小于字符串长度时，返回字符串本身&gt;&gt;&gt; 'abc'.zfill(2)'abc'&gt;&gt;&gt; 'uio'.zfill(20)'00000000000000000uio' isalnum()、isalpha()、isdigit()、isdecimal()、isnumeric()、isspace()、isupper()、islower()，用来测试字符串是否为数字或字母、是否为字母、是否为数字字符、是否为空白字符、是否为大写字母以及是否为小写字母。 123456789101112131415161718192021222324&gt;&gt;&gt; '1234abcd'.isalnum()True&gt;&gt;&gt; '1234abcd'.isalpha() #全部为英文字母时返回TrueFalse&gt;&gt;&gt; '1234abcd'.isdigit() #全部为数字时返回TrueFalse&gt;&gt;&gt; 'abcd'.isalpha()True&gt;&gt;&gt; '1234.0'.isdigit()False&gt;&gt;&gt; '1234'.isdigit()True&gt;&gt;&gt; '九'.isnumeric() #isnumeric()方法支持汉字数字True&gt;&gt;&gt; '九'.isdigit()False&gt;&gt;&gt; '九'.isdecimal() #检查字符串是否只包含十进制字符False&gt;&gt;&gt; 'ⅣⅢⅩ'.isdecimal()False&gt;&gt;&gt; 'ⅣⅢⅩ'.isdigit()False&gt;&gt;&gt; 'ⅣⅢⅩ'.isnumeric() #支持罗马数字True ■ 除了字符串对象提供的方法以外，很多Python内置函数也可以对字符串进行操作 123456789&gt;&gt;&gt; x = 'Hello world.'&gt;&gt;&gt; len(x) #字符串长度12&gt;&gt;&gt; max(x) #最大字符'w'&gt;&gt;&gt; min(x)' '&gt;&gt;&gt; list(zip(x,x)) #zip()也可以作用于字符串[('H', 'H'), ('e', 'e'), ('l', 'l'), ('l', 'l'), ('o', 'o'), (' ', ' '), ('w', 'w'), ('o', 'o'), ('r', 'r'), ('l', 'l'), ('d', 'd'), ('.', '.')] ■ 切片也适用于字符串，但仅限于读取其中的元素，不支持字符串修改。 1234&gt;&gt;&gt; 'Explicit is better than implicit.'[:8]'Explicit'&gt;&gt;&gt; 'Explicit is better than implicit.'[9:23]'is better than' ■ Pytho标准库zlib中提供的compress()和decompress()函数可以用于数据的压缩和解压缩，在压缩字符串之前需要先编码为字节串。 4.1.3 字符串常量Python标准库string中定义数字字符、标点符号、英文字母、大写字母、小写字母等常量。 1234567891011&gt;&gt;&gt; import string&gt;&gt;&gt; string.digits'0123456789'&gt;&gt;&gt; string.punctuation'!"#$%&amp;\'()*+,-./:;&lt;=&gt;?@[\\]^_`&#123;|&#125;~'&gt;&gt;&gt; string.ascii_letters'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'&gt;&gt;&gt; string.ascii_lowercase'abcdefghijklmnopqrstuvwxyz'&gt;&gt;&gt; string.ascii_uppercase'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 未完待续……]]></content>
      <categories>
        <category>Python</category>
        <category>字符串 正则表达式</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python选择与循环]]></title>
    <url>%2F2019%2F05%2F13%2FPython%2FPython%E9%80%89%E6%8B%A9%E4%B8%8E%E5%BE%AA%E7%8E%AF%2F</url>
    <content type="text"><![CDATA[Python选择与循环3.1 条件表达式首先，说一下所有的运算符： 算术运算符：+、 -、 *、 /、 //、 %、 ** 关系运算符：&gt;、 &lt;、 ==、 &lt;=、 &gt;=、 !=，可以连续使用，如 123456&gt;&gt;&gt; 1 &lt; 2 &lt; 3True&gt;&gt;&gt; 1 &lt; 2 &gt; 3False&gt;&gt;&gt; 1 &lt; 3 &gt; 2True 测试运算符：in、 not in、 is、 is not 逻辑运算符：and、 or、 not，注意短路求值 位运算符：~、 &amp;、 |、 ^、 &lt;&lt;、 &gt;&gt; 矩阵乘法运算符：@ 在选择和循环结构中，条件表达式的值只要不是False、0（或0.0、0j等）、空值None、空列表、空元组、空集合、空字典、空字符串、空range对象或其他空迭代对象，Python解释器均认为与True等价。 从这个意义上来讲，几乎所有的Python合法表达式都可以作为条件表达式，包括含有函数调用的表达式。 例如： 1234if 3:a = [1, 2, 3]if a: 都是可执行的 其中需要注意的是，逻辑运算符and和or具有惰性求值的特点，即不管后面的正不正确，先执行前面的判断 3.2 选择结构3.2.1 单分支选择结构12if 表达式: 语句块 当表达式值为True或者其他等价值时，表示条件满足，语句块将被执行，否则不执行 12345678x = input('Input two numbers:')# split()返回分割后的字符串列表a, b = map(int, x.split())if a &gt; b: # 序列解包，交换两个变量的值 a, b = b, aprint(a, b) 关于split(): 1str.split(str="", num=string.count(str)) 参数 str — 分隔符，默认为所有的空字符，包括空格、换行(\n)、制表符(\t)等。 num — 分割次数。默认为 -1, 即分隔所有。 12345678str = "asdfg \nsarwar \nfegtsgr"# 以空格为分隔符，包含\n&gt;&gt;&gt; print(str.split( ))['asdfg', 'sarwar', 'fegtsgr']# 以空格为分隔符，分割成两个&gt;&gt;&gt; print(str.split(' ', 1))[['asdfg', 'sarwar \nfegtsgr']] 3.2.2 双分支选择结构1234if 表达式: 语句块1else: 语句块2 比如： 1234if a &gt; b: print(a)else: print(b) Python还支持如下形式的表达式： 1value1 if condition else value2 即condition的值与True等价时，值为value1，否则值为value2。在value1和value2中可以使用复杂表达式，包括函数调用和基本输出语句。并且该表达式具有惰性求值的特点。 12print(6) if a &gt; 3 else print(5)print(6 if a &gt; 3 else 5) 12345import mathimport randomx = math.sqrt(9) if 2 &gt; 3 else random.randint(1, 100)&gt;&gt;&gt; x77 3.2.3 多结构分支123456789if 表达式1: 语句块1elif 表达式2: 语句块2elif 表达式3: 语句块3……else: 语句块4 其中，关键字elif是else if的缩写 3.2.4 选择结构的嵌套选择结构可以嵌套，比如： 12345if 表达式1: 语句块1 if 表达式2: 语句块2…… 3.2.5 例子 面试资格确认 1234567age = 24subject = "计算机"college = "非重点"if (age &gt; 25 and subject == "电子信息工程") or (college == "重点" and subject == "电子信息工程" ) or (age &lt;= 28 and subject == "计算机"): print("恭喜，你已获得我公司的面试机会!")else: print("抱歉，你未达到面试要求") 编写程序，判断某天是某年第几天 123456789101112import timedate = time.localtime()year, month, day = date[:3]day_month = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]if year % 400 == 0 or (year % 4 == 0 and year % 100 != 0): day_month[1] = 29if month == 1: print(day)else: print(sum(day_month[:month - 1]) + day) 其中，判断闰年可以直接使用calendar模块的方法: 12&gt;&gt;&gt; caledar.isleap(2016)True 或者使用下面的方法直接计算今天是今年的第几天: 12345&gt;&gt;&gt; datetime.date.today().timetuple().tm_yday208&gt;&gt;&gt; datetime.date(2015, 7, 25).timetuple().tm_yday206 也可以使用datetime模块提供的功能来计算 123456789101112import datetimetoday = datetime.date.today()&gt;&gt;&gt; todaydatetime.date(2019, 4, 3)firstDay = datetime.date(today.year, 1, 1)&gt;&gt;&gt; firstDaydatetime.date(2019, 1, 1)daysDelta = today - firstDay + datetime.timedelta(days = 1)&gt;&gt;&gt; daysDelta.days208 3.3 循环结构3.3.1 for循环和while循环Python提供了两种基本的循环结构语句——while语句、for语句。 while循环一般用于循环次数难以提前确定的情况，也可以用于循环次数确定的情况。 for循环一般用于循环次数可以提前确定的情况，尤其是用于枚举序列或迭代对象中的元素。 一般优先考虑使用for循环。相同或不同的循环结构之间都可以互相嵌套，实现更为复杂的逻辑。 12345678910while 条件表达式: 循环体[else: #循环结束，且不是因break结束，执行else部分 else子句代码块]for 取值 in 序列或迭代对象: 循环体[else: else子句代码块] 3.3.2 循环结构的优化&emsp;&emsp;为了优化程序以获得更高的效率和运行速度，在编写循环语句时，应尽量减少循环内部不必要的计算，将与循环变量无关的代码尽可能地提取到循环之外。对于使用多重循环嵌套的情况，应尽量减少内层循环中不必要的计算，尽可能地向外提。 例如： 优化前的代码： 12345678910digits = (1, 2, 3, 4)for i in range(1000): result = [] for i in digits: for j in digits: for k in digits: result.append(i * 100 + j * 10 + k)print(result) 优化后的代码： 123456789101112digits = (1, 2, 3, 4)for i in range(1000): result = [] for i in digits: i = i * 100 for j in digits: j = j * 10 for k in digits: result.append(i + j + k)print(result) 3.4 break 和 continue 语句break语句在while循环和for循环中都可以使用，一般放在if选择结构中，一旦break语句被执行，将使得整个循环提前结束。 continue语句的作用是终止当前循环，并忽略continue之后的语句，然后回到循环的顶端，提前进入下一次循环。 除非break语句让代码更简单或更清晰，否则不要轻易使用。 例：计算小于100的最大素数 1234567for n in range(100, 1, -1): for i in range(2, int(n**0.5) + 1): if n % i == 0: break else: print(n) break 当删除最后一个break时，则为输出1-100的所有素数 警惕continue可能带来的问题： 123456i = 0while i &lt; 10: if i % 2 == 0: continue print(i) i += 1 永不结束的死循环,Ctrl+C强行终止。 这样子就不会有问题 1234for i in range(10): if i % 2 == 0: continue print(i, end = ' ') 3.5 案例精选例1：计算1 + 2 + … + 100 的值 1234s = 0for i in range(1, 101): s += iprint(s) 例2：输出序列中的元素 123a_list = ['a', 'b', 'mpilgrim', 'z', 'example']for i, v in enumerate(a_list): print('列表的第', i + 1, '个元素是：', v) 例3：输出“水仙花数”。所谓水仙花数是指1个3位的十进制数，其各位数字的立方和等于该数本身。例如：153是水仙花数，因为153 = 13 + 53 + 33 。 12345for i in range(100, 1000): #这里是序列解包的用法 bai, shi, ge = map(int, str(i)) if ge**3 + shi**3 + bai**3 == i: print(i) 例4：打印九九乘法表。 1234for i in range(1,10): for j in range(1,i + 1): print('&#123;0&#125;*&#123;1&#125;=&#123;2&#125;'.format(i, j, i * j).ljust(6), end = ' ') print() 例5：编写程序，生成一个含有20个随机数的列表，要求所有元素不相同，并且每个元素的值介于1到100之间。 123456789101112import randomx = []while True: if len(x)==20: break n = random.randint(1, 100) if n not in x: x.append(n)print(x)print(len(x))print(sorted(x)) 如果用集合来做，会更简单一些 1234567from random import randintx = set()while len(x) &lt; 20: x.add(randint(1, 100))print(x)print(sorted(x)) 例6: 递归算法求解汉诺塔问题 123456789101112131415def hannoi(num, src, dst, temp=None): global times #声明用来记录移动次数的变量为全局变量 assert type(num) == int, 'num must be integer' #确认参数类型和范围 assert num &gt; 0, 'num must &gt; 0' if num == 1: #只剩最后或只有一个盘子需要移动，这也是函数递归调用的结束条件 print('The &#123;0&#125; Times move:&#123;1&#125;==&gt;&#123;2&#125;'.format(times, src, dst)) times += 1 else: #递归调用函数自身，先把除最后一个盘子之外的所有盘子移动到临时柱子上 hannoi(num-1, src, temp, dst) hannoi(1, src, dst) #把最后一个盘子直接移动到目标柱子上 #把除最后一个盘子之外的其他盘子从临时柱子上移动到目标柱子上 hannoi(num-1, temp, dst, src)times = 1 #用来记录移动次数的变量hannoi(3, 'A', 'C', 'B') #A表示最初放置盘子的柱子，C是目标柱子，B是临时柱子 ljust() 方法返回一个原字符串左对齐,并使用空格填充至指定长度的新字符串。如果指定的长度小于原字符串的长度则返回原字符串。 end]]></content>
      <categories>
        <category>Python</category>
        <category>选择与循环</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python序列]]></title>
    <url>%2F2019%2F05%2F10%2FPython%2FPython%E5%BA%8F%E5%88%97%2F</url>
    <content type="text"><![CDATA[Python序列 本文章总结了董付国老师的Pthon程序设计(第2版)书的内容，仅供个人学习使用，如有侵权，立刻删除 by：mfdy 2.1 列表2.1.1 列表的创建与删除123a_list = ['a', 'b', 'mpilgrim', 'z', 'example']a_list = []# 创建空列表 或者是用list()函数将元组、range对象、字符串或者其他类型的可迭代对象类型的数据转换为列表，例如： 12345678a_list = list((3, 5, 7, 9, 11))# [3, 5, 7, 9, 11]list(range(1, 10, 2))# [1, 3, 5, 7, 9]print(list('hello world'))# ['h', 'e', 'l', 'l', 'o', ' ', 'w', 'o', 'r', 'l', 'd']x =list()# 创建空列表 当不再使用时，使用del命令删除整个列表，如果列表对象所指向的值不再有其他对象指向，同时删除该值123456del a_list&gt;&gt;&gt; a_listTraceback (most recent call last): File "&lt;pyshell#6&gt;", line 1, in &lt;module&gt; a_listNameError: name 'a_list' is not defined 2.1.2 列表元素的增加 可以使用 + 运算符添加，但是其实这个是重新创建一个列表，并将元素复制过来 1234aList = [3, 4, 5]aList = aList + [7]&gt;&gt;&gt; aList[3, 4, 5 ,7] 使用列表对象的append()方法，再不改变列表在内存中的首地址情况下修改列表，推荐方法 123aList.append(9)&gt;&gt;&gt; aList[3, 4, 5, 7 ,9] Python 采用的是基于值的自动内存管理方式，当为对象修改值得时候，是使变量直接指向新的值，适用于所有类型的变量 123456a = [1, 2, 3]&gt;&gt;&gt; id(a)1234567a = [1, 2]&gt;&gt;&gt; id(a)1234589 但如果是通过修改下标来修改序列中元素的值或者通过可变序列对象自身提供的方法来增加和删除元素的时候，序列对象在内存中的起始地址是不变的，仅仅是被修改的元素地址发生变化 12345678910111213a = [1, 2, 4]b = [1, 2, 3]&gt;&gt;&gt; a == b False&gt;&gt;&gt; id(a) == id(b)False&gt;&gt;&gt; id(a[0]) == id(b[0])True&gt;&gt;&gt; id(a)12345678a[0] = 5&gt;&gt;&gt; id(a)12345678 extend(): 将另一个迭代对象的所有元素添加至该列表对象的尾部 12345678a = [1, 2, 3]&gt;&gt;&gt; id(a)12345678a.extend([7, 8, 9])&gt;&gt;&gt; a[1, 2, 3, 7, 8, 9]&gt;&gt;&gt; id(a)12345678 insert(i, j): 在列表的第i个位置插入j元素 123aList.insert(3, 6)&gt;&gt;&gt; aList[1, 2, 3, 6, 4] 使用乘法来扩展列表，将列表与整数相乘，生成一个新的列表，但是只是引用已有对象，当修改其中的一个值的时候，相关引用都会被修改 1234567891011121314151617aList = [1, 2, 3]bList = aList&gt;&gt;&gt; id(aList) == id(bList)TrueaList = aList * 2&gt;&gt;&gt; aList[1, 2, 3, 1, 2, 3]&gt;&gt;&gt; id(aList) == id(bList)Falsex = [[asd] * 2] * 2&gt;&gt;&gt; x[[asd, asd], [asd, asd]]x = [1, 2, 3] * 3x[0][0] = 5&gt;&gt;&gt; x[[5, 2, 3], [5, 2, 3], [5, 2, 3]] 2.1.3 列表元素的删除 使用del命令删除列表或者列表中的指定位置上的元素 12345678910aList = [1, 2, 3, 4, 5]del aList[0]&gt;&gt;&gt; aList[2, 3, 4, 5]del aList&gt;&gt;&gt; aListTraceback (most recent call last): File "&lt;pyshell#6&gt;", line 1, in &lt;module&gt; a_listNameError: name 'a_list' is not defined pop(): 删除并返回指定位置的元素，没有则默认为最后一个，如果超出范围则抛回异常 12345aList = list((1, 2, 3, 4, 5))aList.pop(1)aList.pop()&gt;&gt;&gt; aList[1, 3, 4] remove(): 删除首次出现的指定元素，不存在则返回异常 1234aList = [1, 2, 3, 2, 4]aList.remove(2)&gt;&gt;&gt; aList[1, 3, 2, 4] 2.1.4 列表元素访问与计数可以使用下标直接访问，如果不存在则抛出异常 1234567aList = [1, 2, 3, 4, 5, 6]&gt;&gt;&gt; aList[3]4&gt;&gt;&gt; aList[10]Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;IndexError: list index out of range index(i): 找到元素i首次出现时的下标count(i): 统计指定元素i在列表对象中出现的次数 12345aList = [3, 1, 1, 2]&gt;&gt;&gt; aList.count(1)2&gt;&gt;&gt; aList.index(1)1 2.1.5 成员资格判断 count(): 大于0成立 in 关键词 123456789aList = [1, 2, 3, 4, 5]bList =['a', 'b', 'c', 'd']cList = [[1], [2], [3]]&gt;&gt;&gt; 3 in aListTrue&gt;&gt;&gt; [3] in cListTrue&gt;&gt;&gt; (1, 'a') in zip(aList, bList)True ★2.1.6 切片操作切片使用2个冒号分隔的3个数字来完成： [x:y:z]&emsp;x表示切片开始的位置，默认为0&emsp;y表示切片截止的为，默认为列表长度&emsp;z表示切片的步长，默认为1 1234567891011aList = [1, 2, 3, 4, 5, 7, 9, 11]&gt;&gt;&gt; aList[::][1, 2, 3, 4, 5, 7, 9, 11]&gt;&gt;&gt; aList[::-1][11, 9, 7, 5, 4, 3, 2, 1]&gt;&gt;&gt; aList[1::2][2, 4, 7, 11]&gt;&gt;&gt; aList[1:100:2][2, 4, 7, 11]&gt;&gt;&gt; aLIst[100:][] 注意：切片操作在程序中书写时如果要更改，则需要进行赋值操作 12345678aList = [1, 2, 3, 4, 5, 7, 9, 11]aList[1::2]print(aList)aList = aList[1::2]print(aList)# 输出内容[1, 2, 3, 4, 5, 7, 9, 11][2, 4, 7, 11] 可以使用切片原地地址修改列表内容 123456789101112131415161718192021222324252627282930313233343536373839aList = [3, 5, 7]# 在尾部追加元素aList[len(aList):] = [9]&gt;&gt;&gt; aList[3, 5, 7, 9]# 替换前3个元素aList[:3] = [1, 2, 3]&gt;&gt;&gt; aList[1, 2, 3, 9]# 删除前3个元素aList[:3] = []&gt;&gt;&gt; aList[9]# 生成0-9的十个数aList = list(range(10))&gt;&gt;&gt; aList[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]# 替换偶数位置上的元素aList[::2] = [0] * 5&gt;&gt;&gt; aList[0, 1, 0, 3, 0, 5, 0, 7, 0, 9]# 切片不连续，两个元素个数必须一样多aList[::2] = [0] * 3line 13, in &lt;module&gt; aList[::2] = [0]*3ValueError: attempt to assign sequence of size 3 to extended slice of size 5# del指令删除元素aList = [3,5,7,9,11]#删除前3个元素del aList[:3]#删除偶数位置上的元素del aList[::2] 切片返回的是列表元素的浅复制&emsp;浅复制即把原列表所有元素的引用都复制到新列表中，如果只包含数字等基本元素或者元组、字符串这样的不可变类型的数据，进行修改操作不影响原列表&emsp;如果原列表中包含列表等可变数据类型，修改任何一个都会影响到另一个 1234567891011121314151617181920212223aList = [1, 2, 3]bList = aList[::]&gt;&gt;&gt; aList == bListTrue&gt;&gt;&gt; aList is bListFalse&gt;&gt;&gt; id(aList) == id(bList)FalsebList[1] = 8&gt;&gt;&gt; bList[3, 8, 7]&gt;&gt;&gt; aList[3, 5, 7]aList = [[1, 2], [3, 4], [5, 6]]bList = aList[::]&gt;&gt;&gt; id(aList) == id(bList)FalseaList[0][0] = 8;&gt;&gt;&gt; aList[[8, 2], [3, 4], [5, 6]]&gt;&gt;&gt; bList[[8, 2], [3, 4], [5, 6]] 2.1.7 列表排序 sort(): 进行原地址排序，为自身进行更改，不需要赋值操作 12345678910111213141516import randomaList = [1, 2, 3, 4, 5, 6, 11, 12, 13]# 将序列的所有元素进行随机排序random.shuffle(aList)&gt;&gt;&gt; aList[13, 5, 12, 3, 2, 6, 4, 11, 1]# 升序排序aList.sort()# 降序排列aList.sort(reverse = True)&gt;&gt;&gt; aList[13, 12, 11, 6, 5, 4, 3, 2, 1]# 按转化成字符串的长度排序aList.sort(key = lambda x:len(str(x)))[6, 5, 4, 3, 2, 1, 13, 12, 11] sorted(): 排序并返回新列表 1234567aList = [13, 5, 12, 3, 2, 6, 4, 11, 1]aList = sorted(aList)&gt;&gt;&gt; aList[1, 2, 3, 4, 5, 6, 11, 12, 13]aList = sorted(aList, reverse = True)&gt;&gt;&gt; aList[13, 12, 11, 6, 5, 4, 3, 2, 1] reverse(): 将函数自身翻转，不需要赋值 1234aList = [6, 5, 4, 3, 2, 1, 13, 12, 11]aList.reverse()&gt;&gt;&gt; aList[11, 12, 13, 1, 2, 3, 4, 5, 6] reversed(): 翻转并返回迭代对象 12345678910111213141516171819aList = [11, 12, 13, 1, 2, 3, 4, 5, 6]# 返回reversed对象bList = reversed(aList)&gt;&gt;&gt; bList&lt;list_reverseiterator object at 0x0000011BE35B86D8&gt;# 把reversed对象转换成列表bList = list(bList)&gt;&gt;&gt; bList[6, 5, 4, 3, 2, 1, 13, 12, 11]for i in bList: print(i, end=' ')# 没有输出内容# 重新创建reversed对象bList = reversed(aList)for i in bList: print(i, end=' ')6 5 4 3 2 1 13 12 11 reversed（）返回的是一个迭代器对象，只能进行一次循环遍历。显示一次所包含的值！ 2.1.8 列表常用内置函数 函数 说明 list.append(x) 将元素x添加至列表尾部 list.extend(x) 将列表L中的所有元素添加值列表尾部 list.insert(index, x) &emsp; 在列表指定位置index处添加元素x，该位置后面的所有元素后移一个位置 list.remove(x) 在列表中删除首次出现的元素x，该元素之后的所有元素前移一个位置 list.pop([index]) 删除并返回列表中下标为index（默认为-1）的元素 list.clear() 删除列表中所有元素，但保留列表对象 list.index(x) 返回列表中第一个值为x的元素的下标，若不存在值为x的元素则抛出异常 list.count(x) 返回指定元素x在列表中的出现次数 list.reverse() 对列表lst所有元素进行逆序 list.sort() 对列表lst中的元素进行排序，key用来指定排序依据，reverse决定升序(False)还是降序(True) list.copy() 返回列表lst的浅复制 函数 说明 len(list) 返回列表中的元素个数，适用于元组、字典、集合、字符串等 max(list) 返回列表中的最大元素，适用于元组、字典、集合、字符串等 len(list) 返回列表中的最小元素，适用于元组、字典、集合、字符串等 sum(list) 对列表的元素进行求和运算，对非数值型列表运算需要指定start参数，同样适用于元组、range zip() 返回可迭代的zip对象 enumerate(list)&emsp; 枚举列表元素，返回枚举对象，其中每个元素为包含下标和值的元组。该函数对元组、字符串同样有效。 12345678910111213141516171819202122232425262728293031# sum() # sum()函数的start参数默认为0 &gt;&gt;&gt; sum(range(1, 11)) 55 # 指定start参数为5，等价于5+sum(range(1,11)) &gt;&gt;&gt; sum(range(1, 11), 5) 60 #这个操作占用空间较大，慎用 &gt;&gt;&gt; sum([[1, 2], [3], [4]], []) [1, 2, 3, 4]# zip() aList = [1, 2, 3] bList = [4, 5, 6] cList = zip(a, b) # 返回zip对象 &gt;&gt;&gt; cList &lt;zip object at 0x0000000003728908&gt; # 把zip对象转换成列表 &gt;&gt;&gt; list(cList) [(1, 4), (2, 5), (3, 6)]# enumerate() for item in enumerate('abcdef'): print(item) (0, 'a') (1, 'b') (2, 'c') (3, 'd') (4, 'e') (5, 'f') 2.1.9 列表推导式1aList = [x * x for x in range(10)] 等价于 123aList = []for x in range(10): aList.append(x*x) 也等价于 1aList = list(map(lambda x: x*x, range(10))) 例：阿凡提与国王比赛下棋，国王说要是自己输了的话阿凡提想要什么他都可以拿得出来。阿凡提说那就要点米吧，棋盘一共64个小格子，在第一个格子里放1粒米，第二个格子里放2粒米，第三个格子里放4粒米，第四个格子里放8粒米，以此类推，后面每个格子里的米都是前一个格子里的2倍，一直把64个格子都放满。需要多少粒米呢？ 1print(sum([2**i for i in range(64)])) 例1. 使用列表推导式实现嵌套列表的平铺 1234vec = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]aList = [num for elem in vec for num in elem]&gt;&gt;&gt; aList[1, 2, 3, 4, 5, 6, 7, 8, 9] 相当于 1234567891011121314151617181920vec = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]result = []for elem in vec: for num in elem: result.append(num)&gt;&gt;&gt; result[1, 2, 3, 4, 5, 6, 7, 8, 9]# 或者vec = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]result = sum(vec, [])&gt;&gt;&gt; result[1, 2, 3, 4, 5, 6, 7, 8, 9]# chain()可以把一组迭代对象串联起来，形成一个更大的迭代器vec = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]from itertools import chainresult = list(chain(*vec))&gt;&gt;&gt; result[1, 2, 3, 4, 5, 6, 7, 8, 9] 例2. 列出当前文件夹下所有Python源文件 12&gt;&gt;&gt; import os&gt;&gt;&gt; [filename for filename in os.listdir('.') if filename.endswith(('.py', '.pyw'))] 例3. 过滤不符合条件的元素 123&gt;&gt;&gt; aList = [-1,-4,6,7.5,-2.3,9,-11]&gt;&gt;&gt; [i for i in aList if i&gt;0][6, 7.5, 9] 2.2 元组元组和列表类似，但属于不可变序列，元组一旦创建，用任何方法都不可以修改其元素元组的定义方式和列表相同，但定义时所有元素是放在一对圆括号“（）”中，而不是方括号中。 2.2.1 元组创建与删除 &emsp; 12345678910111213141516a_tuple = ('a', 'b', 'asd', 'qweasdzxc')# 包含一个元素的元组，最后必须写个逗号a_tuple = (3,)&gt;&gt;&gt; a_tuple(3,)a_tuple = (3)&gt;&gt;&gt; a_tuple(3) # 也可以这样创建a_tuple = 3,&gt;&gt;&gt; a_tuple(3,)# 空元组x = () 类似与列表的list()函数，使用tuple()函数将其他序列转换为元组 12345678aList = [1, 2, 3]a_Tuple = tuple(aList)&gt;&gt;&gt; a_Tuple(1, 2, 3)b_Tuple = tuple('asd')&gt;&gt;&gt; b_Tuple('a', 's', 'd') del只能删除整个元组，不能只删除元组中的指定元素 2.2.2 元组与列表的区别 元组中的数据一旦定义就不允许更改。 元组没有append()、extend()和insert()等方法，无法向元组中添加元素。 元组没有remove()或pop()方法，也无法对元组元素进行del操作，不能从元组中删除元素。 从效果上看，tuple()冻结列表，而list()融化元组。 元组的速度比列表更快。如果定义了一系列常量值，而所需做的仅是对它进行遍历，那么一般使用元组而不用列表。 元组对不需要改变的数据进行“写保护”将使得代码更加安全。 元组可用作字典键（特别是包含字符串、数值和其它元组这样的不可变数据的元组）。列表永远不能当做字典键使用，因为列表不是不可变的。 2.2.3 序列解包 可以使用序列解包功能对多个变量同时赋值 123x, y, z = 1, 2, 3&gt;&gt;&gt; print(x, y, z)1 2 3 可以对range对象进行序列解包 123x, y, z = range(3)&gt;&gt;&gt; print(x, y, z)0 1 2 使用迭代器对象进行序列解包 1x, y, z = iter([1, 2, 3]) 使用可迭代的map对象进行序列解包 123x, y, z = map(str, range(3))&gt;&gt;&gt; print(x, y, z)0 1 2 交换两个变量的值 1a, b = b, a sorted()函数返回排序后的列表 1x, y, z = sorted([1, 3, 2]) 字符串也支持序列解包 1a, b, c = 'ABC' 序列解包对于列表和字典同样有效 123456789101112s = &#123;'a':1, 'b':2, 'c':3&#125;b, c, d = s.items()&gt;&gt;&gt; b('a', 1)# 使用字典时不用太多考虑元素的顺序b, c, d = s&gt;&gt;&gt; b'a'b, c, d = s.values()&gt;&gt;&gt; print(b, c, d)1 2 3 2.2.4 生成器推导式生成器推导式的结果是一个生成器对象。使用生成器对象的元素时，可以根据需要将其转化为列表或元组，也可以使用生成器对象next()方法或内置函数next()进行遍历，或者直接将其作为迭代器对象来使用。 生成器对象具有惰性求值的特点，只在需要时生成新元素，比列表推导式具有更高的效率，空间占用非常少，尤其适合大数据处理的场合。 不管用哪种方法访问生成器对象，都无法再次访问已访问过的元素。 12345678910111213141516171819202122g = ((i+2)**2 for i in range(10))&gt;&gt;&gt; g&lt;generator object &lt;genexpr&gt; at 0x0000011B65812570&gt;a_tuple = tuple(g)&gt;&gt;&gt; a_tuple(4, 9, 16, 25, 36, 49, 64, 81, 100, 121)g = ((i+2)**2 for i in range(10))aList = list(g)&gt;&gt;&gt; aList[4, 9, 16, 25, 36, 49, 64, 81, 100, 121]# 使用生成器对象__next__()方法或内置函数next()进行遍历g = ((i+2)**2 for i in range(10))# 使用生成器对象的__next__()方法获取元素&gt;&gt;&gt; g.__next__()4&gt;&gt;&gt; g.__next__()9&gt;&gt;&gt; next(g)16 2.3 字典字典是“键-值对”的无序可变序列，字典中的每个元素包含两个部分：“键”和“值”。定义字典时，每个元素的键和值用冒号分隔，元素之间用逗号分隔，所有的元素放在一对大括号“｛｝”中。字典中的键可以为任意不可变数据，比如整数、实数、复数、字符串、元组等等。 2.3.1 字典创建与删除 使用=将一个字典赋值给一个变量即可创建一个字典变量 123a_dict = &#123;'asd':'qwe', 'zxc':'2'&#125;&gt;&gt;&gt; a_dict&#123;'asd': 'qwe', 'zxc': '2'&#125; 使用内置函数dict()通过已有数据快速创建字典 12345keys = ['a', 'b', 'c', 'd']values = [1, 2, 3, 4]dictionary = dict(zip(keys, values))&gt;&gt;&gt; dictionary&#123;'a': 1, 'b': 2, 'c': 3, 'd': 4&#125; 同时，也可创建空字典 123x = dict()&gt;&gt;&gt; x&#123;&#125; 使用内置函数dict()根据给定的“键-值对”来创建字典 123d = dict(name='Dong', age=37)&gt;&gt;&gt; d&#123;'name': 'Dong', 'age': 37&#125; 以给定内容为“键”，创建“值”为空的字典 12345678910111213141516adict = dict.fromkeys(['name', 'age', 'sex'])&gt;&gt;&gt; adict&#123;'name': None, 'age': None, 'sex': None&#125;aList = ['name', 'age', 'sex']adict = dict.fromkeys(aList, 10)&gt;&gt;&gt; adict&#123;'name': 10, 'age': 10, 'sex': 10&#125;adict = dict.fromkeys('age', 5)&gt;&gt;&gt; adict&#123;'a': 5, 'g': 5, 'e': 5&#125;adict = dict.fromkeys(['age'], 5)&gt;&gt;&gt; adict&#123;'age': 5&#125; 可以使用del删除整个字典或者字典中指定的元素，具体参考2.3.3 2.3.2 字典元素的读取 以键作为下标可以读取字典元素，若键不存在则抛出异常 12345678aDict = &#123;'name':'Dong', 'sex':'male', 'age':37&#125;&gt;&gt;&gt; aDict['name']Dong&gt;&gt;&gt; aDict['tel']Traceback (most recent call last): File "1.py", line 3, in &lt;module&gt; print(aDict['tel'])KeyError: 'tel' 使用字典对象的get方法获取指定键对应的值，并且可以在键不存在的时候返回指定值 get()方法语法： 1dict.get(key, default = None) 其中：key — 字典中要查找的键。default — 如果指定键的值不存在时，返回该默认值值。get()函数返回指定键的值，如果值不在字典中返回默认值None。 12345678910&gt;&gt;&gt; print(aDict.get('address'))None&gt;&gt;&gt; print(aDict.get('address', 'SDIBT'))SDIBTaDict['score'] = aDict.get('score',[])aDict['score'].append(98)aDict['score'].append(97)&gt;&gt;&gt; aDict&#123;'score': [98, 97]&#125; 使用字典对象的items()方法可以返回字典的键、值对列表使用字典对象的keys()方法可以返回字典的键列表使用字典对象的values()方法可以返回字典的值列表 123456789101112aDict = &#123;'name':'Dong', 'sex':'male', 'age':37&#125;for item in aDict.items(): print(item)for key in aDict.keys(): print(key)for value in aDict.values(): print(value)for key, value in aDict.items(): print(key, value) 输出结果为： 123456789101112('name', 'Dong')('sex', 'male')('age', 37)namesexageDongmale37name Dongsex maleage 37 2.3.3 字典元素的添加与修改 当以指定键为下标为字典赋值时，若键存在，则可以修改该键的值；若不存在，则表示添加一个键、值对。 123456789# 修改元素值&gt;&gt;&gt; aDict['age'] = 38&gt;&gt;&gt; aDict&#123;'age': 38, 'name': 'Dong', 'sex': 'male'&#125;# 增加新元素&gt;&gt;&gt; aDict['address'] = 'SDIBT'&gt;&gt;&gt; aDict&#123;'age': 38, 'address': 'SDIBT', 'name': 'Dong', 'sex': 'male'&#125; 使用字典对象的update方法修改键值，当键不存在的时候则自动添加进去 12345678aDict = &#123;'age': 37, 'score': [98, 97], 'name': 'Dong', 'sex': 'male'&#125;aDict.update(&#123;'a':'a','b':'b'&#125;)&gt;&gt;&gt; (aDict)&#123;'age': 37, 'score': [98, 97], 'name': 'Dong', 'sex': 'male', 'a': 'a', 'b': 'b'&#125;aDict.update(&#123;'a':'dss','b':'afd'&#125;)&gt;&gt;&gt; print(aDict)&#123;'age': 37, 'score': [98, 97], 'name': 'Dong', 'sex': 'male', 'a': 'dss', 'b': 'afd'&#125; 删除&emsp;使用del删除字典中指定键的元素&emsp;使用字典对象的clear()方法来删除字典中所有元素&emsp;使用字典对象的pop()方法删除并返回指定键的元素&emsp;使用字典对象的popitem()方法删除并返回字典中的一个元素 2.3.4 有序字典1234567import collectionsx = collections.OrderedDict()x['b'] = 5x['a'] = 3x['c'] = 8&gt;&gt;&gt; xOrderedDict([('b', 5), ('a', 3), ('c', 8)]) 2.4 集合集合为无序可变序列，不能有重复值 且集合中只能包含数字、字符串、元组等不可变类型数据 2.4.1 集合的创建与删除 直接创建 1a = &#123;3, 5&#125; 使用add()方法添加 1a.add(7) 使用set将其他类型数据转换为集合 1234567891011a_set = set(range(8,14))&gt;&gt;&gt; a_set&#123;8, 9, 10, 11, 12, 13&#125;&gt;&gt;&gt; b_set = set([0, 1, 2, 3, 0, 1, 2, 3, 7, 8]) # 自动去除重复&gt;&gt;&gt; b_set&#123;0, 1, 2, 3, 7, 8&#125;&gt;&gt;&gt; c_set = set() # 空集合&gt;&gt;&gt; c_setset() del()删除整个集合pop()弹出并删除其中一个元素remoove()直接删除指定元素clear()清空集合 1234567891011a = &#123;1, 4, 2, 3&#125;&gt;&gt;&gt; a.pop()1&gt;&gt;&gt; a.pop()2&gt;&gt;&gt; a.add(2)&gt;&gt;&gt; a&#123;4, 3, 2&#125;&gt;&gt;&gt; a,remove(3)&gt;&gt;&gt; a&#123;2, 4&#125; 2.4.2 集合操作Python集合支持交集、并集、差集等运算 12345a_set = set([8, 9, 10, 11, 12, 13])b_set = &#123;0, 1, 2, 3, 7, 8&#125;x = &#123;1, 2, 3&#125;y = &#123;1, 2, 5&#125;z = &#123;1, 2, 3, 4&#125; 并集 1234&gt;&gt;&gt; a_set | b_set&#123;0, 1, 2, 3, 7, 8, 9, 10, 11, 12, 13&#125;&gt;&gt;&gt; a_set.union(b_set)&#123;0, 1, 2, 3, 7, 8, 9, 10, 11, 12, 13&#125; 交集 1234&gt;&gt;&gt; a_set &amp; b_set&#123;8&#125;&gt;&gt;&gt; a_set.intersection(b_set)&#123;8&#125; 差集 1234&gt;&gt;&gt; a_set - b_set&#123;9, 10, 11, 12, 13&#125;&gt;&gt;&gt; a_set.difference(b_set)&#123;9, 10, 11, 12, 13&#125; 对称差集 1234&gt;&gt;&gt; a_set ^ b_set&#123;0, 1, 2, 3, 7, 9, 10, 11, 12, 13&#125;&gt;&gt;&gt; a_set.symmetric_difference(b_set)&#123;0, 1, 2, 3, 7, 9, 10, 11, 12, 13&#125; 集合大小 123456&gt;&gt;&gt; x &lt; yFalse&gt;&gt;&gt; x &lt; zTrue&gt;&gt;&gt; y &lt; zFalse 是否为子集 1234&gt;&gt;&gt; x.issubset(y)False&gt;&gt;&gt; x.issubset(z)True 2.4.3 其他作为集合的具体应用，可以使用集合快速提取序列中单一元素 如果使用传统方式 123456789from random import randint# 100个介于0~999之间的随机数listRandom = [randint(0, 9999) for i in range(100)]noRepeat = []for i in listRandom: if i not in noRepeat: noRepeat.append(i)&gt;&gt;&gt; len(listRandom)&gt;&gt;&gt; len(noRepeat) 但是使用集合，只需要如下一行代码 1newSet = set(listRandom) end]]></content>
      <categories>
        <category>Python</category>
        <category>序列</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python程序设计目录]]></title>
    <url>%2F2019%2F05%2F10%2FPython%2FPython%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%9B%AE%E5%BD%95%2F</url>
    <content type="text"><![CDATA[Python程序设计 本文章总结了董付国老师的Pthon程序设计(第2版)书的内容，仅供个人学习使用，如有侵权，立刻删除 &emsp; &emsp; by：mfdy 链接包含本博客链接和CSDN同步链接CSDN目录：https://blog.csdn.net/mofadiyu/article/details/90178542 文章正在持续更新中…… 第一章 基础知识第二章 Python 序列文章链接：mfdy’s blog: Python序列：https://mfdy.tech/2019/05/10/Python序列 2.1 列表：https://blog.csdn.net/mofadiyu/article/details/90178323 2.2 元组：https://blog.csdn.net/mofadiyu/article/details/90178507 2.3 字典：https://blog.csdn.net/mofadiyu/article/details/90613279 2.4 集合：https://blog.csdn.net/mofadiyu/article/details/90613321 第三章 选择与循环文章链接：mfdy’s blog: Python选择与循环：https://mfdy.tech/2019/05/13/Python选择与循环/ 选择与循环：https://blog.csdn.net/mofadiyu/article/details/90648471 第四章 字符串与正则表达式第五章 函数设计与使用第六章 面向对象程序设计第七章 文件操作]]></content>
      <categories>
        <category>Python</category>
        <category>目录</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第十二届河南省ACM大学生程序设计竞赛赛后总结]]></title>
    <url>%2F2019%2F05%2F09%2FACM%2FCompetition%20Summary%2F%E7%AC%AC%E5%8D%81%E4%BA%8C%E5%B1%8A%E6%B2%B3%E5%8D%97%E7%9C%81ACM%E5%A4%A7%E5%AD%A6%E7%94%9F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B%E8%B5%9B%E5%90%8E%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[第十二届河南省ACM大学生程序设计竞赛赛后总结&emsp;&emsp;这次是我跟菜瓜（色瓜）组织大家去比赛了，因为有天梯赛和CCPC省赛的组织经历，所以并没有出什么差错，比赛场地好评，这也算是头一个省赛在体育馆里面举办的了。&lt;/br&gt;下面说一下这次比赛的题吧&emsp;&emsp;先说总结：题很烂，连我们自己院赛题出的都不如，题目难度和知识点分配不均，题目数据频频出问题，幕后据说也有不知名交易。 A题&emsp;&emsp;一道KMP裸题，但是暴力也能过 B题&emsp;&emsp;动态规划 C题&emsp;&emsp;也是一道字符串处理问题，等于找若干个子串的不同就行，暴力就过 D题&emsp;&emsp;一道线性方程的水题，求若干个点相加之和。但是开场两小时之内基本所有队伍交上去全是TLE。1e5的复杂度怎可能会超时，提问说数据有没有问题得到回复没有，但是后来又重判两次……&emsp;&emsp;赛后我们讨论题意还有问题，题目第一句话告诉我们十点已经会发车，但是过的没有算直接sort就过了，不知道算是题描述错还是数据太水…… E题&emsp;&emsp;题目大意是描述找有向图中先升高再降低的路，直接转化为树即可 F题&emsp;&emsp;骂街题目1号&emsp;&emsp;大意是一个01的图中找11的数量，剩下的1算加1，正确做法二分图匹配，赛后被爆出POJ原题，链接： POJ - 3020: http://poj.org/problem?id=3020 结果大家死活做不出来，有很多队伍后来AC了，说是用的贪心直接过，但是贪心很明显不对，比如111100贪心跑出来的答案会是3，但明显是2 G题&emsp;&emsp;骂街题目2号&emsp;&emsp;一道强连通分量的题，但是全场除了冠军队没一个能再做出来，讲题人始终坚持数据没问题，冠军队1发就AC，赛后讲题支支吾吾，唔…不做评价 H题&emsp;&emsp;一道很简答的最短路变形问题，但是全场基本被DFG三道题给绊住，基本没人做 I题&emsp;&emsp;你能听到赛后讲题人直接说这个题我们拿出来就是专门为了防AK的，这道题我们也不会做的话吗？？？ J题&emsp;&emsp;一道二叉树的，很多人直接用树存值过的，但是这道题我觉得还是数据水了，因为231的数据量…&emsp;&emsp;这道题分析后会发现是先求出X的因子中有多少个2，即2n，然后输出x-2^n+1 x+2^n-1即可&lt;/br&gt;&lt;/br&gt;以上基本就是这次比赛的总结，大家往年都是吐槽数据弱，比如去年的一道最小费用流问题直接深搜就过…结果今年直接数据出错不说，还……今年比赛已经导致cy等大佬上台怒怼了，如果河南省赛再这么下去…哎……]]></content>
      <categories>
        <category>ACM</category>
        <category>赛后总结</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>赛后总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DFS:图的联通块&nbsp; AOJ-0118&nbsp; Property Distribution]]></title>
    <url>%2F2018%2F09%2F18%2FACM%2FSTL%2Fbitset%20HDU6515%20Coding%20Problem%2F</url>
    <content type="text"><![CDATA[Coding Problem[ HDU - 6515 ] 题目大意：给你一个字符串，每个字母的ASCII二级制颠倒过来组成一个01数组。然后这个数组每六位组成一个数字的ASCII输出 一道模拟题，使用C++中的bitset类型会简单的很多 那么正好来学习一下bitset的用法： bitset此处参考了这份博客：https://www.cnblogs.com/magisk/p/8809922.html bitset大概就是一个二进制数组，每个位置只占1bit，想一下状压dp？ bitset的原理大概是将很多数压成一个，从而节省空间和时间（暴力出奇迹） 构造构造时可以直接指定大小，也可以使用string和字符串数组来进行构造需要注意的是，在使用字符串构造时，字符串中只能包含01，否则会抛出异常 123456789101112bitset&lt;4&gt; bitset1; //无参构造，长度为４，默认每一位为０bitset&lt;8&gt; bitset2(12); //长度为８，二进制保存，前面用０补充string s = "100101";bitset&lt;10&gt; bitset3(s); //长度为10，前面用０补充char s2[] = "10101";bitset&lt;13&gt; bitset4(s2); //长度为13，前面用０补充cout &lt;&lt; bitset1 &lt;&lt; endl; //0000cout &lt;&lt; bitset2 &lt;&lt; endl; //00001100cout &lt;&lt; bitset3 &lt;&lt; endl; //0000100101cout &lt;&lt; bitset4 &lt;&lt; endl; //0000000010101 性质它支持所有的位运算操作：^ &amp; | &gt;&gt; 等 bitset的函数1234567891011121314bit.size() 返回大小（位数）bit.count() 返回1的个数bit.any() 返回是否有1bit.none() 返回是否没有1bit.set() 全都变成1bit.set(p) 将第p + 1位变成1（bitset是从第0位开始的！）bit.set(p, x) 将第p + 1位变成xbit.reset() 全都变成0bit.reset(p) 将第p + 1位变成0bit.flip() 全都取反bit.flip(p) 将第p + 1位取反bit.to_ulong() 返回它转换为unsigned long的结果，如果超出范围则报错bit.to_ullong() 返回它转换为unsigned long long的结果，如果超出范围则报错bit.to_string() 返回它转换为string的结果 题解需要注意的坑点是这道题不能有换行符，行尾有空格 代码如下 12345678910111213141516171819202122232425262728#include &lt;bits/stdc++.h&gt;using namespace std;string change(char c)&#123; bitset&lt;8&gt; b((int)c); stringstream str; string s; str &lt;&lt; b; str &gt;&gt; s; reverse(s.begin(), s.end()); return s;&#125;int main(void)&#123; string s; cin &gt;&gt; s; for (int i = 0; i &lt; s.size(); i+= 3) &#123; string ts = change(s[i]) + change(s[i + 1]) + change(s[i + 2]); for (int j = 0; j &lt; ts.size(); j+= 6) &#123; bitset&lt;6&gt; B(ts, j, 6); printf("%d ", B); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>Thinking</category>
        <category>DFS</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>Thinking</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DFS:图的联通块&nbsp; AOJ-0118&nbsp; Property Distribution]]></title>
    <url>%2F2018%2F09%2F18%2FACM%2FThinking%2F%E4%BA%8C%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C%2B%E5%B7%AE%E5%88%86%20HDU6514%20Monitor%2F</url>
    <content type="text"><![CDATA[Monitor[ HDU - 6514 ] 题目大意：给你个n×m的区域，每个区域被选中标记为1，没被选中标记为0，然后给一些标记的区域，查询若干个区域问是否有0的 一道二维前缀和的题目，想通没什么难度 代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;bits/stdc++.h&gt;using namespace std;#define IO ios::sync_with_stdio(false), cin.tie(0), cout.tie(0)#define fin freopen("in.txt", "r", stdin)#define fout freopen("out.txt", "w", stdout)typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int, int&gt; P;const int maxn = 1e7 + 10;const int INF = 0x3f3f3f3f;const double eps = 1e-5;int n, m, p, q;int a[maxn];int getid(int i, int j)&#123; if (i == 0 || j == 0 || i &gt; n || j &gt; m) return 0; return (i - 1) * m + j;&#125;void add(int i, int j, int v)&#123; int id = getid(i, j); if (!id) return; a[id] += v;&#125;int main(void)&#123; IO; while (~scanf("%d%d", &amp;n, &amp;m)) &#123; memset(a, 0, sizeof(a)); int x1, y1, x2, y2; scanf("%d", &amp;p); for (int i = 0; i &lt; p; i++) &#123; scanf("%d%d%d%d", &amp;x1, &amp;y1, &amp;x2, &amp;y2); add(x1, y1, 1); add(x2 + 1, y2 + 1, 1); add(x1, y2 + 1, -1); add(x2 + 1, y1, -1); &#125; for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) a[getid(i, j)] += a[getid(i - 1, j)] + a[getid(i, j - 1)] - a[getid(i - 1, j - 1)]; for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) if (a[getid(i,j)] &gt; 0) a[getid(i, j)] = 1; for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) a[getid(i, j)] += a[getid(i - 1, j)] + a[getid(i, j - 1)] - a[getid(i - 1, j - 1)]; scanf("%d", &amp;q); for (int i = 0; i &lt; q; i++) &#123; scanf("%d%d%d%d", &amp;x1, &amp;y1, &amp;x2, &amp;y2); int ans = a[getid(x2, y2)] - a[getid(x1 - 1, y2)] - a[getid(x2, y1 - 1)] + a[getid(x1 - 1, y1 - 1)]; if (ans == (x2 - x1 + 1) * (y2 - y1 + 1)) puts("YES"); else puts("NO"); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>Thinking</category>
        <category>DFS</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>Thinking</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ftp打开方式更改为资源管理器方法]]></title>
    <url>%2F2018%2F08%2F29%2FWindows%2Fftp%E6%89%93%E5%BC%80%E6%96%B9%E5%BC%8F%E6%9B%B4%E6%94%B9%E4%B8%BA%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E5%99%A8%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[&emsp;今天要登陆一下学校的ftp服务器下载点东西，突然发现打开方式变成了chrome，然后就尝试了很多方法更改。&emsp;目前我的系统是Windows10 1803.&emsp;按照网上的更改按协议指定默认程序和从ie中更改之类的完全没有半毛钱效果 &emsp;在即将崩溃的时候发现了这篇文章https://blog.csdn.net/tianwuya217/article/details/8674622由于这篇文章博主操作系统是Win8,所以更改注册表时我发现内容结构不一样，不能按照这个修改方法，但是给我提供了一个思路就是修改[HKEY_CLASSES_ROOT\ftp]目录下的所有内容。 &emsp;如果身旁有小伙伴电脑操作系统跟自己的一样，按照小伙伴的内容的更改即可。 &emsp;下面列出我的更改内容供大家参考 win + R 输入 regedit 打开注册表格, 直接地址栏输入[计算机\HKEY_CLASSES_ROOT\ftp]， 此时我发现我的文件夹里空空如也。（哇，这到底是哪个软件搞的鬼啊 (╯‵□′)╯ ︵ ┻━┻） 将(默认)的字符串值更改为 URL:File Transfer Protocol新建名为 AppUserModelID 字符串值, 输入Microsoft.InternetExplorer.Default新建名为 EditFlags DWORD(32位值), 输入 2新建名为 FriendlyTypeName 字符串值, 输入@C:\WINDOWS\system32\ieframe.dll,-905新建名为 ShellFolder 字符串值, 输入{63da6ec0-2e98-11cf-8d82-444553540000}新建名为 ShellFolder 字符串值, 输入{E436EBB6-524F-11CE-9F53-0020AF0BA770}新建名为 AppUserModelID 字符串值, 无输入 在ftp中新建项, 命名为 Defaultlcon将(默认)的字符串值更改为 %SystemRoot%\system32\url.dll,0 在ftp中新建项, 命名为 shell将(默认)的字符串值更改为 open 在shell中新建项，命名为 open新建名为 CommandId 字符串值, 输入 IE.Protocol(默认)字符串值无需更改 在open中新建项， 命名为 command将(默认)的字符串值更改为&emsp;&quot;C:\Program Files\Internet Explorer\IEXPLORE.EXE&quot; %1新建名为 DelegateExecute 字符串值, 输入{17FE9752-0B5A-4665-84CD-569794602F5C} 此时尝试一下，发现ftp可以用资源管理器打开了。 附上参考博客的博主的话: 搜索问题最好看那些博客类，相对来说准确度较高！&emsp;——你想想大部分人为什么写博客？大部分都是自己千般万苦的搜索了半天或研究了半天才解决的问题。只是想用博客的形式记录下来，记录下自己的成就感。这成果来之不易 ~]]></content>
      <categories>
        <category>系统</category>
        <category>windows</category>
      </categories>
      <tags>
        <tag>系统</tag>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ftp打开方式更改为资源管理器方法]]></title>
    <url>%2F2018%2F08%2F29%2FACM%2FCompetition%20Summary%2FACM-ICPC%202018%20%E5%8D%97%E4%BA%AC%E8%B5%9B%E5%8C%BA%E7%BD%91%E7%BB%9C%E9%A2%84%E8%B5%9B%20%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[&emsp;今天要登陆一下学校的ftp服务器下载点东西，突然发现打开方式变成了chrome，然后就尝试了很多方法更改。&emsp;目前我的系统是Windows10 1803.&emsp;按照网上的更改按协议指定默认程序和从ie中更改之类的完全没有半毛钱效果 &emsp;在即将崩溃的时候发现了这篇文章https://blog.csdn.net/tianwuya217/article/details/8674622由于这篇文章博主操作系统是Win8,所以更改注册表时我发现内容结构不一样，不能按照这个修改方法，但是给我提供了一个思路就是修改[HKEY_CLASSES_ROOT\ftp]目录下的所有内容。 &emsp;如果身旁有小伙伴电脑操作系统跟自己的一样，按照小伙伴的内容的更改即可。 &emsp;下面列出我的更改内容供大家参考 win + R 输入 regedit 打开注册表格, 直接地址栏输入[计算机\HKEY_CLASSES_ROOT\ftp]， 此时我发现我的文件夹里空空如也。（哇，这到底是哪个软件搞的鬼啊 (╯‵□′)╯ ︵ ┻━┻） 将(默认)的字符串值更改为 URL:File Transfer Protocol新建名为 AppUserModelID 字符串值, 输入Microsoft.InternetExplorer.Default新建名为 EditFlags DWORD(32位值), 输入 2新建名为 FriendlyTypeName 字符串值, 输入@C:\WINDOWS\system32\ieframe.dll,-905新建名为 ShellFolder 字符串值, 输入{63da6ec0-2e98-11cf-8d82-444553540000}新建名为 ShellFolder 字符串值, 输入{E436EBB6-524F-11CE-9F53-0020AF0BA770}新建名为 AppUserModelID 字符串值, 无输入 在ftp中新建项, 命名为 Defaultlcon将(默认)的字符串值更改为 %SystemRoot%\system32\url.dll,0 在ftp中新建项, 命名为 shell将(默认)的字符串值更改为 open 在shell中新建项，命名为 open新建名为 CommandId 字符串值, 输入 IE.Protocol(默认)字符串值无需更改 在open中新建项， 命名为 command将(默认)的字符串值更改为&emsp;&quot;C:\Program Files\Internet Explorer\IEXPLORE.EXE&quot; %1新建名为 DelegateExecute 字符串值, 输入{17FE9752-0B5A-4665-84CD-569794602F5C} 此时尝试一下，发现ftp可以用资源管理器打开了。 附上参考博客的博主的话: 搜索问题最好看那些博客类，相对来说准确度较高！&emsp;——你想想大部分人为什么写博客？大部分都是自己千般万苦的搜索了半天或研究了半天才解决的问题。只是想用博客的形式记录下来，记录下自己的成就感。这成果来之不易 ~]]></content>
      <categories>
        <category>系统</category>
        <category>windows</category>
      </categories>
      <tags>
        <tag>系统</tag>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态规划—最长上升子序列问题 两种角度及优化算法]]></title>
    <url>%2F2018%2F08%2F12%2FACM%2FDP%2F%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E2%80%94%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97%E9%97%AE%E9%A2%98%20%E4%B8%A4%E7%A7%8D%E8%A7%92%E5%BA%A6%E5%8F%8A%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[动态规划—最长上升子序列问题 最长上升子序列 [ OpenJ_Bailian - 2757 ] 一个数的序列 bi，当 b1 &lt; b2 &lt; … &lt; bS的时候，我们称这个序列是上升的。对于给定的一个序列( a1, a2, …, aN)，我们可以得到一些上升的子序列( ai1, ai2, …, aiK)，这里1 &lt;= i1 &lt; i2 &lt; … &lt; iK &lt;= N。比如，对于序列(1, 7, 3, 5, 9, 4, 8)，有它的一些上升子序列，如(1, 7), (3, 4, 8)等等。这些子序列中最长的长度是4，比如子序列(1, 3, 5, 8). 你的任务，就是对于给定的序列，求出最长上升子序列的长度。 Input输入的第一行是序列的长度N (1 &lt;= N &lt;= 1000)。第二行给出序列中的N个整数，这些整数的取值范围都在0到10000。 Output最长上升子序列的长度。 Sample Input1271 7 3 5 9 4 8 Sample Output14 题解找子问题 “求以ak（k=1, 2, 3…N）为终点的最长上升子序列的 一个上升子序列中最右边的那个数，称为该子序列的长度” “终点”。 虽然这个子问题和原问题形式上并不完全一样，但是只要这N个子问题都解决了，那么这N个子问题的解中，最大的那个就是整个问题的解。 方法一状态i的值dp[i] 由若干个值已知的状态值dp[0], dp[1], …, dp[i-1]推出。复杂度O(n2) 12345678910111213141516171819202122232425262728#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std; const int MAX_N = 2000;int a[MAX_N];int dp[MAX_N]; int main(void) &#123; int n; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++)&#123; scanf("%d", &amp;a[i]); dp[i] = 1; &#125; for (int i = 1; i &lt; n; i++) for (int j = 0; j &lt; i; j++) if(a[j] &lt; a[i]) dp[i] = max(dp[i], dp[j] + 1); cout &lt;&lt; *max_element(dp, dp + n) &lt;&lt; endl; return 0;&#125; 方法二状态i的值dp[i]在被更新的时候, 依据dp[i]去更新和状态i相关的dp[i+1], …, dp[n-1]的值。复杂度O(n2) 12345678910111213141516171819202122232425262728#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std; const int MAX_N = 2000;int a[MAX_N];int dp[MAX_N]; int main(void) &#123; int n; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++)&#123; scanf("%d", &amp;a[i]); dp[i] = 1; &#125; for (int i = 0; i &lt; n; i++) for (int j = i + 1; j &lt; n; j++) if(a[j] &gt; a[i]) dp[j] = max(dp[j], dp[i] + 1); cout &lt;&lt; *max_element(dp, dp + n) &lt;&lt; endl; return 0;&#125; 优化将全部dp[i]的值初始化为INF。然后数组中除了INF之外为单调递增，所以每个dp[i]最多只需要一次更新。对于更新位置不必逐个遍历，可以利用二分搜索，这样复杂度可降为O(nlogn) 1234567891011121314151617181920212223242526#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std; const int MAX_N = 2000;const int INF = 9999999;int a[MAX_N];int dp[MAX_N]; int main(void) &#123; int n; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) scanf("%d", &amp;a[i]); fill(dp, dp + n, INF); for (int i = 0; i &lt; n; i++) *lower_bound(dp, dp + n, a[i]) = a[i]; cout &lt;&lt; lower_bound(dp, dp + n, INF) - dp &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态规划—最长公共子序列问题 HDU-1159 Common Subsequence]]></title>
    <url>%2F2018%2F08%2F09%2FACM%2FDP%2F%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E2%80%94%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97%E9%97%AE%E9%A2%98%20HDU-1159%20Common%20Subsequence%2F</url>
    <content type="text"><![CDATA[动态规划—最长公共子序列问题 Common Subsequence [ HDU - 1159 ] A subsequence of a given sequence is the given sequence with some elements (possible none) left out. Given a sequence X = another sequence Z = is a subsequence of X if there exists a strictly increasing sequence of indices of X such that for all j = 1,2,…,k, xij = zj. For example, Z = is a subsequence of X = with index sequence . Given two sequences X and Y the problem is to find the length of the maximum-length common subsequence of X and Y.The program input is from a text file. Each data set in the file contains two strings representing the given sequences. The sequences are separated by any number of white spaces. The input data are correct. For each set of data the program prints on the standard output the length of the maximum-length common subsequence from the beginning of a separate line. Sample Input123abcfbc abfcabprogramming contest abcd mnp Sample Output123420 题解输入两个串s,t, 设dp(i,j)表示: s的左边i个字符形成的子串，与t左边的j个 字符形成的子串的最长公共子序列的长度(i,j从0 开始算)dp(i,j) 就是本题的“状态”假定 len1 = strlen(s),len2 = strlen(t）那么题目就是要求 dp[len1,len2] 显然：dp(n,0) = 0 ( n= 0…len1）dp(0,n) = 0 ( n= 0…len2） 递推公式：if ( s[i-1] == t[j-1] ) //s的最左边字符是s1[0]&emsp;dp(i,j) = dp(i-1,j-1) + 1;else&emsp;dp(i,j) = max(dp(i,j-1), dp(i-1,j) ); 时间复杂度O(mn) m,n是两个字串长度 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstdlib&gt;using namespace std;char s[1005], t[1005];int dp[1010][1010];int main(void)&#123; while(~scanf("%s%s" ,s ,t))&#123; int len1 = strlen(s); int len2 = strlen(t); for (int i = 0; i &lt;= len1; i++) dp[i][0] = 0; for (int i = 0; i &lt;= len2; i++) dp[0][i] = 0; for (int i = 0; i &lt; len1; i++)&#123; for (int j = 0; j &lt; len2; j++)&#123; if(s[i]==t[j]) dp[i + 1][j + 1] = dp[i][j] + 1; else dp[i + 1][j + 1] = max(dp[i][j + 1], dp[i + 1][j]); &#125; &#125; cout &lt;&lt; dp[len1][len2] &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Github博客打开速度太慢利用Coding处理方法]]></title>
    <url>%2F2018%2F08%2F06%2FAbout%20blog%2FGithub%E5%8D%9A%E5%AE%A2%E6%89%93%E5%BC%80%E9%80%9F%E5%BA%A6%E5%A4%AA%E6%85%A2%E5%88%A9%E7%94%A8Coding%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[很多人都选择用github搭建个人博客，但是国内很多地方访问速度都很慢。因此可以选择将博客同时同步到coding和github然后二者绑定同一域名即可可以自己购买一个域名，或者不想花钱或嫌域名备案麻烦的可以直接绑定自己的github博客地址同理也可以选择在github中绑定自己的coding博客地址 具体操作如下： 博客设置文件更改如下：123456deploy: type: git repository: hithub: git@github.com:mfdy/mfdy.github.io.git coding: git@git.coding.net:mfdy/mfdy.git branch: master 在coding上建立项目等与github类似，所以省略……然后SSH可以直接用当时github生成的，建议直接添加到个人设置里。添加到项目设置中默认权限是只读的，可能会造成一系列的问题。 coding上要用户名在前的地址是需要启动 代码 - pages服务 的&nbsp;&nbsp;&nbsp;&nbsp;这里选择静态Pages即可。 之后在博客根目录右键Git Bash，输入1ssh -T git@git.coding.net 得到以下回复即为成功1Coding.net Tips : [Hello ! You've conected to Coding.net by SSH successfully! ] 下来CMD输入命令上传并发布1hexo d -g 截至到此，你的两个代码仓库都部署好博客了然后给二者绑定同一域名这里可以选择购买一个个人域名绑定但是个人域名需要花钱而且备案时间又有点长比较麻烦 这时候就——重点来了 在coding的pages自定义域名中直接绑定自己的github域名即可 同理也可以选择在github中绑定自己的coding博客地址]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[更换个人博客地址]]></title>
    <url>%2F2018%2F08%2F05%2FAbout%20blog%2F%E6%9B%B4%E6%8D%A2%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%9C%B0%E5%9D%80%2F</url>
    <content type="text"><![CDATA[博客搬家了！&lt;/br&gt;&emsp;从csdn搬过来了，同时原csdn博客基本不再更新（有时候嫌麻烦会更新，但这里会同步）&lt;/br&gt; &lt;/br&gt;原csdn博客地址：MFDY’s csdn blog&lt;/br&gt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[DFS:图的联通块 &nbsp;POJ-1979 &nbsp;Red and Black]]></title>
    <url>%2F2018%2F08%2F05%2FACM%2FThinking%2FDFS%20POJ-1979%20Red%20and%20Black%2F</url>
    <content type="text"><![CDATA[Red and Black[ POJ - 1979] &nbsp;&nbsp;Here is a rectangular room, covered with square tiles. Each tile is colored either red or black. A man is standing on a black tile. From a tile, he can move to one of four adjacent tiles. But he can’t move on red tiles, he can move only on black tiles.&nbsp;&nbsp;Write a program to count the number of black tiles which he can reach by repeating the moves described above. Input The input consists of multiple data sets. A data set starts with a line containing two positive integers W and H; W and H are the numbers of tiles in the x- and y- directions, respectively. W and H are not more than 20.There are H more lines in the data set, each of which includes W characters. Each character represents the color of a tile as follows.‘.’ - a black tile‘#’ - a red tile‘@’ - a man on a black tile(appears exactly once in a data set)The end of the input is indicated by a line consisting of two zeros. Output For each data set, your program should output a line which contains the number of tiles he can reach from the initial tile (including itself). Sample Input1234567891011121314151617181920212223242526272829303132333435366 9....#......#..............................#@...#.#..#.11 9.#..........#.#######..#.#.....#..#.#.###.#..#.#..@#.#..#.#####.#..#.......#..#########............11 6..#..#..#....#..#..#....#..#..###..#..#..#@...#..#..#....#..#..#..7 7..#.#....#.#..###.###...@...###.###..#.#....#.#..0 0 Sample Output12344559613 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstdlib&gt;using namespace std; int m, n, sum;char garden[105][105];int d[4][2] = &#123; &#123;0, -1&#125;, &#123;1, 0&#125;, &#123;0, 1&#125;, &#123;-1, 0&#125;,&#125;; void dfs(int x, int y)&#123; garden[x][y] = '#'; sum++; for (int i = 0; i &lt; 4; i++)&#123; int nx = x + d[i][1]; int ny = y + d[i][0]; if(0&lt;=nx &amp;&amp; nx&lt;n &amp;&amp; 0&lt;=ny &amp;&amp; ny&lt;m &amp;&amp; garden[nx][ny]=='.') dfs(nx, ny); &#125;&#125; int main(void)&#123; while(~scanf("%d%d", &amp;m, &amp;n) &amp;&amp; m+n)&#123; getchar(); memset(garden, 0, sizeof(garden)); for (int i = 0; i &lt; n; i++)&#123; for (int j = 0; j &lt; m; j++) scanf("%c", &amp;garden[i][j]); getchar(); &#125; sum = 0; for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; m; j++) if (garden[i][j] == '@') dfs(i, j); cout &lt;&lt; sum &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>Thinking</category>
        <category>DFS</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>Thinking</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线段树 &nbsp;HDU-1166 &nbsp;敌兵布阵]]></title>
    <url>%2F2018%2F08%2F05%2FACM%2FData%20Structure%2F%E7%BA%BF%E6%AE%B5%E6%A0%91-HDU-1166%2F</url>
    <content type="text"><![CDATA[敌兵布阵[HDU - 1166] &nbsp;&nbsp;&nbsp;&nbsp;C国的死对头A国这段时间正在进行军事演习，所以C国间谍头子Derek和他手下Tidy又开始忙乎了。A国在海岸线沿直线布置了N个工兵营地,Derek和Tidy的任务就是要监视这些工兵营地的活动情况。由于采取了某种先进的监测手段，所以每个工兵营地的人数C国都掌握的一清二楚,每个工兵营地的人数都有可能发生变动，可能增加或减少若干人手,但这些都逃不过C国的监视。&nbsp;&nbsp;&nbsp;&nbsp;中央情报局要研究敌人究竟演习什么战术,所以Tidy要随时向Derek汇报某一段连续的工兵营地一共有多少人,例如Derek问:“Tidy,马上汇报第3个营地到第10个营地共有多少人!”Tidy就要马上开始计算这一段的总人数并汇报。但敌兵营地的人数经常变动，而Derek每次询问的段都不一样，所以Tidy不得不每次都一个一个营地的去数，很快就精疲力尽了，Derek对Tidy的计算速度越来越不满:”你个死肥仔，算得这么慢，我炒你鱿鱼!”Tidy想：“你自己来算算看，这可真是一项累人的工作!我恨不得你炒我鱿鱼呢!”无奈之下，Tidy只好打电话向计算机专家Windbreaker求救,Windbreaker说：“死肥仔，叫你平时做多点acm题和看多点算法书，现在尝到苦果了吧!”Tidy说：”我知错了。。。”但Windbreaker已经挂掉电话了。Tidy很苦恼，这么算他真的会崩溃的，聪明的读者，你能写个程序帮他完成这项工作吗？不过如果你的程序效率不够高的话，Tidy还是会受到Derek的责骂的. Input 第一行一个整数T，表示有T组数据。每组数据第一行一个正整数N（N&lt;=50000）,表示敌人有N个工兵营地，接下来有N个正整数,第i个正整数ai代表第i个工兵营地里开始时有ai个人（1&lt;=ai&lt;=50）。接下来每行有一条命令，命令有4种形式：(1) Add i j,i和j为正整数,表示第i个营地增加j个人（j不超过30）(2)Sub i j ,i和j为正整数,表示第i个营地减少j个人（j不超过30）;(3)Query i j ,i和j为正整数,i&lt;=j，表示询问第i到第j个营地的总人数;(4)End 表示结束，这条命令在每组数据最后出现;每组数据最多有40000条命令 Output 对第i组数据,首先输出“Case i:”和回车,对于每个Query询问，输出一个整数并回车,表示询问的段中的总人数,这个数保持在int以内。 Sample Input123456789101101 2 3 4 5 6 7 8 9 10Query 1 3Add 3 6Query 2 7Sub 10 2Add 6 3Query 3 10End Sample Output1234Case 1:63359 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;string&gt;using namespace std; struct Node&#123; int l, r, sum;&#125;t[210000]; int a[210000]; void build(int l, int r, int k) &#123; t[k].l=l; t[k].r=r; if(l==r)&#123; t[k].sum=a[r]; &#125;else&#123; build(l, (l+r)/2, k*2); build((l+r)/2+1, r, k*2+1); t[k].sum=t[k*2].sum+t[k*2+1].sum; &#125;&#125; int query(int l, int r, int k)&#123; if(t[k].l&gt;=l &amp;&amp; t[k].r&lt;=r) return t[k].sum; else&#123; int m=(t[k].l+t[k].r)/2; int ans=0; if(l&lt;=m) ans+=query(l, r, 2*k); if(r&gt;m) ans+=query(l, r, 2*k+1); return ans; &#125; &#125; void add(int a,int b,int k)&#123; t[k].sum+=b; if(t[k].l==a &amp;&amp; t[k].r==a) return; if(a&gt;(t[k].l+t[k].r)/2) add(a, b, 2*k+1); else add(a, b, 2*k);&#125; void sub(int a,int b,int k)&#123; t[k].sum-=b; if(t[k].l==a &amp;&amp; t[k].r==a) return; if(a&gt;(t[k].l+t[k].r)/2) sub(a, b, 2*k+1); else sub(a, b, 2*k);&#125; int main(void)&#123; int n,T; char command[6]; scanf("%d", &amp;T); for (int i=1; i&lt;=T; i++) &#123; scanf("%d", &amp;n); for (int j=1; j&lt;=n; j++) scanf("%d", &amp;a[j]); build(1, n, 1); cout &lt;&lt; "Case " &lt;&lt; i &lt;&lt; ":" &lt;&lt; endl; int a,b; while (scanf("%s", command)) &#123; if (strcmp(command,"End")==0) break; scanf("%d%d", &amp;a, &amp;b); if(strcmp(command,"Query")==0) cout &lt;&lt; query(a, b, 1) &lt;&lt; endl; else if(strcmp(command,"Add")==0) add(a, b, 1); else if(strcmp(command,"Sub")==0) sub(a, b, 1); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>Data Structure</category>
        <category>线段树</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>Data Structure</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线段树 &nbsp;HDU-1754 &nbsp;I Hate It]]></title>
    <url>%2F2018%2F08%2F05%2FACM%2FData%20Structure%2F%E7%BA%BF%E6%AE%B5%E6%A0%91-HDU-1754%2F</url>
    <content type="text"><![CDATA[I Hate It[HDU - 1754] 很多学校流行一种比较的习惯。老师们很喜欢询问，从某某到某某当中，分数最高的是多少。这让很多学生很反感。不管你喜不喜欢，现在需要你做的是，就是按照老师的要求，写一个程序，模拟老师的询问。当然，老师有时候需要更新某位同学的成绩。 Input 本题目包含多组测试，请处理到文件结束。在每个测试的第一行，有两个正整数 N 和 M ( 0&lt;N&lt;=200000,0&lt;M&lt;5000 )，分别代表学生的数目和操作的数目。学生ID编号分别从1编到N。第二行包含N个整数，代表这N个学生的初始成绩，其中第i个数代表ID为i的学生的成绩。接下来有M行。每一行有一个字符 C (只取’Q’或’U’) ，和两个正整数A，B。当C为’Q’的时候，表示这是一条询问操作，它询问ID从A到B(包括A,B)的学生当中，成绩最高的是多少。当C为’U’的时候，表示这是一条更新操作，要求把ID为A的学生的成绩更改为B。 Output 对于每一次询问操作，在一行里面输出最高成绩。 Sample Input123456785 61 2 3 4 5Q 1 5U 3 6Q 3 4Q 4 5U 2 9Q 1 5 Sample Output12345659 Hint1Huge input,the C function scanf() will work better than cin 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;string&gt;#include&lt;cstring&gt;using namespace std; struct node&#123; int l,r,max;&#125;t[810000]; int A[210000],max; int MAX(int a, int b)&#123; return a&gt;b ? a:b;&#125; void build(int l,int r,int k)&#123; t[k].l=l; t[k].r=r; if(l==r) t[k].max=A[r]; else&#123; build(l,(l+r)/2,k&lt;&lt;1); build((l+r)/2+1,r,k&lt;&lt;1|1); t[k].max=MAX(t[k&lt;&lt;1].max, t[k&lt;&lt;1|1].max); &#125;&#125; int query(int l,int r,int k)&#123; if(t[k].l&gt;=l &amp;&amp; t[k].r&lt;=r) return t[k].max; else&#123; int ans=0; int m=(t[k].l+t[k].r)/2; if(l&lt;=m) ans=query(l,r,k&lt;&lt;1); if(r&gt;m) ans=MAX(ans,query(l,r,k&lt;&lt;1|1)); return ans; &#125; &#125; void change(int a,int b,int k)&#123; if(t[k].l==a &amp;&amp; t[k].r==a)&#123; t[k].max=b; return; &#125; if(a&gt;(t[k].l+t[k].r)/2) change(a,b,2*k+1); else change(a,b,2*k); t[k].max=MAX(t[k*2].max, t[k*2+1].max);&#125; int main(void) &#123; int l,r,k,n,m; char command; while(scanf("%d%d",&amp;n,&amp;m)!=EOF)&#123; memset(t,0,sizeof(t)); memset(A,0,sizeof(A)); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;A[i]); build(1,n,1); getchar(); while(m--&gt;0)&#123; int a, b; scanf("%c%d%d",&amp;command,&amp;a,&amp;b); getchar(); if(command=='Q') cout &lt;&lt; query(a,b,1) &lt;&lt; endl; else if(command=='U') change(a,b,1); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>Data Structure</category>
        <category>线段树</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>Data Structure</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并查集 &nbsp;HDU-1213 &nbsp;How Many Tables]]></title>
    <url>%2F2018%2F08%2F05%2FACM%2FData%20Structure%2F%E5%B9%B6%E6%9F%A5%E9%9B%86%20HDU-1213%20How%20Many%20Tables%2F</url>
    <content type="text"><![CDATA[How Many Tables[ HDU - 1213 ] Today is Ignatius’ birthday. He invites a lot of friends. Now it’s dinner time. Ignatius wants to know how many tables he needs at least. You have to notice that not all the friends know each other, and all the friends do not want to stay with strangers.One important rule for this problem is that if I tell you A knows B, and B knows C, that means A, B, C know each other, so they can stay in one table.For example: If I tell you A knows B, B knows C, and D knows E, so A, B, C can stay in one table, and D, E have to stay in the other one. So Ignatius needs 2 tables at least. Input The input starts with an integer T(1&lt;=T&lt;=25) which indicate the number of test cases. Then T test cases follow. Each test case starts with two integers N and M(1&lt;=N,M&lt;=1000). N indicates the number of friends, the friends are marked from 1 to N. Then M lines follow. Each line consists of two integers A and B(A!=B), that means friend A and friend B know each other. There will be a blank line between two cases. Output For each test case, just output how many tables Ignatius needs at least. Do NOT print any blanks. Sample Input1234567825 31 22 34 5 5 12 5 Sample Output1224 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;iostream&gt;using namespace std; int par[1010];int ran[1010]; void init(int n)&#123; for(int i=1; i&lt;=n; i++)&#123; par[i]=i; ran[i]=0; &#125;&#125; int find(int x)&#123; if(par[x]==x) return x; else return par[x]=find(par[x]);&#125; void unite(int x, int y)&#123; x=find(x); y=find(y); if(x==y) return; if(ran[x]&lt;ran[y])&#123; par[x]=y; &#125;else&#123; par[y]=x; if(ran[x]==ran[y]) ran[x]++; &#125;&#125; int main(void)&#123; int t, m, n, a, b; cin &gt;&gt; t; while(t--)&#123; scanf("%d%d", &amp;n, &amp;m); init(n); for(int i=0; i&lt;m; i++)&#123; scanf("%d%d", &amp;a, &amp;b); if(a&lt;b) swap(a, b); unite(a, b); &#125; int sum=0; for(int i=1; i&lt;=n; i++)&#123; if(par[i]==i) sum++; &#125; printf("%d\n", sum); getchar(); &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>Data Structure</category>
        <category>并查集</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>Data Structure</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BFS:图的最短路径 &nbsp;Aizu-0558 &nbsp;​​​​​​​Cheese]]></title>
    <url>%2F2018%2F08%2F05%2FACM%2FThinking%2FBFS%20Aizu%20-%200558%20%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8BCheese%2F</url>
    <content type="text"><![CDATA[Cheese[ Aizu - 0558 ] 大意：在H * W的地图上有N个奶酪工厂，每个工厂分别生产硬度为1-N的奶酪。有一只老鼠准备从出发点吃遍每一个工厂的奶酪。老鼠有一个体力值，初始时为1，每吃一个工厂的奶酪体力值增加1（每个工厂只能吃一次），且老鼠只能吃硬度不大于当前体力值的奶酪。 老鼠从当前格到上下左右相邻的无障碍物的格需要时间1单位，有障碍物的格不能走。走到工厂上时即可吃到该工厂的奶酪，吃奶酪时间不计。问吃遍所有奶酪最少用时。 输入：第一行三个整数H(1 &lt;= H &lt;= 1000)、W(1 &lt;= W &lt;=1000)、N(1 &lt;= N &lt;= 9)，之后H行W列为地图， “.“为空地， ”X“为障碍物，”S“为老鼠洞， 1-N代表硬度为1-N的奶酪的工厂。输出最少用时。 今年も JOI 町のチーズ工場がチーズの生産を始め，ねずみが巣から顔を出した．JOI 町は東西南北に区画整理されていて，各区画は巣，チーズ工場，障害物，空き地のいずれかである．ねずみは巣から出発して全てのチーズ工場を訪れチーズを 1 個ずつ食べる． この町には，N 個のチーズ工場があり，どの工場も１種類のチーズだけを生産している．チーズの硬さは工場によって異なっており，硬さ 1 から N までのチーズを生産するチーズ工場がちょうど 1 つずつある． ねずみの最初の体力は 1 であり，チーズを 1 個食べるごとに体力が 1 増える．ただし，ねずみは自分の体力よりも硬いチーズを食べることはできない． ねずみは，東西南北に隣り合う区画に 1 分で移動することができるが，障害物の区画には入ることができない．チーズ工場をチーズを食べずに通り過ぎることもできる．すべてのチーズを食べ終えるまでにかかる最短時間を求めるプログラムを書け．ただし，ねずみがチーズを食べるのにかかる時間は無視できる． Input 入力は H+1 行ある．1 行目には 3 つの整数 H，W，N (1 ≤ H ≤ 1000，1 ≤ W ≤ 1000，1 ≤ N ≤ 9) がこの順に空白で区切られて書かれている．2 行目から H+1 行目までの各行には，’S’，’1’, ‘2’, …, ‘9’，’X’，’.’ からなる W 文字の文字列が書かれており，各々が各区画の状態を表している．北から i 番目，西から j 番目の区画を (i,j) と記述することにすると (1 ≤ i ≤ H, 1 ≤ j ≤ W)，第 i+1 行目の j 番目の文字は，区画 (i,j) が巣である場合は ‘S’ となり，障害物である場合は ‘X’ となり，空き地である場合は ‘.’ となり，硬さ 1, 2, …, 9 のチーズを生産する工場である場合はそれぞれ ‘1’, ‘2’, …, ‘9’ となる．入力には巣と硬さ 1, 2, …, N のチーズを生産する工場がそれぞれ 1 つずつある．他のマスは障害物または空き地であることが保証されている．ねずみは全てのチーズを食べられることが保証されている． Output すべてのチーズを食べ終えるまでにかかる最短時間（分）を表す整数を 1 行で出力せよ． Sample Input 112343 3 1S.......1 Sample Output 114 Sample Input 2123454 5 2.X..1....X.XX.S.2.X. Sample Output 2112 Sample Input 3123456789101110 10 9.X...X.S.X6..5X..X1X...XXXX..XX..9X...X.8.X2X..X3X...XX.X4..XX....7X..X..X..XX..X...X.XX....X....... Sample Output 3191 問題文と自動審判に使われるデータは、情報オリンピック日本委員会が作成し公開している問題文と採点用テストデータです。 BFS变下形就行，注意数组范围……123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;string&gt;#include&lt;cstdio&gt;#include&lt;cctype&gt;#include&lt;queue&gt;#include&lt;cmath&gt;#include&lt;map&gt;#include&lt;set&gt;using namespace std;const int INF = 100000000, maxn = 1005;//可以使用结构体typedef pair&lt;int, int&gt; P; char maze[maxn][maxn];int n, m, k, sx, sy, gx[10], gy[10];//到各个位置的最短距离的数组int d[maxn][maxn];//4个方向移动的向量int dx[4] = &#123;1, 0, -1, 0&#125;, dy[4] = &#123;0, 1, 0, -1&#125;; //求从(sx,sy)到(gx,gy)的最短距离//若无法到达则是INFint bfs(int sx, int sy, int gx, int gy)&#123; queue&lt;P&gt; que; //所有的位置都初始化为INF for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; m; j++) d[i][j] = INF; que.push(P(sx, sy)); //将起点加入队列中 d[sx][sy] = 0; //并把这一地点的距离设置为0 //不断循环直到队列的长度为0 while (que.size())&#123; P p = que.front(); // 从队列的最前段取出元素 que.pop(); //取出后从队列中删除该元素 if (p.first == gx &amp;&amp; p.second == gy) break; //四个方向的循环 for (int i = 0; i &lt; 4; i++)&#123; //移动后的位置标记为(nx,ny) int nx = p.first + dx[i], ny = p.second + dy[i]; //判断是否可以移动以及是否访问过(即d[nx][ny]!=INF） if (0 &lt;= nx &amp;&amp; nx &lt; n &amp;&amp; 0 &lt;= ny &amp;&amp; ny &lt; m &amp;&amp; maze[nx][ny] != 'X' &amp;&amp; d[nx][ny] == INF)&#123; que.push(P(nx, ny)); //可以移动，添加到队列 d[nx][ny] = d[p.first][p.second] + 1; //到该位置的距离为到p的距离+1 &#125; &#125; &#125; return d[gx][gy];&#125; int main()&#123; cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; int t; for (int i = 0; i &lt; n; i++)&#123; for (int j = 0; j &lt; m; j++)&#123; cin &gt;&gt; maze[i][j]; if(maze[i][j]=='S')&#123; gx[0] = i; gy[0] = j; &#125;else if (isdigit(maze[i][j]))&#123; t = maze[i][j] - '0'; gx[t] = i; gy[t] = j; &#125; &#125; &#125; int sum = 0; for (int i = 1; i &lt;= k; i++) sum += bfs(gx[i - 1], gy[i - 1], gx[i], gy[i]); cout &lt;&lt; sum &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>Thinking</category>
        <category>BFS</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>Thinking</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并查集 &nbsp;HDU-1232 &nbsp;畅通工程​​​​​​​]]></title>
    <url>%2F2018%2F08%2F05%2FACM%2FData%20Structure%2F%E5%B9%B6%E6%9F%A5%E9%9B%86%20HDU-1232%20%E7%95%85%E9%80%9A%E5%B7%A5%E7%A8%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%2F</url>
    <content type="text"><![CDATA[畅通工程[ HDU - 1232 ] 某省调查城镇交通状况，得到现有城镇道路统计表，表中列出了每条道路直接连通的城镇。省政府“畅通工程”的目标是使全省任何两个城镇间都可以实现交通（但不一定有直接的道路相连，只要互相间接通过道路可达即可）。问最少还需要建设多少条道路？ Input 测试输入包含若干测试用例。每个测试用例的第1行给出两个正整数，分别是城镇数目N ( &lt; 1000 )和道路数目M；随后的M行对应M条道路，每行给出一对正整数，分别是该条道路直接连通的两个城镇的编号。为简单起见，城镇从1到N编号。注意:两个城市之间可以有多条道路相通,也就是说3 31 21 22 1这种输入也是合法的当N为0时，输入结束，该用例不被处理。 Output 对每个测试用例，在1行里输出最少还需要建设的道路数目。 Sample Input1234567891011124 21 34 33 31 21 32 35 21 23 5999 00 Sample Output1234102998 HintHuge input, scanf is recommended. 赤裸裸的并查集……12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;iostream&gt;using namespace std; int par[1010];int ran[1010]; void init(int n)&#123; for(int i=1; i&lt;=n; i++)&#123; par[i]=i; ran[i]=0; &#125;&#125; int find(int x)&#123; if(par[x]==x) return x; else return par[x]=find(par[x]);&#125; void unite(int x, int y)&#123; x=find(x); y=find(y); if(x==y) return; if(ran[x]&lt;ran[y])&#123; par[x]=y; &#125;else&#123; par[y]=x; if(ran[x]==ran[y]) ran[x]++; &#125;&#125; int main(void)&#123; int n, m, a, b; while(~scanf("%d", &amp;n) &amp;&amp; n!=0)&#123; init(n); scanf("%d", &amp;m); for(int i=0; i&lt;m; i++)&#123; scanf("%d%d", &amp;a, &amp;b); if(a&gt;b) swap(a,b); unite(a, b); &#125; int sum=0; for(int i=1; i&lt;=n; i++) if(par[i]==i) sum++; printf("%d\n", sum-1); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>Data Structure</category>
        <category>并查集</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>Data Structure</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络流—Edmonds-Karp最短增广路算法(最大流)]]></title>
    <url>%2F2018%2F08%2F05%2FACM%2FGraph%2F%E7%BD%91%E7%BB%9C%E6%B5%81%E2%80%94Edmonds-Karp%20%E6%9C%80%E7%9F%AD%E5%A2%9E%E5%B9%BF%E8%B7%AF%E7%AE%97%E6%B3%95(%E6%9C%80%E5%A4%A7%E6%B5%81)%2F</url>
    <content type="text"><![CDATA[网络流—Edmonds-Karp 最短增广路算法(最大流)思路 ■求最大流的过程，就是不断找到一条源到汇的路径，然后构建残余网络，再在残余网络上寻找新的路径，使总流量增加，然后形成新的残余网络，再寻找新路径…..直到某个残余网络上找不到从源到汇的路径为止，最大流就算出来了。 ■每次寻找新流量并构造新残余网络的过程，就叫做寻找流量的“增广路径”，也叫“增广” 现在假设每条边的容量都是整数，这个算法每次都能将流至少增加1 由于整个网络的流量最多不超过 图中所有的边的容量和C，从而算法会结束 复杂度 找增广路径的算法可以用dfs，复杂度为边数m+顶点数n ，Dfs 最多运行C次 ，所以时间复杂度为C*(m+n) =C* n^2 这个算法实现很简单 但是注意到在图中C可能会非常大 因此在每次增广的时候，选择从源到汇的具有最少边数的增广路径,即不是通过dfs寻找增广路径，而是通过bfs寻找增广路径。 这就是Edmonds-Karp 最短增广路算法 已经证明这种算法的复杂度上限为nm2 (n是点数，m是边数） --- 例题： Drainage Ditches [ POJ - 1273 ] Every time it rains on Farmer John's fields, a pond forms over Bessie's favorite clover patch. This means that the clover is covered by water for awhile and takes quite a long time to regrow. Thus, Farmer John has built a set of drainage ditches so that Bessie's clover patch is never covered in water. Instead, the water is drained to a nearby stream. Being an ace engineer, Farmer John has also installed regulators at the beginning of each ditch, so he can control at what rate water flows into that ditch. Farmer John knows not only how many gallons of water each ditch can transport per minute but also the exact layout of the ditches, which feed out of the pond and into each other and stream in a potentially complex network. Given all this information, determine the maximum rate at which water can be transported out of the pond and into the stream. For any given ditch, water flows in only one direction, but there might be a way that water can flow in a circle. Input The input includes several cases. For each case, the first line contains two space-separated integers, N (0 &lt;= N &lt;= 200) and M (2 &lt;= M &lt;= 200). N is the number of ditches that Farmer John has dug. M is the number of intersections points for those ditches. Intersection 1 is the pond. Intersection point M is the stream. Each of the following N lines contains three integers, Si, Ei, and Ci. Si and Ei (1 &lt;= Si, Ei &lt;= M) designate the intersections between which this ditch flows. Water will flow through this ditch from Si to Ei. Ci (0 &lt;= Ci &lt;= 10,000,000) is the maximum rate at which water will flow through the ditch. Output For each case, output a single integer, the maximum rate at which water may emptied from the pond. Sample Input1234565 41 2 401 4 202 4 202 3 303 4 10 Sample Output150 赤裸裸的网络流题目。给定点数，边数，每条边的容量，以及源点，汇点，求最大流。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;queue&gt;using namespace std; int G[300][300];int Prev[300]; //路径上每个节点的前驱节点bool Visited[300];int n, m; //m是顶点数目，顶点编号从1开始 1是源，m是汇, n是边数 unsigned Augment(void)&#123; int v; int i; deque&lt;int&gt; q; memset(Prev, 0, sizeof(Prev)); memset(Visited, 0, sizeof(Visited)); Prev[1] = 0; Visited[1] = 1; q.push_back(1); bool bFindPath = false; //用bfs寻找一条源到汇的可行路径 while (!q.empty())&#123; v = q.front(); q.pop_front(); for (i = 1; i &lt;= m; i++)&#123; if (G[v][i] &gt; 0 &amp;&amp; Visited[i] == 0)&#123; //必须是依然有容量的边，才可以走 Prev[i] = v; Visited[i] = 1; if (i == m)&#123; bFindPath = true; q.clear(); break; &#125;else q.push_back(i); &#125; &#125; &#125; if (!bFindPath) return 0; int nMinFlow = 999999999; v = m; //寻找源到汇路径上容量最小的边，其容量就是此次增加的总流量 while (Prev[v])&#123; nMinFlow = min(nMinFlow, G[Prev[v]][v]); v = Prev[v]; &#125; //沿此路径添加反向边，同时修改路径上每条边的容量 v = m; while (Prev[v])&#123; G[Prev[v]][v] -= nMinFlow; G[v][Prev[v]] += nMinFlow; v = Prev[v]; &#125; return nMinFlow;&#125; int main(void)&#123; while (~scanf("%d%d", &amp;n, &amp;m))&#123; //m是顶点数目，顶点编号从1开始 int i, j, k; int s, e, c; memset(G, 0, sizeof(G)); for (i = 0; i &lt; n; i++)&#123; scanf("%d%d%d", &amp;s, &amp;e, &amp;c); G[s][e] += c; //两点之间可能有多条边 &#125; unsigned int MaxFlow = 0; unsigned int aug; while (aug = Augment()) MaxFlow += aug; cout &lt;&lt; MaxFlow &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>Graph</category>
        <category>网络流</category>
        <category>最大流</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>Graph</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[贪心 &nbsp;POJ-3617 ​​​​​​​&nbsp;Best Cow Line]]></title>
    <url>%2F2018%2F08%2F05%2FACM%2FThinking%2F%E8%B4%AA%E5%BF%83%20POJ%20-%203617%20%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8BBest%20Cow%20Line%2F</url>
    <content type="text"><![CDATA[Best Cow Line[ POJ - 3617 ] &nbsp;&nbsp;FJ is about to take his N (1 ≤ N ≤ 2,000) cows to the annual”Farmer of the Year” competition. In this contest every farmer arranges his cows in a line and herds them past the judges.&nbsp;&nbsp;The contest organizers adopted a new registration scheme this year: simply register the initial letter of every cow in the order they will appear (i.e., If FJ takes Bessie, Sylvia, and Dora in that order he just registers BSD). After the registration phase ends, every group is judged in increasing lexicographic order according to the string of the initials of the cows’ names.&nbsp;&nbsp;FJ is very busy this year and has to hurry back to his farm, so he wants to be judged as early as possible. He decides to rearrange his cows, who have already lined up, before registering them.&nbsp;&nbsp;FJ marks a location for a new line of the competing cows. He then proceeds to marshal the cows from the old line to the new one by repeatedly sending either the first or last cow in the (remainder of the) original line to the end of the new line. When he’s finished, FJ takes his cows for registration in this new order.&nbsp;&nbsp;Given the initial order of his cows, determine the least lexicographic string of initials he can make this way. Input Line 1: A single integer: N Lines 2..N+1: Line i+1 contains a single initial (‘A’..’Z’) of the cow in the ith position in the original line Output The least lexicographic string he can make. Every line (except perhaps the last one) contains the initials of 80 cows (‘A’..’Z’) in the new line. Sample Input12345676ACDBCB Sample Output1ABCBCD 这道题就每次比较前后即可主要是细节方面的问题1.这道题字符串输入是一个一个输入……要么用getchar()收集，或者直接scanf(“ %c”, &amp;s[i])收集空白符2.注意每80个换一下行123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;iostream&gt;using namespace std; int par[1010];int ran[1010]; void init(int n)&#123; for(int i=1; i&lt;=n; i++)&#123; par[i]=i; ran[i]=0; &#125;&#125; int find(int x)&#123; if(par[x]==x) return x; else return par[x]=find(par[x]);&#125; void unite(int x, int y)&#123; x=find(x); y=find(y); if(x==y) return; if(ran[x]&lt;ran[y])&#123; par[x]=y; &#125;else&#123; par[y]=x; if(ran[x]==ran[y]) ran[x]++; &#125;&#125; int main(void)&#123; int t, m, n, a, b; cin &gt;&gt; t; while(t--)&#123; scanf("%d%d", &amp;n, &amp;m); init(n); for(int i=0; i&lt;m; i++)&#123; scanf("%d%d", &amp;a, &amp;b); if(a&lt;b) swap(a, b); unite(a, b); &#125; int sum=0; for(int i=1; i&lt;=n; i++)&#123; if(par[i]==i) sum++; &#125; printf("%d\n", sum); getchar(); &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>Thinking</category>
        <category>贪心</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>Thinking</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DFS深入优先搜索 &nbsp;POJ-2386 &nbsp;Lake Counting]]></title>
    <url>%2F2018%2F08%2F05%2FACM%2FThinking%2FDFS%20POJ-2386%20Lake%20Counting%2F</url>
    <content type="text"><![CDATA[Lake Counting[POJ - 2386] Due to recent rains, water has pooled in various places in Farmer John’s field, which is represented by a rectangle of N x M (1 &lt;= N &lt;= 100; 1 &lt;= M &lt;= 100) squares. Each square contains either water (‘W’) or dry land (‘.’). Farmer John would like to figure out how many ponds have formed in his field. A pond is a connected set of squares with water in them, where a square is considered adjacent to all eight of its neighbors.Given a diagram of Farmer John’s field, determine how many ponds he has. Input Line 1: Two space-separated integers: N and M Lines 2..N+1: M characters per line representing one row of Farmer John’s field. Each character is either ‘W’ or ‘.’. The characters do not have spaces between them. Output Line 1: The number of ponds in Farmer John’s field. Sample Input123456789101110 12W........WW..WWW.....WWW....WW...WW..........WW..........W....W......W...W.W.....WW.W.W.W.....W..W.W......W...W.......W. Sample Output13 HintOUTPUT DETAILS:There are three ponds: one in the upper left, one in the lower left,and one along the right side. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstdlib&gt;using namespace std; int m, n;char garden[105][105]; void dfs(int x, int y)&#123; //将当前点取消标记，避免重复查找 garden[x][y] = '.'; //遍历周围的八个点 for (int dx = -1; dx &lt;= 1; dx++)&#123; for (int dy = -1; dy &lt;= 1;dy++)&#123; int nx = x + dx; int ny = y + dy; if(0&lt;=nx &amp;&amp; nx&lt;n &amp;&amp; 0&lt;=ny &amp;&amp; ny&lt;m &amp;&amp; garden[nx][ny]=='W') dfs(nx, ny); &#125; &#125;&#125; int main(void)&#123; while(~scanf("%d%d", &amp;n,&amp;m))&#123; getchar(); //吸收两数字后的换行符 memset(garden, 0, sizeof(garden)); for (int i = 0; i &lt; n;i++)&#123; for (int j = 0; j &lt; m;j++) scanf("%c", &amp;garden[i][j]); getchar(); //吸收每次输入一行后的换行符 &#125; int sum = 0; for (int i = 0; i &lt; n; i++)&#123; for (int j = 0; j &lt; m; j++)&#123; if (garden[i][j] == 'W')&#123; dfs(i, j); sum++; &#125; &#125; &#125; cout &lt;&lt; sum &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>Thinking</category>
        <category>DFS</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>Thinking</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DFS图的联通块 &nbsp;UVA-572 &nbsp;Oil Deposits]]></title>
    <url>%2F2018%2F08%2F05%2FACM%2FThinking%2FDFS%20UVA-572%20Oil%20Deposits%2F</url>
    <content type="text"><![CDATA[Oil Deposits[ UVA - 572 ]&nbsp;&nbsp;The GeoSurvComp geologic survey company is responsible for detecting underground oil deposits. GeoSurvComp works with one large rectangular region of land at a time, and creates a grid that divides the land into numerous square plots. It then analyzes each plot separately, using sensing equipment to determine whether or not the plot contains oil. &nbsp;&nbsp;A plot containing oil is called a pocket. If two pockets are adjacent, then they are part of the same oil deposit. Oil deposits can be quite large and may contain numerous pockets. Your job is to determine how many different oil deposits are contained in a grid. Input The input file contains one or more grids. Each grid begins with a line containing m and n, the number of rows and columns in the grid, separated by a single space. If m = 0 it signals the end of the input; otherwise 1 ≤ m ≤ 100 and 1 ≤ n ≤ 100. Following this are m lines of n characters each (not counting the end-of-line characters). Each character corresponds to one plot, and is either ‘*’, representing the absence of oil, or ‘@’, representing an oil pocket. Output For each grid, output the number of distinct oil deposits. Two different pockets are part of the same oil deposit if they are adjacent horizontally, vertically, or diagonally. An oil deposit will not contain more than 100 pockets. Sample Input1234567891011121314151 1*3 5*@*@***@***@*@*1 8@@****@*5 5****@*@@*@*@**@@@@*@@@**@0 0 Hint12340122 分析从每个”@”格子出发，递归遍历它周围的”@”格子。 每次访问就把他标记成”*”，即不通路（或者可以用数组表示是否访问过）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstdlib&gt;using namespace std; int m, n;char garden[105][105]; void dfs(int x, int y)&#123; //将当前点取消标记，避免重复查找 garden[x][y] = '*'; //遍历周围的八个点 for (int dx = -1; dx &lt;= 1; dx++)&#123; for (int dy = -1; dy &lt;= 1;dy++)&#123; int nx = x + dx; int ny = y + dy; if(0&lt;=nx &amp;&amp; nx&lt;n &amp;&amp; 0&lt;=ny &amp;&amp; ny&lt;m &amp;&amp; garden[nx][ny]=='@') dfs(nx, ny); &#125; &#125;&#125; int main(void)&#123; while(~scanf("%d%d", &amp;n, &amp;m) &amp;&amp; m+n)&#123; getchar(); //吸收两数字后的换行符 memset(garden, 0, sizeof(garden)); for (int i = 0; i &lt; n;i++)&#123; for (int j = 0; j &lt; m;j++) scanf("%c", &amp;garden[i][j]); getchar(); //吸收每次输入一行后的换行符 &#125; int sum = 0; for (int i = 0; i &lt; n; i++)&#123; for (int j = 0; j &lt; m; j++)&#123; if (garden[i][j] == '@')&#123; dfs(i, j); sum++; &#125; &#125; &#125; cout &lt;&lt; sum &lt;&lt; endl; &#125; system("pause"); return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>Thinking</category>
        <category>DFS</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>Thinking</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[贪心 &nbsp;POJ-2376 ​​​​​​​&nbsp;Cleaning Shifts]]></title>
    <url>%2F2018%2F08%2F05%2FACM%2FThinking%2F%E8%B4%AA%E5%BF%83%20POJ%20-%202376%20%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8BCleaning%20Shifts%2F</url>
    <content type="text"><![CDATA[Cleaning Shifts[ POJ - 2376 ] Farmer John is assigning some of his N (1 &lt;= N &lt;= 25,000) cows to do some cleaning chores around the barn. He always wants to have one cow working on cleaning things up and has divided the day into T shifts (1 &lt;= T &lt;= 1,000,000), the first being shift 1 and the last being shift T.Each cow is only available at some interval of times during the day for work on cleaning. Any cow that is selected for cleaning duty will work for the entirety of her interval.Your job is to help Farmer John assign some cows to shifts so that (i) every shift has at least one cow assigned to it, and (ii) as few cows as possible are involved in cleaning. If it is not possible to assign a cow to each shift, print -1. Input Line 1: Two space-separated integers: N and T Lines 2..N+1: Each line contains the start and end times of the interval during which a cow can work. A cow starts work at the start time and finishes after the end time. Output Line 1: The minimum number of cows Farmer John needs to hire or -1 if it is not possible to assign a cow to each shift. Sample Input12343 101 73 66 10 Sample Output12 HintThis problem has huge input data,use scanf() instead of cin to read data to avoid time limit exceed.INPUT DETAILS:There are 3 cows and 10 shifts. Cow #1 can work shifts 1..7, cow #2 can work shifts 3..6, and cow #3 can work shifts 6..10.OUTPUT DETAILS:By selecting cows #1 and #3, all shifts are covered. There is no way to cover all the shifts using fewer than 2 cows. 先对起始时间进行排序，然后对于没有取过的牛进行处理，判断即可。123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;queue&gt;using namespace std; const int maxn = 25050;pair&lt;int, int&gt; it[maxn]; int n, t; int main(void)&#123; cin &gt;&gt; n &gt;&gt; t; for (int i = 0; i &lt; n; i++) &#123; scanf("%d%d", &amp;it[i].first, &amp;it[i].second); &#125; sort(it, it + n); int sum = 0; int ju = 0, maxn = 0; while (maxn &lt; t) &#123; int ans = maxn + 1; for (int i = ju; i &lt; n; i++) &#123; if (it[i].first &lt;= ans &amp;&amp; it[i].second &gt;= ans) &#123; maxn = max(maxn, it[i].second); &#125;else if (it[i].first &gt; ans) &#123; ju = i; break; &#125; &#125; if(ans &gt; maxn) break; else sum++; &#125; if (maxn &gt;= t) cout &lt;&lt; sum &lt;&lt; endl; else cout &lt;&lt; "-1" &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>Thinking</category>
        <category>贪心</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>Thinking</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DFS:图的联通块&nbsp; AOJ-0118&nbsp; Property Distribution]]></title>
    <url>%2F2018%2F08%2F05%2FACM%2FThinking%2FDFS%20AOJ-0118%20Property%20Distribution%2F</url>
    <content type="text"><![CDATA[Property Distribution[ Aizu - 0118 ] 这道题类似于联通图问题，将联通的归成一个，数一下总共有几个即可。 因为题目告诉不会有空格，所以排除标记用空格表示即可。 タナカ氏が HW アールの果樹園を残して亡くなりました。果樹園は東西南北方向に H × W の区画に分けられ、区画ごとにリンゴ、カキ、ミカンが植えられています。タナカ氏はこんな遺言を残していました。 果樹園は区画単位でできるだけ多くの血縁者に分けること。ただし、ある区画の東西南北どれかの方向にとなりあう区画に同じ種類の果物が植えられていた場合は、区画の境界が分からないのでそれらは 1 つの大きな区画として扱うこと。 例えば次のような 3 × 10 の区画であれば (‘リ’はリンゴ、’カ’はカキ、’ミ’はミカンを表す) 同じ樹がある区画の間の境界を消すと次のようになり、 結局 10 個の区画、つまり 10 人で分けられることになります。 雪が降って区画の境界が見えなくなる前に分配を終えなくてはなりません。あなたの仕事は果樹園の地図をもとに分配する区画の数を決めることです。 果樹園の地図を読み込み、分配を受けられる血縁者の人数を出力するプログラムを作成してください。 Input 複数のデータセットが与えられます。各データセットは空白で区切られた H, W (H, W ≤ 100) を含む行から始まり、続いて H × W の文字からなる H 行の文字列が与えられます。この文字列には、リンゴを表す ‘@’、カキを表す ‘#’、ミカンを表す ‘*’、の 3 文字しか現れません。 入力はゼロが２つの行で終わります。データセットの数は 20 を超えません。 Output 複数のデータセットが与えられます。各データセットは空白で区切られた H, W (H, W ≤ 100) を含む行から始まり、続いて H × W の文字からなる H 行の文字列が与えられます。この文字列には、リンゴを表す ‘@’、カキを表す ‘#’、ミカンを表す ‘*’、の 3 文字しか現れません。 入力はゼロが２つの行で終わります。データセットの数は 20 を超えません。 Sample Input12345678910111210 10####*****@@#@@@@#*#*@##***@@@*#****#*@**##@*#@@*##*@@@@*@@@#***#@*@##**@@@*@@##@*@*#*@##**@****#@@#@0 0 Sample Output133 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstdlib&gt;using namespace std; int m, n;char garden[105][105];int d[4][2] = &#123; &#123;0, -1&#125;, &#123;1, 0&#125;, &#123;0, 1&#125;, &#123;-1, 0&#125;,&#125;; void dfs(int x, int y, char c)&#123; if(garden[x][y] == c)&#123; garden[x][y] = ' '; for (int i = 0; i &lt; 4; i++)&#123; int nx = x + d[i][1]; int ny = y + d[i][0]; if (0 &lt;= nx &amp;&amp; nx &lt; n &amp;&amp; 0 &lt;= ny &amp;&amp; ny &lt; m &amp;&amp; garden[nx][ny] != ' ') dfs(nx, ny, c); &#125; &#125;&#125; int main(void)&#123; while(~scanf("%d%d", &amp;n, &amp;m) &amp;&amp; m+n)&#123; getchar(); memset(garden, 0, sizeof(garden)); for (int i = 0; i &lt; n; i++)&#123; for (int j = 0; j &lt; m; j++) scanf("%c", &amp;garden[i][j]); getchar(); &#125; int sum = 0; for (int i = 0; i &lt; n; i++)&#123; for (int j = 0; j &lt; m; j++)&#123; if (garden[i][j] != ' ')&#123; dfs(i, j, garden[i][j]); sum++; &#125; &#125; &#125; cout &lt;&lt; sum &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>Thinking</category>
        <category>DFS</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>Thinking</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello Hexo]]></title>
    <url>%2F2018%2F08%2F04%2FOthers%2Fhello-hexo%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
