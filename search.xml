<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[更换个人博客地址]]></title>
    <url>%2F2018%2F08%2F05%2F%E6%9B%B4%E6%8D%A2%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%9C%B0%E5%9D%80%2F</url>
    <content type="text"><![CDATA[博客搬家了！&emsp;从csdn搬过来了，同时原csdn博客基本不再更新（有时候嫌麻烦会更新，但这里会同步） 原csdn博客地址：MFDY’s csdn blog]]></content>
  </entry>
  <entry>
    <title><![CDATA[线段树 &nbsp;HDU-1166 &nbsp;敌兵布阵]]></title>
    <url>%2F2018%2F08%2F05%2F%E7%BA%BF%E6%AE%B5%E6%A0%91-HDU-1166%2F</url>
    <content type="text"><![CDATA[敌兵布阵[HDU - 1166] &nbsp;&nbsp;&nbsp;&nbsp;C国的死对头A国这段时间正在进行军事演习，所以C国间谍头子Derek和他手下Tidy又开始忙乎了。A国在海岸线沿直线布置了N个工兵营地,Derek和Tidy的任务就是要监视这些工兵营地的活动情况。由于采取了某种先进的监测手段，所以每个工兵营地的人数C国都掌握的一清二楚,每个工兵营地的人数都有可能发生变动，可能增加或减少若干人手,但这些都逃不过C国的监视。&nbsp;&nbsp;&nbsp;&nbsp;中央情报局要研究敌人究竟演习什么战术,所以Tidy要随时向Derek汇报某一段连续的工兵营地一共有多少人,例如Derek问:“Tidy,马上汇报第3个营地到第10个营地共有多少人!”Tidy就要马上开始计算这一段的总人数并汇报。但敌兵营地的人数经常变动，而Derek每次询问的段都不一样，所以Tidy不得不每次都一个一个营地的去数，很快就精疲力尽了，Derek对Tidy的计算速度越来越不满:”你个死肥仔，算得这么慢，我炒你鱿鱼!”Tidy想：“你自己来算算看，这可真是一项累人的工作!我恨不得你炒我鱿鱼呢!”无奈之下，Tidy只好打电话向计算机专家Windbreaker求救,Windbreaker说：“死肥仔，叫你平时做多点acm题和看多点算法书，现在尝到苦果了吧!”Tidy说：”我知错了。。。”但Windbreaker已经挂掉电话了。Tidy很苦恼，这么算他真的会崩溃的，聪明的读者，你能写个程序帮他完成这项工作吗？不过如果你的程序效率不够高的话，Tidy还是会受到Derek的责骂的. Input 第一行一个整数T，表示有T组数据。每组数据第一行一个正整数N（N&lt;=50000）,表示敌人有N个工兵营地，接下来有N个正整数,第i个正整数ai代表第i个工兵营地里开始时有ai个人（1&lt;=ai&lt;=50）。接下来每行有一条命令，命令有4种形式：(1) Add i j,i和j为正整数,表示第i个营地增加j个人（j不超过30）(2)Sub i j ,i和j为正整数,表示第i个营地减少j个人（j不超过30）;(3)Query i j ,i和j为正整数,i&lt;=j，表示询问第i到第j个营地的总人数;(4)End 表示结束，这条命令在每组数据最后出现;每组数据最多有40000条命令 Output 对第i组数据,首先输出“Case i:”和回车,对于每个Query询问，输出一个整数并回车,表示询问的段中的总人数,这个数保持在int以内。 Sample Input123456789101101 2 3 4 5 6 7 8 9 10Query 1 3Add 3 6Query 2 7Sub 10 2Add 6 3Query 3 10End Sample Output1234Case 1:63359 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;string&gt;using namespace std; struct Node&#123; int l, r, sum;&#125;t[210000]; int a[210000]; void build(int l, int r, int k) &#123; t[k].l=l; t[k].r=r; if(l==r)&#123; t[k].sum=a[r]; &#125;else&#123; build(l, (l+r)/2, k*2); build((l+r)/2+1, r, k*2+1); t[k].sum=t[k*2].sum+t[k*2+1].sum; &#125;&#125; int query(int l, int r, int k)&#123; if(t[k].l&gt;=l &amp;&amp; t[k].r&lt;=r) return t[k].sum; else&#123; int m=(t[k].l+t[k].r)/2; int ans=0; if(l&lt;=m) ans+=query(l, r, 2*k); if(r&gt;m) ans+=query(l, r, 2*k+1); return ans; &#125; &#125; void add(int a,int b,int k)&#123; t[k].sum+=b; if(t[k].l==a &amp;&amp; t[k].r==a) return; if(a&gt;(t[k].l+t[k].r)/2) add(a, b, 2*k+1); else add(a, b, 2*k);&#125; void sub(int a,int b,int k)&#123; t[k].sum-=b; if(t[k].l==a &amp;&amp; t[k].r==a) return; if(a&gt;(t[k].l+t[k].r)/2) sub(a, b, 2*k+1); else sub(a, b, 2*k);&#125; int main(void)&#123; int n,T; char command[6]; scanf("%d", &amp;T); for (int i=1; i&lt;=T; i++) &#123; scanf("%d", &amp;n); for (int j=1; j&lt;=n; j++) scanf("%d", &amp;a[j]); build(1, n, 1); cout &lt;&lt; "Case " &lt;&lt; i &lt;&lt; ":" &lt;&lt; endl; int a,b; while (scanf("%s", command)) &#123; if (strcmp(command,"End")==0) break; scanf("%d%d", &amp;a, &amp;b); if(strcmp(command,"Query")==0) cout &lt;&lt; query(a, b, 1) &lt;&lt; endl; else if(strcmp(command,"Add")==0) add(a, b, 1); else if(strcmp(command,"Sub")==0) sub(a, b, 1); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>线段树</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线段树 &nbsp;HDU-1754 &nbsp;I Hate It]]></title>
    <url>%2F2018%2F08%2F05%2F%E7%BA%BF%E6%AE%B5%E6%A0%91-HDU-1754%2F</url>
    <content type="text"><![CDATA[I Hate It[HDU - 1754] 很多学校流行一种比较的习惯。老师们很喜欢询问，从某某到某某当中，分数最高的是多少。这让很多学生很反感。不管你喜不喜欢，现在需要你做的是，就是按照老师的要求，写一个程序，模拟老师的询问。当然，老师有时候需要更新某位同学的成绩。 Input 本题目包含多组测试，请处理到文件结束。在每个测试的第一行，有两个正整数 N 和 M ( 0&lt;N&lt;=200000,0&lt;M&lt;5000 )，分别代表学生的数目和操作的数目。学生ID编号分别从1编到N。第二行包含N个整数，代表这N个学生的初始成绩，其中第i个数代表ID为i的学生的成绩。接下来有M行。每一行有一个字符 C (只取’Q’或’U’) ，和两个正整数A，B。当C为’Q’的时候，表示这是一条询问操作，它询问ID从A到B(包括A,B)的学生当中，成绩最高的是多少。当C为’U’的时候，表示这是一条更新操作，要求把ID为A的学生的成绩更改为B。 Output 对于每一次询问操作，在一行里面输出最高成绩。 Sample Input123456785 61 2 3 4 5Q 1 5U 3 6Q 3 4Q 4 5U 2 9Q 1 5 Sample Output12345659 Hint1Huge input,the C function scanf() will work better than cin 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;string&gt;#include&lt;cstring&gt;using namespace std; struct node&#123; int l,r,max;&#125;t[810000]; int A[210000],max; int MAX(int a, int b)&#123; return a&gt;b ? a:b;&#125; void build(int l,int r,int k)&#123; t[k].l=l; t[k].r=r; if(l==r) t[k].max=A[r]; else&#123; build(l,(l+r)/2,k&lt;&lt;1); build((l+r)/2+1,r,k&lt;&lt;1|1); t[k].max=MAX(t[k&lt;&lt;1].max, t[k&lt;&lt;1|1].max); &#125;&#125; int query(int l,int r,int k)&#123; if(t[k].l&gt;=l &amp;&amp; t[k].r&lt;=r) return t[k].max; else&#123; int ans=0; int m=(t[k].l+t[k].r)/2; if(l&lt;=m) ans=query(l,r,k&lt;&lt;1); if(r&gt;m) ans=MAX(ans,query(l,r,k&lt;&lt;1|1)); return ans; &#125; &#125; void change(int a,int b,int k)&#123; if(t[k].l==a &amp;&amp; t[k].r==a)&#123; t[k].max=b; return; &#125; if(a&gt;(t[k].l+t[k].r)/2) change(a,b,2*k+1); else change(a,b,2*k); t[k].max=MAX(t[k*2].max, t[k*2+1].max);&#125; int main(void) &#123; int l,r,k,n,m; char command; while(scanf("%d%d",&amp;n,&amp;m)!=EOF)&#123; memset(t,0,sizeof(t)); memset(A,0,sizeof(A)); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;A[i]); build(1,n,1); getchar(); while(m--&gt;0)&#123; int a, b; scanf("%c%d%d",&amp;command,&amp;a,&amp;b); getchar(); if(command=='Q') cout &lt;&lt; query(a,b,1) &lt;&lt; endl; else if(command=='U') change(a,b,1); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>线段树</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello Hexo]]></title>
    <url>%2F2018%2F08%2F04%2Fhello-hexo%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
