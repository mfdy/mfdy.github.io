<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[数位DP 石子合并 模板题]]></title>
    <url>%2F2019%2F09%2F27%2FACM%2FDP%2FDigital%20DP%2F%E6%95%B0%E4%BD%8DDP%20%E7%9F%B3%E5%AD%90%E5%90%88%E5%B9%B6%20%E6%A8%A1%E6%9D%BF%E9%A2%98%2F</url>
    <content type="text"><![CDATA[数位DP模板题 石子合并 题目有n堆石子排成一排，每堆石子有一定的数量，将n堆石子合并成一堆。合并的规则是每次只能合并相邻的两堆石子，合并的花费为这两堆石子的总数，求最小花费。 思路题解代码123456789101112131415161718192021222324252627282930313233343536#include&lt;bits/stdc++.h&gt;using namespace std;int sum[1010];int dp[1010][1010], s[1010][1010];int n, x;int main(void)&#123; while (~scanf("%d", &amp;n)) &#123; sum[0] = 0; for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;x); sum[i] = sum[i - 1] + x; &#125; for (int i = 1; i &lt;= n; i++) &#123; dp[i][i] = 0; s[i][i] = i; &#125; for (int len = 1; len &lt; n; len++) &#123; for (int i = 1; i &lt;= n - len; i++) &#123; int j = i + len; dp[i][j] = INF; for (int k = s[i][j - 1]; k &lt;= s[i + 1][j]; k++) &#123; if (dp[i][k] + dp[k + 1][j] + sum[j] - sum[i -1] &lt; dp[i][j]) &#123; dp[i][j] = dp[i][k] + dp[k + 1][j] + sum[j] - sum[i - 1]; s[i][j] = k; &#125; &#125; &#125; &#125; cout &lt;&lt; dp[1][n] &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>动态规划</category>
        <category>数位DP</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数位DP 回文序列 POJ-3280 Cheapest Palindrome]]></title>
    <url>%2F2019%2F09%2F23%2FACM%2FDP%2FDigital%20DP%2F%E6%95%B0%E4%BD%8DDP%20%E5%9B%9E%E6%96%87%E5%BA%8F%E5%88%97%20POJ-3280%20Cheapest%20Palindrome%2F</url>
    <content type="text"><![CDATA[Cheapest Palindrome[ POJ - 3280 ] 题目大意：给定字符串s，长度为m，由n个小写字母组成。在s的任意位置增删字母，把它变成回文串，增删特定字母的花费不同，求最小花费 思路定义状态dp[i][j]表示字符串s的子区间s[i, j]变成回文的最小花费 那么每次有三种情况: 如果s[i] == s[j], 那么dp[i][j] = dp[i + 1][j - 1]。 如果dp[i + 1][j]是回文串, 那么dp[i][j] = dp[i + 1][j] + w[i]。 如果dp[i][j - 1]是回文串, 那么dp[i][j] = dp[i][j - 1] + w[j]。 2, 3情况的状态转移方程就是dp[i][j] = min(dp[i + 1][j] + w[i], dp[i][j - 1] + w[j]) 题解代码123456789101112131415161718192021222324252627282930#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int w[30], dp[2010][2010];char s[2010], ch;int n, m;int main(void)&#123; int x, y; while (cin &gt;&gt; n &gt;&gt; m) &#123; cin &gt;&gt; s; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; ch &gt;&gt; x &gt;&gt; y; w[ch - 'a'] = min(x, y); &#125; for (int i = m - 1; i &gt;= 0; i--) &#123; // i是子区间的起点 for (int j = i + 1; j &lt; m; j++) &#123; // j是子区间的终点 if (s[i] == s[j]) dp[i][j] = dp[i + 1][j - 1]; else dp[i][j] = min(dp[i + 1][j] + w[s[i] - 'a'], dp[i][j - 1] + w[s[j] - 'a']); &#125; &#125; cout &lt;&lt; dp[0][m - 1] &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>动态规划</category>
        <category>数位DP</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模拟退火 HDU - 2899 Strange Function]]></title>
    <url>%2F2019%2F09%2F22%2FACM%2FThinking%2F%E6%A8%A1%E6%8B%9F%E9%80%80%E7%81%AB%20HDU%20-%202899%20Strange%20Function%2F</url>
    <content type="text"><![CDATA[Strange Function[ HDU - 2899 ] 题目大意：函数 F(x) = 6x7 + 8x6 + 7x3 + 5x2 - yx, 其中x的范围是0 ≤ x ≤ 100.输入y值，输出F(x)的最小值 模拟退火算法模拟退火就是类似于物体降温的概率，来进行多次搜索迭代 在迭代过程中，模拟退火算法随机选择下一个状态，有两种可能 新状态比原来状态更优，那么接受这个新状态 新状态更差，那么以一定的概率接受该状态，不过这个概率应该随着时间的推移逐渐降低 模拟退火算法的主要步骤如下： 设置一个初始的温度T 温度下降，状态转移。从当前温度按降温系数下降到下一个温度，在新的温度计算当前状态 如果温度降到设定的温度下界，程序停止 伪代码1234567891011121314eps = 1e-8; // 终止温度，接近0，用于控制精度T = 100; // 初始温度，应该是高温，以100℃为例delta = 0.98; // 降温系数，控制退火的快慢，小于1，以0.98为例g(x); // 状态x时的评价函数，例如物理意义上的能量now, next; // 当前状态和新状态while (T &gt; eps) &#123; // 如果温度未降到eps g(next), g(now); // 计算能量 dE = g(next) - g(now); // 能量差 if (dE &gt;= 0) // 新状态更优， 接受新状态 now = next; else if (exp(dE / T) &gt; rand()) // 如果新状态更差，在一定概率下接受他，e^(dE/T) now = next; T *= delta; // 降温，退火过程模拟&#125; 常见问题模拟退火算法在ACM中的典型问题有函数最值问题、TSP旅行商问题、最小圆覆盖、最小球覆盖等 题解代码1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;bits/stdc++.h&gt;using namespace std;const double eps = 1e-8; // 终止温度double y;double func(double x) // 计算函数值&#123; return 6 * pow(x, 7.0) + 8 * pow(x, 6.0) + 7 * pow(x, 3.0) + 5 * pow(x, 2.0) - y * x;&#125;double solve(void)&#123; double T = 100; // 初始温度 double delta = 0.98; // 降温系数 double x = 50.0; // x的初始值 double now = func(x); // 计算初始函数值 double ans = now; // 返回值 while (T &gt; eps) &#123; int f[2] = &#123;1, -1&#125;; double newx = x + f[rand() % 2] * T; // 按概率改变x，随t的降温而减少 if (newx &gt;= 0 &amp;&amp; newx &lt;= 100) &#123; double next = func(newx); ans = min(ans, next); if (now - next &gt; eps) &#123; x = newx; now = next; &#125; &#125; T *= delta; &#125; return ans;&#125;int main(void)&#123; int cas; scanf("%d", &amp;cas); while (cas--) &#123; scanf("%lf", &amp;y); printf("%.4lf\n", solve()); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>Thinking</category>
        <category>模拟退火</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>Thinking</tag>
        <tag>模拟退火</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bitset HDU6515 Coding Problem]]></title>
    <url>%2F2019%2F09%2F18%2FACM%2FSTL%2Fbitset%20HDU6515%20Coding%20Problem%2F</url>
    <content type="text"><![CDATA[Coding Problem[ HDU - 6515 ] 题目大意：给你一个字符串，每个字母的ASCII二级制颠倒过来组成一个01数组。然后这个数组每六位组成一个数字的ASCII输出 一道模拟题，使用C++中的bitset类型会简单的很多 那么正好来学习一下bitset的用法： bitset此处参考了这份博客：https://www.cnblogs.com/magisk/p/8809922.html bitset大概就是一个二进制数组，每个位置只占1bit，想一下状压dp？ bitset的原理大概是将很多数压成一个，从而节省空间和时间（暴力出奇迹） 构造构造时可以直接指定大小，也可以使用string和字符串数组来进行构造需要注意的是，在使用字符串构造时，字符串中只能包含01，否则会抛出异常 123456789101112bitset&lt;4&gt; bitset1; //无参构造，长度为４，默认每一位为０bitset&lt;8&gt; bitset2(12); //长度为８，二进制保存，前面用０补充string s = "100101";bitset&lt;10&gt; bitset3(s); //长度为10，前面用０补充char s2[] = "10101";bitset&lt;13&gt; bitset4(s2); //长度为13，前面用０补充cout &lt;&lt; bitset1 &lt;&lt; endl; //0000cout &lt;&lt; bitset2 &lt;&lt; endl; //00001100cout &lt;&lt; bitset3 &lt;&lt; endl; //0000100101cout &lt;&lt; bitset4 &lt;&lt; endl; //0000000010101 性质它支持所有的位运算操作：^ &amp; | &gt;&gt; 等 bitset的函数1234567891011121314bit.size() 返回大小（位数）bit.count() 返回1的个数bit.any() 返回是否有1bit.none() 返回是否没有1bit.set() 全都变成1bit.set(p) 将第p + 1位变成1（bitset是从第0位开始的！）bit.set(p, x) 将第p + 1位变成xbit.reset() 全都变成0bit.reset(p) 将第p + 1位变成0bit.flip() 全都取反bit.flip(p) 将第p + 1位取反bit.to_ulong() 返回它转换为unsigned long的结果，如果超出范围则报错bit.to_ullong() 返回它转换为unsigned long long的结果，如果超出范围则报错bit.to_string() 返回它转换为string的结果 题解需要注意的坑点是这道题不能有换行符，行尾有空格 代码如下 12345678910111213141516171819202122232425262728#include &lt;bits/stdc++.h&gt;using namespace std;string change(char c)&#123; bitset&lt;8&gt; b((int)c); stringstream str; string s; str &lt;&lt; b; str &gt;&gt; s; reverse(s.begin(), s.end()); return s;&#125;int main(void)&#123; string s; cin &gt;&gt; s; for (int i = 0; i &lt; s.size(); i+= 3) &#123; string ts = change(s[i]) + change(s[i + 1]) + change(s[i + 2]); for (int j = 0; j &lt; ts.size(); j+= 6) &#123; bitset&lt;6&gt; B(ts, j, 6); printf("%d ", B); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>STL</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二维前缀和+差分 HDU6514 Monitor]]></title>
    <url>%2F2019%2F09%2F18%2FACM%2FThinking%2F%E4%BA%8C%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C%2B%E5%B7%AE%E5%88%86%20HDU6514%20Monitor%2F</url>
    <content type="text"><![CDATA[Monitor[ HDU - 6514 ] 题目大意：给你个n×m的区域，每个区域被选中标记为1，没被选中标记为0，然后给一些标记的区域，查询若干个区域问是否有0的 一道二维前缀和的题目，想通没什么难度 代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;bits/stdc++.h&gt;using namespace std;#define IO ios::sync_with_stdio(false), cin.tie(0), cout.tie(0)#define fin freopen("in.txt", "r", stdin)#define fout freopen("out.txt", "w", stdout)typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int, int&gt; P;const int maxn = 1e7 + 10;const int INF = 0x3f3f3f3f;const double eps = 1e-5;int n, m, p, q;int a[maxn];int getid(int i, int j)&#123; if (i == 0 || j == 0 || i &gt; n || j &gt; m) return 0; return (i - 1) * m + j;&#125;void add(int i, int j, int v)&#123; int id = getid(i, j); if (!id) return; a[id] += v;&#125;int main(void)&#123; IO; while (~scanf("%d%d", &amp;n, &amp;m)) &#123; memset(a, 0, sizeof(a)); int x1, y1, x2, y2; scanf("%d", &amp;p); for (int i = 0; i &lt; p; i++) &#123; scanf("%d%d%d%d", &amp;x1, &amp;y1, &amp;x2, &amp;y2); add(x1, y1, 1); add(x2 + 1, y2 + 1, 1); add(x1, y2 + 1, -1); add(x2 + 1, y1, -1); &#125; for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) a[getid(i, j)] += a[getid(i - 1, j)] + a[getid(i, j - 1)] - a[getid(i - 1, j - 1)]; for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) if (a[getid(i,j)] &gt; 0) a[getid(i, j)] = 1; for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) a[getid(i, j)] += a[getid(i - 1, j)] + a[getid(i, j - 1)] - a[getid(i - 1, j - 1)]; scanf("%d", &amp;q); for (int i = 0; i &lt; q; i++) &#123; scanf("%d%d%d%d", &amp;x1, &amp;y1, &amp;x2, &amp;y2); int ans = a[getid(x2, y2)] - a[getid(x1 - 1, y2)] - a[getid(x2, y1 - 1)] + a[getid(x1 - 1, y1 - 1)]; if (ans == (x2 - x1 + 1) * (y2 - y1 + 1)) puts("YES"); else puts("NO"); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>Thinking</category>
        <category>前缀和</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>Thinking</tag>
        <tag>前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线段树+扫描线 POJ2482 Stars in Your Windows]]></title>
    <url>%2F2019%2F08%2F06%2FACM%2FData%20Structure%2FSegment%20Tree%2F%E7%BA%BF%E6%AE%B5%E6%A0%91%2B%E6%89%AB%E6%8F%8F%E7%BA%BF%20POJ2482%20Stars%20in%20Your%20Windows%2F</url>
    <content type="text"><![CDATA[Stars in Your Windows[ POJ - 2482 ] 题目大意：给出n个星星的坐标，每个星星有一个亮度，给出一个矩形的长和宽，问矩形能包括的星星的最大亮度和 题解代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include &lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;stdlib.h&gt;using namespace std;#define N 20010#define LL long longstruct node&#123; LL lx,rx,y,s; node()&#123;&#125; node(LL a,LL b,LL c,LL d):lx(a),rx(b),y(c),s(d)&#123;&#125; bool operator &lt;(const node &amp;S)const &#123; if(y==S.y) return s&gt;S.s; return y&lt;S.y; &#125;&#125;te[N];int sum[N&lt;&lt;2],cov[N&lt;&lt;2],que[N];int bin(LL x,int n)&#123; int s=0,e = n,m; while(s&lt;=e) &#123; m = (s+e)/2; if(que[m]==x) return m; else if(que[m]&gt;x) e = m-1; else s = m+1; &#125; return m;&#125;void pushdown(int w)&#123; if(cov[w]) &#123; cov[w&lt;&lt;1] += cov[w]; cov[w&lt;&lt;1|1] += cov[w]; sum[w&lt;&lt;1] += cov[w]; sum[w&lt;&lt;1|1] += cov[w]; cov[w] = 0; &#125;&#125;void pushup(int w)&#123; sum[w] = max(sum[w&lt;&lt;1],sum[w&lt;&lt;1|1]);&#125;void update(int a,int b,int d,int l,int r,int w)&#123; if(a&lt;=l&amp;&amp;b&gt;=r) &#123; sum[w]+=d; cov[w]+=d; return ; &#125; pushdown(w); int m = (l+r)&gt;&gt;1; if(a&lt;=m) update(a,b,d,l,m,w&lt;&lt;1); if(b&gt;m) update(a,b,d,m+1,r,w&lt;&lt;1|1); pushup(w);&#125;int main()&#123; int i,k,n; LL w,h,x,y,v; while(cin&gt;&gt;n&gt;&gt;w&gt;&gt;h) &#123; int num = 0; w--;h--; for(i = 1; i &lt;= n ;i++) &#123; cin&gt;&gt;x&gt;&gt;y&gt;&gt;v; que[num] = x; te[num++] = node(x,x+w,y,v); que[num] = x+w; te[num++] = node(x,x+w,y+h,-v); &#125; sort(que,que+num); sort(te,te+num); k = 1; for(i = 1 ; i &lt; num ; i++) &#123; if(que[i]!=que[i-1]) que[k++] = que[i]; &#125; int maxz = 0; for(i = 0 ; i &lt; num ; i++) &#123; int l = bin(te[i].lx,k-1); int r = bin(te[i].rx,k-1); update(l,r,te[i].s,0,k-1,1); maxz = max(maxz,sum[1]); &#125; cout &lt;&lt; maxz &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>Data Structure</category>
        <category>线段树</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>Data Structure</tag>
        <tag>线段树</tag>
        <tag>扫描线</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线段树+扫描线 HDU1542 Picture]]></title>
    <url>%2F2019%2F08%2F04%2FACM%2FData%20Structure%2FSegment%20Tree%2F%E7%BA%BF%E6%AE%B5%E6%A0%91%2B%E6%89%AB%E6%8F%8F%E7%BA%BF%20HDU1828%20Picture%2F</url>
    <content type="text"><![CDATA[Picture[ HDU - 1828 ] 题目大意：给你n个矩形的左下角坐标和右上角坐标，求外周长。 题解扫描线 + 离散化板子 将横竖两次扫描简化 代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 10010;const int maxN = 80010;const int INF = 0x3f3f3f3f;inline int read(void)&#123; int w = 1, d = 0; char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123; if (ch == '-') w = -1; ch = getchar(); &#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123; d = d * 10 + ch - '0'; ch = getchar(); &#125; return w * d;&#125;struct Node &#123; int l, r, cnt; int lc, rc; int len, num;&#125; tree[maxN];struct node &#123; int x1, x2, y, flag; void init(int l, int r, int h, int f) &#123; x1 = l, x2 = r, y = h, flag = f; &#125; bool operator &lt; (const node&amp; a) &#123; return y &lt; a.y; &#125;&#125; line[maxn];int n, x1, y11, x2, y2;void build_tree(int id, int l, int r)&#123; tree[id].l = l; tree[id].r = r; tree[id].cnt = 0; tree[id].len = 0; tree[id].lc = 0; tree[id].rc = 0; tree[id].num = 0; if (l == r) return; int mid = (l + r) &gt;&gt; 1; build_tree(id &lt;&lt; 1, l, mid); build_tree(id &lt;&lt; 1 | 1, mid + 1, r);&#125;void getlen(int i)&#123; if (tree[i].cnt) &#123; tree[i].len = tree[i].r - tree[i].l + 1; tree[i].lc = tree[i].rc = 1; tree[i].num = 1; &#125;else if (tree[i].l == tree[i].r) &#123; tree[i].len = 0; tree[i].lc = tree[i].rc = 0; tree[i].num = 0; &#125; else &#123; tree[i].len = tree[i &lt;&lt; 1].len + tree[i &lt;&lt; 1 | 1].len; tree[i].lc = tree[i &lt;&lt; 1].lc; tree[i].rc = tree[i &lt;&lt; 1 | 1].rc; tree[i].num = tree[i &lt;&lt; 1].num + tree[i &lt;&lt; 1 | 1].num - (tree[i &lt;&lt; 1].rc &amp; tree[i &lt;&lt; 1 | 1].lc); &#125;&#125;void update(int id, int l, int r, int v)&#123; if (tree[id].l == l &amp;&amp; tree[id].r == r) &#123; tree[id].cnt += v; getlen(id); return; &#125; int mid = (tree[id].l + tree[id].r) &gt;&gt; 1; if (r &lt;= mid) update(id &lt;&lt; 1, l, r, v); else if (l &gt; mid) update(id &lt;&lt; 1 | 1, l, r, v); else &#123; update(id &lt;&lt; 1, l, mid, v); update(id &lt;&lt; 1 | 1, mid + 1, r, v); &#125; getlen(id);&#125;int main(void)&#123; ios::sync_with_stdio(false); while (~scanf("%d", &amp;n)) &#123; int minn = INF, maxx = -INF; for (int i = 0; i &lt; n; i++) &#123; x1 = read(), y11 = read(), x2 = read(), y2 = read(); maxx = max(maxx, max(x1, x2)); minn = min(minn, min(x1, x2)); line[i].init(x1, x2, y11, 1); line[i + n].init(x1, x2, y2, -1); &#125; sort(line, line + 2 * n); build_tree(1, minn, maxx - 1); long long ans = 0, last = 0; for (int i = 0; i &lt; 2 * n; i++) &#123; update(1, line[i].x1, line[i].x2 - 1, line[i].flag); ans += abs(tree[1].len - last); ans += (line[i + 1].y - line[i].y) * tree[1].num * 2; last = tree[1].len; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>Data Structure</category>
        <category>线段树</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>Data Structure</tag>
        <tag>线段树</tag>
        <tag>扫描线</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线段树+扫描线 HDU3642 Get The Treasury]]></title>
    <url>%2F2019%2F08%2F04%2FACM%2FData%20Structure%2FSegment%20Tree%2F%E7%BA%BF%E6%AE%B5%E6%A0%91%2B%E6%89%AB%E6%8F%8F%E7%BA%BF%20HDU3642%20Get%20The%20Treasury%2F</url>
    <content type="text"><![CDATA[Get The Treasury[ HDU - 3642 ] 题目大意：给你n个立方体的左下角坐标和右上角坐标，求立方体相交至少相交的面积。 题解将Z轴离散化，把面积当作二维的底和高 代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXN=2010;struct Node&#123; int l,r; int lf,rf;//实际的左右端点 int c; int once,twice,more;&#125;segTree[MAXN*3];int y[MAXN];int z[MAXN];struct Line&#123; int x; int y1,y2; int z1,z2;//这两个是枚举的时候判断使用的 int f;&#125;line[MAXN];bool cmp(Line a,Line b)&#123; return a.x&lt;b.x;&#125;void Build(int i,int l,int r)&#123; segTree[i].l=l; segTree[i].r=r; segTree[i].lf=y[l]; segTree[i].rf=y[r]; segTree[i].c=0; segTree[i].once=segTree[i].twice=segTree[i].more=0; if(r==l+1)return; int mid=(l+r)&gt;&gt;1; Build(i&lt;&lt;1,l,mid); Build((i&lt;&lt;1)|1,mid,r);&#125;void push_up(int i)&#123; if(segTree[i].c&gt;2) &#123; segTree[i].more=segTree[i].rf-segTree[i].lf; segTree[i].once=segTree[i].twice=0; &#125; else if(segTree[i].c==2) &#123; if(segTree[i].l+1==segTree[i].r)//叶子结点 &#123; segTree[i].more=0; segTree[i].twice=segTree[i].rf-segTree[i].lf; segTree[i].once=0; return; &#125; segTree[i].more=segTree[i&lt;&lt;1].once+segTree[i&lt;&lt;1].twice+segTree[i&lt;&lt;1].more +segTree[(i&lt;&lt;1)|1].once+segTree[(i&lt;&lt;1)|1].twice+segTree[(i&lt;&lt;1)|1].more; segTree[i].twice=segTree[i].rf-segTree[i].lf-segTree[i].more; segTree[i].once=0; &#125; else if(segTree[i].c==1) &#123; if(segTree[i].l+1==segTree[i].r) &#123; segTree[i].more=0; segTree[i].twice=0; segTree[i].once=segTree[i].rf-segTree[i].lf; return; &#125; segTree[i].more=segTree[i&lt;&lt;1].more+segTree[i&lt;&lt;1].twice +segTree[(i&lt;&lt;1)|1].more+segTree[(i&lt;&lt;1)|1].twice; segTree[i].twice=segTree[i&lt;&lt;1].once+segTree[(i&lt;&lt;1)|1].once; segTree[i].once=segTree[i].rf-segTree[i].lf-segTree[i].more-segTree[i].twice; &#125; else &#123; if(segTree[i].l+1==segTree[i].r) &#123; segTree[i].more=segTree[i].once=segTree[i].twice=0; return; &#125; segTree[i].more=segTree[i&lt;&lt;1].more+segTree[(i&lt;&lt;1)|1].more; segTree[i].twice=segTree[i&lt;&lt;1].twice+segTree[(i&lt;&lt;1)|1].twice; segTree[i].once=segTree[i&lt;&lt;1].once+segTree[(i&lt;&lt;1)|1].once; &#125;&#125;void update(int i,Line e)&#123; if(segTree[i].lf&gt;=e.y1 &amp;&amp; segTree[i].rf&lt;=e.y2) &#123; segTree[i].c+=e.f; push_up(i); return; &#125; if(e.y2&lt;=segTree[i&lt;&lt;1].rf) update(i&lt;&lt;1,e); else if(e.y1&gt;=segTree[(i&lt;&lt;1)|1].lf) update((i&lt;&lt;1)|1,e); else &#123; Line temp=e; temp.y2=segTree[i&lt;&lt;1].rf; update(i&lt;&lt;1,temp); temp=e; temp.y1=segTree[(i&lt;&lt;1)|1].lf; update((i&lt;&lt;1)|1,temp); &#125; push_up(i);&#125;Line temp[MAXN];int main(void)&#123; int T; int n; int x1,y1,z1,x2,y2,z2; scanf("%d",&amp;T); int iCase=0; while(T--) &#123; iCase++; scanf("%d",&amp;n); int t=0; for(int i=0;i&lt;n;i++) &#123; scanf("%d%d%d%d%d%d", &amp;x1, &amp;y1, &amp;z1, &amp;x2, &amp;y2, &amp;z2); line[t].x=x1; line[t].y1=y1; line[t].y2=y2; line[t].z1=z1; line[t].z2=z2; line[t].f=1; y[t]=y1; z[t++]=z1; line[t].x=x2; line[t].y1=y1; line[t].y2=y2; line[t].z1=z1; line[t].z2=z2; line[t].f=-1; y[t]=y2; z[t++]=z2; &#125; sort(line,line+t,cmp); sort(y,y+t); int t1=unique(y,y+t)-y; Build(1,0,t1-1); sort(z,z+t); int t2=unique(z,z+t)-z; long long ans=0; long long area=0; for(int i=0;i&lt;t2-1;i++) &#123; int m=0; for(int j=0;j&lt;t;j++) if(line[j].z1&lt;=z[i]&amp;&amp;line[j].z2&gt;z[i]) temp[m++]=line[j]; area=0; update(1,temp[0]); for(int j=1;j&lt;m;j++) &#123; area+=(long long)segTree[1].more*(temp[j].x-temp[j-1].x); update(1,temp[j]); &#125; ans+=area*(z[i+1]-z[i]); &#125; printf("Case %d: %I64d\n",iCase,ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>Data Structure</category>
        <category>线段树</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>Data Structure</tag>
        <tag>线段树</tag>
        <tag>扫描线</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线段树+扫描线 HDU1542 覆盖的面积]]></title>
    <url>%2F2019%2F08%2F04%2FACM%2FData%20Structure%2FSegment%20Tree%2F%E7%BA%BF%E6%AE%B5%E6%A0%91%2B%E6%89%AB%E6%8F%8F%E7%BA%BF%20HDU1255%20%E8%A6%86%E7%9B%96%E7%9A%84%E9%9D%A2%E7%A7%AF%2F</url>
    <content type="text"><![CDATA[覆盖的面积[ HDU - 1255 ] 题目大意：给你n个矩形的左下角坐标和右上角坐标，求矩形相交至少覆盖两次以上的面积。 题解代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 2010;double dif_x[maxn]; //记录不同的x坐标int n, t = 0;struct node &#123; double x1, x2, y; int flag; void init(double l, double r, double h, int key) &#123; x1 = l, x2 = r, y = h, flag = key; &#125; bool operator &lt; (const node&amp; a) const &#123; return y &lt; a.y; &#125;&#125;line[maxn];struct Node &#123; int l, r, cnt; double len; double len2;&#125;tree[maxn * 4];void build_tree(int id, int l, int r)&#123; tree[id].l = l; tree[id].r = r; tree[id].cnt = 0; tree[id].len = 0; tree[id].len2 = 0; if (l == r) return; int mid = (r + l) &gt;&gt; 1; build_tree(id &lt;&lt; 1, l, mid); build_tree(id &lt;&lt; 1 | 1, mid + 1, r);&#125;void getlen(int id)&#123; if (tree[id].cnt) //如果该段被覆盖那么就直接由dif_x数组获得长度 tree[id].len = dif_x[tree[id].r + 1] - dif_x[tree[id].l]; else if (tree[id].l == tree[id].r) tree[id].len = 0; else //如果没有被覆盖，那么应该是由左右孩子的和 tree[id].len = tree[id &lt;&lt; 1].len + tree[id &lt;&lt; 1 | 1].len; if (tree[id].cnt &gt;= 2) tree[id].len2 = dif_x[tree[id].r + 1] - dif_x[tree[id].l]; else if (tree[id].l == tree[id].r) tree[id].len2 = 0; else if (tree[id].cnt == 1) tree[id].len2 = tree[id &lt;&lt; 1].len + tree[id &lt;&lt; 1 | 1].len; else tree[id].len2 = tree[id &lt;&lt; 1].len2 + tree[id &lt;&lt; 1 | 1].len2;&#125;void update(int id, int l, int r, int v)&#123; if (tree[id].l == l &amp;&amp; tree[id].r == r) &#123; tree[id].cnt += v; getlen(id); return; &#125; int mid = (tree[id].l + tree[id].r) &gt;&gt; 1; if (r &lt;= mid) update(id &lt;&lt; 1, l, r, v); else if (l &gt; mid) update(id &lt;&lt; 1 | 1, l, r, v); else &#123; update(id &lt;&lt; 1, l, mid, v); update(id &lt;&lt; 1 | 1, mid + 1, r, v); &#125; getlen(id);&#125;int main(void)&#123; ios::sync_with_stdio(false); scanf("%d", &amp;t); while (t--) &#123; scanf("%d", &amp;n); int line_num = 0; //一共有多少条横线 double x1, y11, x2, y2; for (int i = 0; i &lt; n; i++) &#123; scanf("%lf%lf%lf%lf", &amp;x1, &amp;y11, &amp;x2, &amp;y2); line[line_num].init(x1, x2, y11, 1); dif_x[line_num++] = x1; line[line_num].init(x1, x2, y2, -1); dif_x[line_num++] = x2; &#125; sort(line, line + line_num); sort(dif_x, dif_x + line_num); //对dif_x去重，要先排个序，这样更方便 int dif_x_num = unique(dif_x, dif_x + line_num) - dif_x; //dif_x_num表示去重后不同的x坐标的数量 build_tree(1, 0, dif_x_num - 1); double ans = 0.00; for (int i = 0; i &lt; line_num - 1; i++) &#123; int ll = lower_bound(dif_x, dif_x + dif_x_num, line[i].x1) - dif_x; int rr = lower_bound(dif_x, dif_x + dif_x_num, line[i].x2) - dif_x - 1; update(1, ll, rr, line[i].flag); ans += tree[1].len2 * (line[i + 1].y - line[i].y); &#125; printf("%.2lf\n", ans + 0.000001); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>Data Structure</category>
        <category>线段树</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>Data Structure</tag>
        <tag>线段树</tag>
        <tag>扫描线</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线段树+扫描线 HDU1542 Atlantis]]></title>
    <url>%2F2019%2F08%2F02%2FACM%2FData%20Structure%2FSegment%20Tree%2F%E7%BA%BF%E6%AE%B5%E6%A0%91%2B%E6%89%AB%E6%8F%8F%E7%BA%BF%20HDU1542%20Atlantis%2F</url>
    <content type="text"><![CDATA[Atlantis[ HDU - 1542 ] 题目大意：给你n个矩形的左下角坐标和右上角坐标，求矩形相交的面积。 题解扫描线 + 离散化板子 代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;double dif_x[500];struct node&#123; double x1,x2,y; int flag; void init(double l, double r, double h, int key) &#123; x1 = l; x2 = r; y = h; flag = key; &#125;&#125;line[500];bool cmp(node a, node b)&#123; return a.y &lt; b.y;&#125;struct node2&#123; int l, r, cnt; double len;&#125;tree[1000];void build_tree(int id, int l, int r)&#123; tree[id].l = l; tree[id].r = r; tree[id].cnt = 0; tree[id].len = 0; if(l == r) return; int mid = (r + l) &gt;&gt; 1; build_tree(id &lt;&lt; 1, l, mid); build_tree((id &lt;&lt; 1) + 1, mid + 1, r);&#125;void getlen(int id)&#123; if(tree[id].cnt &gt;= 1) tree[id].len = dif_x[tree[id].r+1] - dif_x[tree[id].l]; else tree[id].len = tree[id&lt;&lt;1].len + tree[(id&lt;&lt;1)|1].len;&#125;void update(int id,int l,int r,int v)&#123; if(tree[id].l==l &amp;&amp; tree[id].r==r) &#123; tree[id].cnt += v; getlen(id); return; &#125; int mid = (tree[id].l + tree[id].r) &gt;&gt; 1; if(r &lt;= mid) update(id &lt;&lt; 1,l,r,v); else if(l &gt; mid) update((id &lt;&lt; 1) + 1, l, r, v); else &#123; update(id &lt;&lt; 1, l, mid, v); update((id &lt;&lt; 1) + 1, mid + 1, r, v); &#125; getlen(id);&#125;int mySearch(double p, int l, int r)&#123; while(l &lt;= r) &#123; int mid = (l + r) &gt;&gt; 1; if(dif_x[mid] == p) return mid; if(dif_x[mid] &lt; p) l = mid + 1; else r = mid - 1; &#125;&#125;int main(void)&#123; int n, noc = 0; while (~scanf("%d", &amp;n)) &#123; if (n == 0) break; noc++; double x1, y1, x2, y2; int line_num = 0; for(int i = 0; i &lt; n; i++) &#123; scanf("%lf%lf%lf%lf", &amp;x1, &amp;y1, &amp;x2, &amp;y2); line[line_num].init(x1, x2, y1, 1); dif_x[line_num++] = x1; line[line_num].init(x1, x2, y2, -1); dif_x[line_num++] = x2; &#125; sort(line, line + line_num, cmp); sort(dif_x, dif_x + line_num); int dif_x_num = unique(dif_x, dif_x + line_num) - dif_x; build_tree(1, 0, dif_x_num - 1); double ans = 0; for(int i = 0; i &lt; line_num - 1; i++) &#123; int line_l = mySearch(line[i].x1, 0, dif_x_num - 1); int line_r = mySearch(line[i].x2, 0, dif_x_num-1) - 1; update(1, line_l, line_r, line[i].flag); ans += tree[1].len * (line[i+1].y - line[i].y); &#125; printf("Test case #%d\n", noc); printf("Total explored area: %.2lf\n\n", ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>Data Structure</category>
        <category>线段树</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>Data Structure</tag>
        <tag>线段树</tag>
        <tag>扫描线</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树状数组 POJ3468 A Simple Problem with Integers]]></title>
    <url>%2F2019%2F07%2F25%2FACM%2FData%20Structure%2FBinary%20Indexed%20Tree%2F%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%20POJ3468%20A%20Simple%20Problem%20with%20Integers%2F</url>
    <content type="text"><![CDATA[A Simple Problem with Integers[ POJ - 3468 ] 题目大意：给一个长度为n的数列，有Q次操作Q代表查询区间 a b之间的累加和，操作C代表将a-b区间的所有数加上c 题解树状数组模板题，此题建立完整的一维树状数组板子 代码如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstdio&gt;#include&lt;string&gt;#include&lt;vector&gt;using namespace std;typedef long long ll;ll n, m, k;inline ll lowbit(ll x)&#123; return x &amp; -x;&#125;struct BIT &#123; ll a[500050]; void add(ll x, ll v) &#123; for (x; x &gt; 0; x -= lowbit(x)) a[x] += v; &#125; void addinv(ll x, ll v) &#123; for (ll i = x; i &lt;= n; i += lowbit(i)) a[i] += x * v; &#125; ll Sum(ll x) &#123; ll res = 0; for(x; x &lt;= n; x += lowbit(x)) res += a[x]; return res; &#125; ll Suminv(ll x) &#123; ll res = 0; for (x; x &gt; 0; x -= lowbit(x)) res += a[x]; return res; &#125;&#125;bit, bitinv;ll sum(ll x)&#123; if (x) return bit.Sum(x) * x + bitinv.Suminv(x - 1); else return 0;&#125;void add(ll l, ll r, ll c)&#123; bit.add(r, c); bitinv.addinv(r, c); if (l &gt; 1) &#123; bit.add(l - 1, -c); bitinv.addinv(l - 1, -c); &#125;&#125;int main(void)&#123; scanf("%lld%lld", &amp;n, &amp;m); for (ll i = 1; i &lt;= n; i++) &#123; scanf("%lld", &amp;k); add(i, i, k); &#125; getchar(); char ch; ll l, r, c; while (m--) &#123; scanf("%c %lld %lld", &amp;ch, &amp;l, &amp;r); if (ch == 'Q') printf("%lld\n", sum(r) - sum(l - 1)); if (ch == 'C') &#123; scanf("%lld", &amp;c); add(l, r, c); &#125; getchar(); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>Data Structure</category>
        <category>树状数组</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>Data Structure</tag>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树状数组 POJ2155 Matrix]]></title>
    <url>%2F2019%2F07%2F25%2FACM%2FData%20Structure%2FBinary%20Indexed%20Tree%2F%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%20POJ2155%20Matrix%2F</url>
    <content type="text"><![CDATA[Matrix[ POJ - 2155 ] 题目大意：对一个n∗n的矩阵：1.格式C x1 y1 x2 y2，表示将左上角为(x1,y1)，右下角为(x2,y2)的矩阵全部取反，即0变1，1变0.2.Q x y，表示查询位置(x,y)的值.设询问次数为t，则10^3, 1 ≤ t ≤ 10^5, 数据组数 ≤ 10. 题解树状数组模板题，此题建立完整的二维树状数组板子 代码如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;string&gt;#include&lt;vector&gt;using namespace std;typedef long long ll;ll a[1010][1010];ll t, m, n;inline ll lowbit(ll x)&#123; return x &amp; -x;&#125;ll sum(ll x, ll y)&#123; ll res = 0; for (ll i = x; i &gt; 0; i -= lowbit(i)) for (ll j = y; j &gt; 0; j -= lowbit(j)) res += a[i][j]; return res;&#125;void add(ll x, ll y, ll v)&#123; for (ll i = x; i &lt;= n; i += lowbit(i)) for (ll j = y; j &lt;= n; j += lowbit(j)) a[i][j] += v;&#125;int main(void)&#123; cin &gt;&gt; t; while (t--) &#123; memset(a, 0, sizeof(a)); scanf("%lld%lld", &amp;n, &amp;m); getchar(); char ch; ll x1, y1, x2, y2; while (m--) &#123; scanf("%c %lld %lld", &amp;ch, &amp;x1, &amp;y1); if (ch == 'Q') printf("%lld\n", sum(x1, y1) % 2); if (ch == 'C') &#123; scanf("%lld%lld", &amp;x2, &amp;y2); add(x1, y1, 1); add(x2 + 1, y1, 1); add(x1, y2 + 1, 1); add(x2 + 1, y2 + 1, 1); &#125; getchar(); &#125; if (t) cout &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>Data Structure</category>
        <category>树状数组</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>Data Structure</tag>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019年牛客多校第1场 赛后总结]]></title>
    <url>%2F2019%2F07%2F18%2FACM%2FCompetition%20Summary%2F2019%E5%B9%B4%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A1%E7%AC%AC1%E5%9C%BA%E8%B5%9B%E5%90%8E%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[2019年牛客多校第1场 赛后总结 A题 ：Equivalent Prefixes&emsp;题意：就是给你两个有n个不同数的串，然后保证1-p区间内任选一个区间，使得区间中最小值的下标相同，找到最大的p值 &emsp;思路：我的思路是设置两个单调栈，然后每次的第i个数判断大小，放到栈顶（比它大的数弹出栈），当两个栈容量不同时，即不成立。 代码如下: 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 5e5 + 5;int a[maxn], b[maxn];stack&lt;int&gt;s1, s2;int main(void)&#123; int n; while (~scanf("%d", &amp;n)) &#123; for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;a[i]); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;b[i]); while (s1.size()) s1.pop(); while (s2.size()) s2.pop(); int ans = 1; s1.push(a[1]); s2.push(b[1]); for (int i = 2; i &lt;= n; i++) &#123; while (s1.size() &amp;&amp; s1.top() &gt; a[i]) s1.pop(); s1.push(a[i]); while (s2.size() &amp;&amp; s2.top() &gt; b[i]) s2.pop(); s2.push(b[i]); if (s1.size() != s2.size()) break; ans = i; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; B题：Integration&emsp;题意：已知$ \int_{0}^{∞} \frac{1}{1 + x_{2} } dx = \frac{\pi}{2}$，求$\frac{1}{\pi } \int_{0}^{∞} \frac{1}{\prod_{i=1}^{n}(a_{i}^{2} + x^{2})}dx $ 这道题强行唤醒我的数学…但最终以失败告终…看了好几个巨巨的博客……这里感谢这位大佬的博客：2019牛客网暑期多校第一场B题 $ \frac{1}{\prod_{i=1}^{n}(a_{i}^{2} + x^{2})}\,=\,\frac{c_{1} }{a_{1}^{2} + x^{2} }\,+\,\frac{c_{2} }{a_{2}^{2} + x^{2} }\,+…+\frac{c_{n} }{a_{n}^{2} + x^{2} } \\ \, \\\qquad\quad\quad\;\;\, = \frac{c_{1}\cdot \prod_{i\neq 1 }(a_{i}^{2} + x^{2}) + …+c_{i}\cdot \prod_{j\neq i }(a_{j}^{2} + x^{2}) + … + +c_{n}\cdot \prod_{i\neq n }(a_{i}^{2} + x^{2})}{\prod_{i=1}^{n}(a_{i}^{2} + x^{2})}$ 我们可以得到: $\sum_{i = 1}^{n}C_{i}\cdot \prod_{j\neq i}(a_{i}^{2} + x^{2})\,=\,1$ 由数学归纳法，可得：$C_{i}\,=\,\frac{1}{\prod_{j\neq i}(a_{j}^{2}-a_{i}^{2})}$ 又因为$\int_{0}^{∞} \frac{1}{1 + x_{2} } dx = \frac{\pi}{2}$ $ \frac{1}{\pi } \int_{0}^{∞} \frac{1}{\prod_{i=1}^{n}(a_{i}^{2} + x^{2})}dx\,=\,\frac{1}{\pi }\sum_{i=1}^{n}\int_{0}^{∞}\frac{C_{i} }{a_{i}^{2}+x^{2} }dx $$ \\\,\\ \qquad\qquad\qquad\qquad\;=\,\frac{1}{\pi }\sum_{i=1}^{n}C_{i}\int_{0}^{∞}\frac{1}{a_{i}^{2}+x^{2} }dx $$ \\\,\\ \qquad\qquad\qquad\qquad\;=\,\frac{1}{\pi }\sum_{i=1}^{n}\frac{c_{i} }{a_{i} }\cdot \frac{\pi}{2} $$ \\\,\\ \qquad\qquad\qquad\qquad\;=\,\sum_{i=1}^{n}\frac{c_{i} }{2a_{i} } $$ \\\,\\ \qquad\qquad\qquad\qquad\;=\,\frac{1}{2}\sum_{i=1}^{n}\frac{1}{ {a_{i} }\cdot \prod_{j\neq i}(a_{j}^{2}-a_{i}^{2})} $ 然后进行逆元，费马小定理 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int mod = 1e9 + 7;const int maxn = 1e3 + 10;ll a[maxn];ll qpow(ll a, ll b)&#123; ll res = 1; while (b) &#123; if (b &amp; 1) res = res * a % mod; a = a * a % mod; b &gt;&gt;= 1; &#125; return res;&#125;int main(void)&#123; int n; while (~scanf("%d", &amp;n)) &#123; for (int i = 1; i &lt;= n; i++) scanf("%lld", &amp;a[i]); ll ans = 0; for (int i = 1; i &lt;= n; i++) &#123; ll res = 1; for (int j = 1; j &lt;= n; j++) &#123; if (i == j) continue; res *= (a[j] * a[j] % mod - a[i] * a[i] % mod); res %= mod; &#125; ans += qpow(2 * a[i] % mod * res % mod, mod - 2); &#125; ans = (ans % mod + mod) % mod; cout &lt;&lt; ans &lt;&lt; endl; &#125;&#125; E题：ABBA&emsp;题意：有n个＂AB＂,m个＂BA＂，问能结合成多少个序列．这个要求是AB和BA的顺序不变，即A和B的相对位置不变，BA中可以穿插AB，反之亦然 那么我们采用dp，dp[i][j]表示放置i个A和j个B方案数也就是说我们当前串也就是后面添加A还是添加B的情况 12dp[i][j] += dp[i - 1][j];dp[i][j] += dp[i][j - 1]; &emsp;当i ≤ n时，A可以随便放；&emsp;当j ≤ m时，B可以随便放；&emsp;当i &gt; n，如果放A，AB的数量要小于等于n，i - j是至少有多少个AB, i - j ≤ n；&emsp;当j &gt; m，如果放B，BA的数量要小于等于m，j - i是至少有多少个BA, j - i ≤ m;即 12if(i - j &lt;= n) d[i][j] += d[i - 1][j];if(j - i &lt;= m) d[i][j] += d[i][j - 1]]; 最终代码如下(PS: 用于数据组过多，memset会卡T，跟缓冲区有关) 1234567891011121314151617181920212223242526272829#include&lt;bits/stdc++.h&gt;using namespace std; const int mod = 1e9 + 7;const int maxn = 2e3 + 10;int dp[maxn][maxn]; int main(void)&#123; int n, m; while (~scanf("%d%d", &amp;n, &amp;m)) &#123; for (int i = 0; i &lt;= n + m; i++) for (int j = 0; j &lt;= m + n; j++) dp[i][j] = 0; dp[0][0] = 1; for (int i = 0; i &lt;= n + m; i++) &#123; for (int j = 0; j &lt;= m + n; j++) &#123; if (i - j &lt; n) dp[i + 1][j] = (dp[i][j] + dp[i + 1][j]) % mod; if (j - i &lt; m) dp[i][j + 1] = (dp[i][j] + dp[i][j + 1]) % mod; &#125; &#125; printf("%d\n", dp[n + m][n + m]); &#125; return 0;&#125; F题：Random Point in Triangle&emsp;题意：求三角形内部一个点连三个顶点形成的最大三角形面积的期望，再乘一个36 &emsp;答案是 11/2 倍三角形 ABC 的面积 123456789101112131415161718192021#include&lt;bits/stdc++.h&gt;using namespace std;struct point&#123; long long x, y;&#125;a, b, c;point AB, BC;int main(void)&#123; while (cin &gt;&gt; a.x &gt;&gt; a.y &gt;&gt; b.x &gt;&gt; b.y &gt;&gt; c.x &gt;&gt; c.y) &#123; AB.x = b.x - a.x; AB.y = b.y - a.y; BC.x = c.x - b.x; BC.y = c.y - b.y; printf("%lld\n",abs((AB.x * BC.y - AB.y * BC.x)) * 11); &#125; return 0;&#125; J题 ：Fraction Comparision&emsp;题意：判断x/a和y/b的大小，其中1 ≤ x, y ≤ 1018， 1 ≤ a, b ≤ 109 签到题，这道题我们直接用的大整数写的，判断x * b和y * a，没什么好说的 其实出题人是想考察数学方面知识的，官方题解是这样的： 先把 $\frac{x}{a}$ 写成 $[\frac{x}{a}] + \frac{x\,mod\,a}{a}$ 先比整数部分，分数部分分子分母都在 109 范围内，交叉相乘比较 于是乎，上一下官方题解： 1234567891011121314151617181920212223242526272829#include &lt;bits/stdc++.h&gt;static std::pair&lt;uint64_t, uint64_t&gt; fcompare(uint64_t x, uint32_t a, uint64_t y, uint32_t b) &#123; uint64_t p = x / a; // p &lt;= (x / a) &lt; p + 1 uint64_t q = y / b; // q &lt;= (y / b) &lt; q + 1 if (p != q) &#123; return &#123;p, q&#125;; &#125; x %= a; y %= b; return &#123;x * b, y * a&#125;;&#125;int main(void)&#123; std::ios::sync_with_stdio(false); uint64_t x, y; uint32_t a, b; while (std::cin &gt;&gt; x &gt;&gt; a &gt;&gt; y &gt;&gt; b) &#123; auto result = fcompare(x, a, y, b); if (result.first == result.second) puts("="); else if (result.first &lt; result.second) puts("&lt;"); else puts("&gt;"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>多校训练</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>多校训练</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树形DP入门 POJ-2342 没有上司的舞会.md]]></title>
    <url>%2F2019%2F07%2F17%2FACM%2FDP%2FTree%20DP%2F%E6%A0%91%E5%BD%A2DP%E5%85%A5%E9%97%A8%20POJ-2342%20%E6%B2%A1%E6%9C%89%E4%B8%8A%E5%8F%B8%E7%9A%84%E8%88%9E%E4%BC%9A%2F</url>
    <content type="text"><![CDATA[没有上司的舞会&lt;/[POJ - 2342] 题目某大学有N个职员，编号为1~N。他们之间有从属关系，也就是说他们的关系就像一棵以校长为根的树，父结点就是子结点的直接上司。现在有个周年庆宴会，宴会每邀请来一个职员都会增加一定的快乐指数Ri，但是呢，如果某个职员的上司来参加舞会了，那么这个职员就无论如何也不肯来参加舞会了。所以，请你编程计算，邀请哪些职员可以使快乐指数最大，求最大的快乐指数。 Input 第一行一个整数N。(1&lt;=N&lt;=6000)接下来N行，第i+1行表示i号职员的快乐指数Ri。(-128&lt;=Ri&lt;=127)接下来N行分别代表每个结点的权值范围从-128到127接下来N-1行，每行输入一对整数L,K。表示K是L的直接上司。, 最后一行输入0 0 Output 对于每组测试数据，输出一个整数Ans，表示在不发生口角的情况下，乘务员最多可以清扫的垃圾数目。 Sample Input 125 2 136 9 80 69 85 Sample Output 1201 解112345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;bits/stdc++.h&gt;using namespace std;int dp[6010][2];int v[6010], a[6010];vector&lt;int&gt; son[6010];int n;void dfs(int x)&#123; dp[x][0] = 0; dp[x][1] = a[x]; for (int i = 0; i &lt; son[x].size(); i++) &#123; int id = son[x][i]; dfs(id); dp[x][0] += max(dp[id][0], dp[id][1]); dp[x][1] += dp[id][0]; &#125;&#125;int main(void)&#123; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;a[i]); int x, y; for (int i = 1; i &lt; n; i++) &#123; scanf("%d%d", &amp;x, &amp;y); son[y].push_back(x); v[x] = 1; &#125; scanf("%d%d", &amp;x, &amp;y); int root = 0; for (int i = 1; i &lt;= n; i++) &#123; if (!v[i]) &#123; root = i; break; &#125; &#125; dfs(root); cout &lt;&lt; max(dp[root][1], dp[root][0]) &lt;&lt; endl; getchar(), getchar(); return 0;&#125; 解2题解 这道题我们需要存储当前位置i开始往前m个位置的状态 在递推式dp[i][j] = max(dp[i - 1][j &gt;&gt; 1], dp[i - 1][(j &gt;&gt; 1) + (1 &lt;&lt; m - 1)]) + w[i]中dp[i - 1][j &gt;&gt; 1]、dp[i - 1][(j &gt;&gt; 1) + (1 &lt;&lt; m - 1)]) + w[i]为再往前一个节点为0或者1的状态 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1010;int dp[maxn][1050];int w[maxn];int n, m, q;int sum(int j)&#123; int sum = 0; while (j) &#123; if (j &amp; 1) sum++; j &gt;&gt;= 1; &#125; return sum;&#125;int main(void)&#123; memset(dp, 0, sizeof(dp)); cin &gt;&gt; n &gt;&gt; m &gt;&gt; q; for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;w[i]); for (int i = 1; i &lt;= n; i++) &#123; for (int j = 0; j &lt; 1 &lt;&lt; m; j++) &#123; if (sum(j) &gt; q) continue; if (j &amp; 1) dp[i][j] = max(dp[i - 1][j &gt;&gt; 1], dp[i - 1][(j &gt;&gt; 1) + (1 &lt;&lt; m - 1)]) + w[i]; else dp[i][j] = max(dp[i - 1][j &gt;&gt; 1], dp[i - 1][(j &gt;&gt; 1) + (1 &lt;&lt; m - 1)]); &#125; &#125; int sum = -1; for (int i = 0; i &lt; 1 &lt;&lt; m; i++) sum = max(sum, dp[n][i]); cout &lt;&lt; sum &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>动态规划</category>
        <category>树形DP</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>动态规划</tag>
        <tag>树形DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[状压DP &nbsp;Hiho-1044 &nbsp;状态压缩]]></title>
    <url>%2F2019%2F07%2F13%2FACM%2FDP%2FState%20Compression%20DP%2F%E7%8A%B6%E5%8E%8BDP%20Hiho-1044%20%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9%2F</url>
    <content type="text"><![CDATA[状态压缩[HihoCoder - 1044] 小Hi和小Ho在兑换到了喜欢的奖品之后，便继续起了他们的美国之行，思来想去，他们决定乘坐火车前往下一座城市——那座城市即将举行美食节！ 但是不幸的是，小Hi和小Ho并没有能够买到很好的火车票——他们只能够乘坐最为破旧的火车进行他们的旅程。 不仅如此，因为美食节的吸引，许多人纷纷踏上了和小Hi小Ho一样的旅程，于是有相当多的人遭遇到了和小Hi小Ho一样的情况——这导致这辆车上的人非常非常的多，以至于都没有足够的位置能让每一个人都有地方坐下来。 小Hi和小Ho本着礼让他们的心情——当然还因为本来他们买的就是站票，老老实实的呆在两节车厢的结合处。他们本以为就能够这样安稳抵达目的地，但事与愿违，他们这节车厢的乘务员是一个强迫症，每隔一小会总是要清扫一次卫生，而时值深夜，大家都早已入睡，这种行为总是会惊醒一些人。而一旦相邻的一些乘客被惊醒了大多数的话，就会同乘务员吵起来，弄得大家都睡不好。 将这一切看在眼里的小Hi与小Ho决定利用他们的算法知识，来帮助这个有着强迫症的乘务员——在不与乘客吵起来的前提下尽可能多的清扫垃圾。 小Hi和小Ho所处的车厢可以被抽象成连成一列的N个位置，按顺序分别编号为1..N，每个位置上都有且仅有一名乘客在休息。同时每个位置上都有一些垃圾需要被清理，其中第i个位置的垃圾数量为Wi。乘务员可以选择其中一些位置进行清理，但是值得注意的是，一旦有编号连续的M个位置中有超过Q个的位置都在这一次清理中被选中的话（即这M个位置上的乘客有至少Q+1个被惊醒了），就会发生令人不愉快的口角。而小Hi和小Ho的任务是，计算选择哪些位置进行清理，在不发生口角的情况下，清扫尽可能多的垃圾。 Input 每个测试点（输入文件）有且仅有一组测试数据。 每组测试数据的第一行为三个正整数N、M和Q，意义如前文所述。 每组测试数据的第二行为N个整数，分别为W1到WN，代表每一个位置上的垃圾数目。 对于100%的数据，满足N&lt;=1000, 2&lt;=M&lt;=10,1&lt;=Q&lt;=M, Wi&lt;=100 Output 对于每组测试数据，输出一个整数Ans，表示在不发生口角的情况下，乘务员最多可以清扫的垃圾数目。 Sample Input 125 2 136 9 80 69 85 Sample Output 1201 题解 这道题我们需要存储当前位置i开始往前m个位置的状态 在递推式dp[i][j] = max(dp[i - 1][j &gt;&gt; 1], dp[i - 1][(j &gt;&gt; 1) + (1 &lt;&lt; m - 1)]) + w[i]中dp[i - 1][j &gt;&gt; 1]、dp[i - 1][(j &gt;&gt; 1) + (1 &lt;&lt; m - 1)]) + w[i]为再往前一个节点为0或者1的状态 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1010;int dp[maxn][1050];int w[maxn];int n, m, q;int sum(int j)&#123; int sum = 0; while (j) &#123; if (j &amp; 1) sum++; j &gt;&gt;= 1; &#125; return sum;&#125;int main(void)&#123; memset(dp, 0, sizeof(dp)); cin &gt;&gt; n &gt;&gt; m &gt;&gt; q; for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;w[i]); for (int i = 1; i &lt;= n; i++) &#123; for (int j = 0; j &lt; 1 &lt;&lt; m; j++) &#123; if (sum(j) &gt; q) continue; if (j &amp; 1) dp[i][j] = max(dp[i - 1][j &gt;&gt; 1], dp[i - 1][(j &gt;&gt; 1) + (1 &lt;&lt; m - 1)]) + w[i]; else dp[i][j] = max(dp[i - 1][j &gt;&gt; 1], dp[i - 1][(j &gt;&gt; 1) + (1 &lt;&lt; m - 1)]); &#125; &#125; int sum = -1; for (int i = 0; i &lt; 1 &lt;&lt; m; i++) sum = max(sum, dp[n][i]); cout &lt;&lt; sum &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>动态规划</category>
        <category>状压DP</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>动态规划</tag>
        <tag>状压DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第十二届河南省ACM大学生程序设计竞赛赛后总结]]></title>
    <url>%2F2019%2F05%2F09%2FACM%2FCompetition%20Summary%2F%E7%AC%AC%E5%8D%81%E4%BA%8C%E5%B1%8A%E6%B2%B3%E5%8D%97%E7%9C%81ACM%E5%A4%A7%E5%AD%A6%E7%94%9F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B%E8%B5%9B%E5%90%8E%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[第十二届河南省ACM大学生程序设计竞赛赛后总结&emsp;&emsp;这次是我跟菜瓜（色瓜）组织大家去比赛了，因为有天梯赛和CCPC省赛的组织经历，所以并没有出什么差错，比赛场地好评，这也算是头一个省赛在体育馆里面举办的了。&lt;/br&gt;下面说一下这次比赛的题吧&emsp;&emsp;先说总结：题很烂，连我们自己院赛题出的都不如，题目难度和知识点分配不均，题目数据频频出问题，幕后据说也有不知名交易。 A题&emsp;&emsp;一道KMP裸题，但是暴力也能过 B题&emsp;&emsp;动态规划 C题&emsp;&emsp;也是一道字符串处理问题，等于找若干个子串的不同就行，暴力就过 D题&emsp;&emsp;一道线性方程的水题，求若干个点相加之和。但是开场两小时之内基本所有队伍交上去全是TLE。1e5的复杂度怎可能会超时，提问说数据有没有问题得到回复没有，但是后来又重判两次……&emsp;&emsp;赛后我们讨论题意还有问题，题目第一句话告诉我们十点已经会发车，但是过的没有算直接sort就过了，不知道算是题描述错还是数据太水…… E题&emsp;&emsp;题目大意是描述找有向图中先升高再降低的路，直接转化为树即可 F题&emsp;&emsp;骂街题目1号&emsp;&emsp;大意是一个01的图中找11的数量，剩下的1算加1，正确做法二分图匹配，赛后被爆出POJ原题，链接： POJ - 3020: http://poj.org/problem?id=3020 结果大家死活做不出来，有很多队伍后来AC了，说是用的贪心直接过，但是贪心很明显不对，比如111100贪心跑出来的答案会是3，但明显是2 G题&emsp;&emsp;骂街题目2号&emsp;&emsp;一道强连通分量的题，但是全场除了冠军队没一个能再做出来，讲题人始终坚持数据没问题，冠军队1发就AC，赛后讲题支支吾吾，唔…不做评价 H题&emsp;&emsp;一道很简答的最短路变形问题，但是全场基本被DFG三道题给绊住，基本没人做 I题&emsp;&emsp;你能听到赛后讲题人直接说这个题我们拿出来就是专门为了防AK的，这道题我们也不会做的话吗？？？ J题&emsp;&emsp;一道二叉树的，很多人直接用树存值过的，但是这道题我觉得还是数据水了，因为231的数据量…&emsp;&emsp;这道题分析后会发现是先求出X的因子中有多少个2，即2n，然后输出x-2^n+1 x+2^n-1即可&lt;/br&gt;&lt;/br&gt;以上基本就是这次比赛的总结，大家往年都是吐槽数据弱，比如去年的一道最小费用流问题直接深搜就过…结果今年直接数据出错不说，还……今年比赛已经导致cy等大佬上台怒怼了，如果河南省赛再这么下去…哎……]]></content>
      <categories>
        <category>ACM</category>
        <category>赛后总结</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>赛后总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并查集 POJ-1611 The Suspects]]></title>
    <url>%2F2018%2F09%2F19%2FACM%2FData%20Structure%2FUnion-Find%20Set%2F%E5%B9%B6%E6%9F%A5%E9%9B%86%20POJ-1611%20The%20Suspects%2F</url>
    <content type="text"><![CDATA[The Suspects[ POJ - 1611 ] 并查集裸题，需要注意一下合并时是序号大的合到小的当中，否则不一定会出现0，或者是find(i) == find(0) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cmath&gt;using namespace std;#define IO ios::sync_with_stdio(false), cin.tie(0), cout.tie(0)#define fin freopen("in.txt", "r", stdin)#define fout freopen("out.txt", "w", stdout)typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int, int&gt; P;const int maxn = 1e5 + 10;const int INF = 0x3f3f3f3f;const double eps = 1e-5;int par[maxn];int high[maxn];void init(int n)&#123; for (int i = 0; i &lt;= n; i++) &#123; par[i] = i; high[i] = 0; &#125;&#125;int find(int x)&#123; if (par[x] == x) return x; return par[x] = find(par[x]);&#125;void unite(int x, int y)&#123; x = find(x); y = find(y); if (x == y) return; else if (x &lt; y) par[y] = x; else par[x] = y;&#125;bool same(int x, int y)&#123; return find(x) == find(y);&#125;int main(void)&#123; IO; int n, m; int tot = 0; while (~scanf("%d%d", &amp;n, &amp;m)) &#123; if (n == 0 &amp;&amp; m == 0) break; init(n); int a, b, nu; for (int i = 0; i &lt; m; i++) &#123; scanf("%d%d", &amp;nu, &amp;a); nu--; while (nu--) &#123; scanf("%d", &amp;b); unite(a, b); &#125; &#125; int ans = 0; for (int i = 0; i &lt;= n; i++) if (find(i) == 0) ans++; printf("%d\n", ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>Data Structure</category>
        <category>并查集</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>Data Structure</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并查集 POJ-2524 Ubiquitous Religion]]></title>
    <url>%2F2018%2F09%2F19%2FACM%2FData%20Structure%2FUnion-Find%20Set%2F%E5%B9%B6%E6%9F%A5%E9%9B%86%20POJ-2524%20Ubiquitous%20Religions%2F</url>
    <content type="text"><![CDATA[Ubiquitous Religion[ POJ - 2524 ] 并查集裸题 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cmath&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int, int&gt; P;const int maxn = 1e5 + 10;int par[maxn];int high[maxn];void init(int n)&#123; for (int i = 1; i &lt;= n; i++) &#123; par[i] = i; high[i] = 0; &#125;&#125;int find(int x)&#123; if (par[x] == x) return x; return par[x] = find(par[x]);&#125;void unite(int x, int y)&#123; x = find(x); y = find(y); if (x == y) return; if (high[x] &lt; high[y]) par[x] = y; else &#123; par[y] = x; if (high[x] == high[y]) high[x]++; &#125;&#125;bool same(int x, int y)&#123; return find(x) == find(y);&#125;int main(void)&#123; int n, m; int tot = 0; while (~scanf("%d%d", &amp;n, &amp;m)) &#123; if (n == 0 &amp;&amp; m == 0) break; init(n); int a, b; for (int i = 0; i &lt; m; i++) &#123; scanf("%d%d", &amp;a, &amp;b); unite(a, b); &#125; int ans = 0; for (int i = 1; i &lt;= n; i++) if (par[i] == i) ans++; printf("Case %d: %d\n", ++tot, ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>Data Structure</category>
        <category>并查集</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>Data Structure</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ftp打开方式更改为资源管理器方法]]></title>
    <url>%2F2018%2F08%2F29%2FWindows%2Fftp%E6%89%93%E5%BC%80%E6%96%B9%E5%BC%8F%E6%9B%B4%E6%94%B9%E4%B8%BA%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E5%99%A8%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[&emsp;今天要登陆一下学校的ftp服务器下载点东西，突然发现打开方式变成了chrome，然后就尝试了很多方法更改。&emsp;目前我的系统是Windows10 1803.&emsp;按照网上的更改按协议指定默认程序和从ie中更改之类的完全没有半毛钱效果 &emsp;在即将崩溃的时候发现了这篇文章https://blog.csdn.net/tianwuya217/article/details/8674622由于这篇文章博主操作系统是Win8,所以更改注册表时我发现内容结构不一样，不能按照这个修改方法，但是给我提供了一个思路就是修改[HKEY_CLASSES_ROOT\ftp]目录下的所有内容。 &emsp;如果身旁有小伙伴电脑操作系统跟自己的一样，按照小伙伴的内容的更改即可。 &emsp;下面列出我的更改内容供大家参考 win + R 输入 regedit 打开注册表格, 直接地址栏输入[计算机\HKEY_CLASSES_ROOT\ftp]， 此时我发现我的文件夹里空空如也。（哇，这到底是哪个软件搞的鬼啊 (╯‵□′)╯ ︵ ┻━┻） 将(默认)的字符串值更改为 URL:File Transfer Protocol新建名为 AppUserModelID 字符串值, 输入Microsoft.InternetExplorer.Default新建名为 EditFlags DWORD(32位值), 输入 2新建名为 FriendlyTypeName 字符串值, 输入@C:\WINDOWS\system32\ieframe.dll,-905新建名为 ShellFolder 字符串值, 输入{63da6ec0-2e98-11cf-8d82-444553540000}新建名为 ShellFolder 字符串值, 输入{E436EBB6-524F-11CE-9F53-0020AF0BA770}新建名为 AppUserModelID 字符串值, 无输入 在ftp中新建项, 命名为 Defaultlcon将(默认)的字符串值更改为 %SystemRoot%\system32\url.dll,0 在ftp中新建项, 命名为 shell将(默认)的字符串值更改为 open 在shell中新建项，命名为 open新建名为 CommandId 字符串值, 输入 IE.Protocol(默认)字符串值无需更改 在open中新建项， 命名为 command将(默认)的字符串值更改为&emsp;&quot;C:\Program Files\Internet Explorer\IEXPLORE.EXE&quot; %1新建名为 DelegateExecute 字符串值, 输入{17FE9752-0B5A-4665-84CD-569794602F5C} 此时尝试一下，发现ftp可以用资源管理器打开了。 附上参考博客的博主的话: 搜索问题最好看那些博客类，相对来说准确度较高！&emsp;——你想想大部分人为什么写博客？大部分都是自己千般万苦的搜索了半天或研究了半天才解决的问题。只是想用博客的形式记录下来，记录下自己的成就感。这成果来之不易 ~]]></content>
      <categories>
        <category>系统</category>
        <category>windows</category>
      </categories>
      <tags>
        <tag>系统</tag>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ftp打开方式更改为资源管理器方法]]></title>
    <url>%2F2018%2F08%2F29%2FACM%2FCompetition%20Summary%2FACM-ICPC%202018%20%E5%8D%97%E4%BA%AC%E8%B5%9B%E5%8C%BA%E7%BD%91%E7%BB%9C%E9%A2%84%E8%B5%9B%20%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[&emsp;今天要登陆一下学校的ftp服务器下载点东西，突然发现打开方式变成了chrome，然后就尝试了很多方法更改。&emsp;目前我的系统是Windows10 1803.&emsp;按照网上的更改按协议指定默认程序和从ie中更改之类的完全没有半毛钱效果 &emsp;在即将崩溃的时候发现了这篇文章https://blog.csdn.net/tianwuya217/article/details/8674622由于这篇文章博主操作系统是Win8,所以更改注册表时我发现内容结构不一样，不能按照这个修改方法，但是给我提供了一个思路就是修改[HKEY_CLASSES_ROOT\ftp]目录下的所有内容。 &emsp;如果身旁有小伙伴电脑操作系统跟自己的一样，按照小伙伴的内容的更改即可。 &emsp;下面列出我的更改内容供大家参考 win + R 输入 regedit 打开注册表格, 直接地址栏输入[计算机\HKEY_CLASSES_ROOT\ftp]， 此时我发现我的文件夹里空空如也。（哇，这到底是哪个软件搞的鬼啊 (╯‵□′)╯ ︵ ┻━┻） 将(默认)的字符串值更改为 URL:File Transfer Protocol新建名为 AppUserModelID 字符串值, 输入Microsoft.InternetExplorer.Default新建名为 EditFlags DWORD(32位值), 输入 2新建名为 FriendlyTypeName 字符串值, 输入@C:\WINDOWS\system32\ieframe.dll,-905新建名为 ShellFolder 字符串值, 输入{63da6ec0-2e98-11cf-8d82-444553540000}新建名为 ShellFolder 字符串值, 输入{E436EBB6-524F-11CE-9F53-0020AF0BA770}新建名为 AppUserModelID 字符串值, 无输入 在ftp中新建项, 命名为 Defaultlcon将(默认)的字符串值更改为 %SystemRoot%\system32\url.dll,0 在ftp中新建项, 命名为 shell将(默认)的字符串值更改为 open 在shell中新建项，命名为 open新建名为 CommandId 字符串值, 输入 IE.Protocol(默认)字符串值无需更改 在open中新建项， 命名为 command将(默认)的字符串值更改为&emsp;&quot;C:\Program Files\Internet Explorer\IEXPLORE.EXE&quot; %1新建名为 DelegateExecute 字符串值, 输入{17FE9752-0B5A-4665-84CD-569794602F5C} 此时尝试一下，发现ftp可以用资源管理器打开了。 附上参考博客的博主的话: 搜索问题最好看那些博客类，相对来说准确度较高！&emsp;——你想想大部分人为什么写博客？大部分都是自己千般万苦的搜索了半天或研究了半天才解决的问题。只是想用博客的形式记录下来，记录下自己的成就感。这成果来之不易 ~]]></content>
      <categories>
        <category>系统</category>
        <category>windows</category>
      </categories>
      <tags>
        <tag>系统</tag>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基本DP POJ - 2373 Dividing the Path]]></title>
    <url>%2F2018%2F08%2F14%2FACM%2FDP%2FBase%20DP%2F%E5%9F%BA%E6%9C%ACDP%20POJ-2373%20Dividing%20the%20Path%2F</url>
    <content type="text"><![CDATA[Dividing the Path[ POJ - 2373 ] 题目大意：有一个直线的山脊，喷泉是一个在中间向两边同时喷的，最近喷a，最远b。同时山脊上有牛，每只牛在一个区域里活动，牛活动的区域只能被一个喷泉的水来覆盖。求最少的喷泉使山脊上所有地方都能有水浇灌到 思路手工实现优先队列的方法如果一个队列满足以下条件: 开始为空 每在队尾加入一个元素a之前，都从现有队尾往前删除元素 ，一直删到碰到小于a的元素为止，然后再加入a,那么队列就是递增的，当然队头的元素，一定是队列中最小的 题解代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;bits/stdc++.h&gt;using namespace std;const int INFINITE = 1&lt;&lt;30;const int MAXL = 1000010;const int MAXN = 1010;int F[MAXL]; // F[L]就是答案int cowThere[MAXL]; //cowThere[i]为1表示点i有奶牛int N,L,A,B;struct Fx &#123; int x; int f; bool operator&lt;(const Fx &amp; a) const &#123; return f &gt; a.f; &#125; Fx(int xx=0,int ff=0):x(xx),f(ff) &#123; &#125;&#125;;// 在优先队列里，f值越小的越优先priority_queue&lt;Fx&gt; qFx;int main(void)&#123; cin &gt;&gt; N &gt;&gt; L; cin &gt;&gt; A &gt;&gt; B; A &lt;&lt;= 1; B &lt;&lt;= 1; //A,B的定义变为覆盖的直径 memset(cowThere,0,sizeof(cowThere)); for( int i = 0;i &lt; N; ++i ) &#123; int s,e; cin &gt;&gt; s &gt;&gt; e; ++cowThere[s+1]; //从s+1起进入一个奶牛区 --cowThere[e]; //从e起退出一个奶牛区 &#125; int inCows = 0; //表示当前点位于多少头奶牛的活动范围之内 for( int i = 0;i &lt;= L ; i ++) &#123; //算出每个点是否有奶牛 F[i] = INFINITE; inCows += cowThere[i]; cowThere[i] = inCows &gt; 0; &#125; for( int i = A;i &lt;= B ; i += 2 ) //初始化队列 if(! cowThere[i] ) &#123; F[i] = 1; if( i &lt;= B + 2 - A ) //在求F[i]的时候，要确保队列里的点x，x &lt;= i - A qFx.push(Fx(i,1)); &#125; for( int i = B + 2 ; i &lt;= L; i += 2 ) &#123; if(!cowThere[i]) &#123; Fx fx; while(!qFx.empty()) &#123; fx = qFx.top(); if( fx.x &lt; i - B ) qFx.pop(); else break; &#125; if (!qFx.empty()) F[i] = fx.f + 1; &#125; if( F[i- A + 2] != INFINITE) &#123; //队列中增加一个+1可达下个点的点 qFx.push(Fx(i- A + 2, F[i- A + 2])); &#125; &#125; if( F[L] == INFINITE ) cout &lt;&lt; -1 &lt;&lt;endl; else cout &lt;&lt; F[L] &lt;&lt; endl; return 0;&#125; // 复杂度:O(nlogn)]]></content>
      <categories>
        <category>ACM</category>
        <category>动态规划</category>
        <category>基本DP</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基本DP POJ - 1390 Blocks]]></title>
    <url>%2F2018%2F08%2F13%2FACM%2FDP%2FBase%20DP%2F%E5%9F%BA%E6%9C%ACDP%20POJ-1390%20Blocks%2F</url>
    <content type="text"><![CDATA[Blocks [ POJ - 1390 ] 题目大意：给你一个颜色块序列，每次你可以删除一些相同颜色并且相邻的颜色块，并获得删除数目平方的收益，现在给你一个颜色块序列，问收益最大是多少？ 题解代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;bits/stdc++.h&gt;using namespace std;const int M = 210;struct Segment &#123; int color; int len;&#125;;Segment segments[M];int score[M][M][M];int ClickBox(int i,int j,int len) &#123; if( score[i][j][len] != -1) return score[i][j][len]; int result = (segments[j].len + len) * (segments[j].len + len); if(i == j) return result; result += ClickBox(i,j-1,0); for(int k = i;k &lt;= j-1; ++k ) &#123; if(segments[k].color != segments[j].color) continue; int r = ClickBox(k + 1, j - 1, 0); r += ClickBox(i, k, segments[j].len + len); result = max(result, r); &#125; score[i][j][len] = result; return result;&#125;int main(void)&#123; int T; cin &gt;&gt; T; for (int t = 1; t &lt;= T; ++t) &#123; int n; memset(score,0xff,sizeof(score)); cin &gt;&gt; n; int lastC = 0; int segNum = -1; for(int i = 0; i &lt; n; ++i) &#123; int c; cin &gt;&gt; c; if( c != lastC ) &#123; segNum ++; segments[segNum].len = 1; segments[segNum].color = c; lastC = c; &#125; else segments[segNum].len ++; &#125; cout &lt;&lt; "Case " &lt;&lt; t &lt;&lt; ": " &lt;&lt; ClickBox(0,segNum,0) &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>动态规划</category>
        <category>基本DP</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基本DP POJ - 1088 滑雪]]></title>
    <url>%2F2018%2F08%2F12%2FACM%2FDP%2FBase%20DP%2F%E5%9F%BA%E6%9C%ACDP%20LIS%20POJ-1088%20%E6%BB%91%E9%9B%AA%2F</url>
    <content type="text"><![CDATA[滑雪&lt;/[ POJ - 1088 ] 题目大意：求最长上升子序列的题目，二维数组稍微转化一下 题解代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;bits/stdc++.h&gt;using namespace std;int dp[105][105];int h[105][105];int dx[] = &#123;-1, 0, 1, 0&#125;;int dy[] = &#123;0, -1, 0, 1&#125;;struct node&#123; int h; int x, y;&#125;s[10050]; bool cmp(node a, node b)&#123; return a.h &lt; b.h;&#125;int main(void)&#123; int n, m; cin &gt;&gt; n &gt;&gt; m; int r = 0; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; scanf("%d", &amp;h[i][j]); dp[i][j] = 1; s[r].h = h[i][j]; s[r].x = i; s[r].y = j; r++; &#125; &#125; sort(s, s + r, cmp); int ans = 1; for (int i = 0; i &lt; r; i++) &#123; int lx = s[i].x; int ly = s[i].y; for (int i = 0; i &lt; 4; i++) &#123; int x = lx + dx[i]; int y = ly + dy[i]; if (x&gt;=1 &amp;&amp; y&gt;=1 &amp;&amp; x&lt;=n &amp;&amp; y&lt;=m &amp;&amp; h[x][y] &gt; h[lx][ly]) &#123; dp[x][y] = max(dp[x][y], dp[lx][ly] + 1); ans = max(ans, dp[x][y]); &#125; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>动态规划</category>
        <category>基本DP</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基本DP LIS 最长上升子序列 两种角度及优化算法]]></title>
    <url>%2F2018%2F08%2F12%2FACM%2FDP%2FBase%20DP%2F%E5%9F%BA%E6%9C%ACDP%20LIS%20%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97%20%E4%B8%A4%E7%A7%8D%E8%A7%92%E5%BA%A6%E5%8F%8A%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[动态规划—最长上升子序列问题 最长上升子序列 [ OpenJ_Bailian - 2757 ] 一个数的序列 bi，当 b1 &lt; b2 &lt; … &lt; bS的时候，我们称这个序列是上升的。对于给定的一个序列( a1, a2, …, aN)，我们可以得到一些上升的子序列( ai1, ai2, …, aiK)，这里1 &lt;= i1 &lt; i2 &lt; … &lt; iK &lt;= N。比如，对于序列(1, 7, 3, 5, 9, 4, 8)，有它的一些上升子序列，如(1, 7), (3, 4, 8)等等。这些子序列中最长的长度是4，比如子序列(1, 3, 5, 8). 你的任务，就是对于给定的序列，求出最长上升子序列的长度。 Input输入的第一行是序列的长度N (1 &lt;= N &lt;= 1000)。第二行给出序列中的N个整数，这些整数的取值范围都在0到10000。 Output最长上升子序列的长度。 Sample Input1271 7 3 5 9 4 8 Sample Output14 题解找子问题 “求以ak（k=1, 2, 3…N）为终点的最长上升子序列的 一个上升子序列中最右边的那个数，称为该子序列的长度” “终点”。 虽然这个子问题和原问题形式上并不完全一样，但是只要这N个子问题都解决了，那么这N个子问题的解中，最大的那个就是整个问题的解。 方法一状态i的值dp[i] 由若干个值已知的状态值dp[0], dp[1], …, dp[i-1]推出。复杂度O(n2) 12345678910111213141516171819202122232425262728#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std; const int MAX_N = 2000;int a[MAX_N];int dp[MAX_N]; int main(void) &#123; int n; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++)&#123; scanf("%d", &amp;a[i]); dp[i] = 1; &#125; for (int i = 1; i &lt; n; i++) for (int j = 0; j &lt; i; j++) if(a[j] &lt; a[i]) dp[i] = max(dp[i], dp[j] + 1); cout &lt;&lt; *max_element(dp, dp + n) &lt;&lt; endl; return 0;&#125; 方法二状态i的值dp[i]在被更新的时候, 依据dp[i]去更新和状态i相关的dp[i+1], …, dp[n-1]的值。复杂度O(n2) 12345678910111213141516171819202122232425262728#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std; const int MAX_N = 2000;int a[MAX_N];int dp[MAX_N]; int main(void) &#123; int n; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++)&#123; scanf("%d", &amp;a[i]); dp[i] = 1; &#125; for (int i = 0; i &lt; n; i++) for (int j = i + 1; j &lt; n; j++) if(a[j] &gt; a[i]) dp[j] = max(dp[j], dp[i] + 1); cout &lt;&lt; *max_element(dp, dp + n) &lt;&lt; endl; return 0;&#125; 优化将全部dp[i]的值初始化为INF。然后数组中除了INF之外为单调递增，所以每个dp[i]最多只需要一次更新。对于更新位置不必逐个遍历，可以利用二分搜索，这样复杂度可降为O(nlogn) 1234567891011121314151617181920212223242526#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std; const int MAX_N = 2000;const int INF = 9999999;int a[MAX_N];int dp[MAX_N]; int main(void) &#123; int n; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) scanf("%d", &amp;a[i]); fill(dp, dp + n, INF); for (int i = 0; i &lt; n; i++) *lower_bound(dp, dp + n, a[i]) = a[i]; cout &lt;&lt; lower_bound(dp, dp + n, INF) - dp &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>动态规划</category>
        <category>基本DP</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基本DP 百炼 - 2755 神奇的口袋]]></title>
    <url>%2F2018%2F08%2F10%2FACM%2FDP%2FBase%20DP%2F%E5%9F%BA%E6%9C%ACDP%20%E8%83%8C%E5%8C%85%20%E7%99%BE%E7%82%BC-2755%20%E7%A5%9E%E5%A5%87%E7%9A%84%E5%8F%A3%E8%A2%8B%2F</url>
    <content type="text"><![CDATA[神奇的口袋[ HDU - 2069 ] 题目大意：背包问题 思路设V(m,n)表示在n个数字中插入m个加号所能形成 的表达式最小值，那么: if m = 0 V(m,n) = n个数字构成的整数 else if n &lt; m + 1 V(m,n) = ∞ else V(m,n) = Min{ V(m-1,i) + Num(i+1,n) } ( i = m … n-1) Num(i,j)表示从第i个数字到第j个数字所组成的数。数字编号从1开始算。此操 作复杂度是O(j-i+1)，可以预处理后存起来。 总时间复杂度:O(mn2) 题解代码12345678910111213141516171819202122232425262728#include&lt;bits/stdc++.h&gt;using namespace std;int dp[50][50];int a[50];int main(void)&#123; int n; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;a[i]); for (int i = 1; i &lt;= n; i++) dp[0][i] = 1; dp[0][0] = 1; for (int i = 1; i &lt;= 40; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; dp[i][j] = dp[i][j - 1]; if (i - a[j] &gt;= 0) dp[i][j] += dp[i - a[j]][j - 1]; &#125; &#125; cout &lt;&lt; dp[40][n] &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>动态规划</category>
        <category>基本DP</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基本DP LCS 最长公共子序列 HDU-1159 Common Subsequence]]></title>
    <url>%2F2018%2F08%2F09%2FACM%2FDP%2FBase%20DP%2F%E5%9F%BA%E6%9C%ACDP%20LCS%20%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97%20HDU-1159%20Common%20Subsequence%2F</url>
    <content type="text"><![CDATA[动态规划—最长公共子序列问题 Common Subsequence [ HDU - 1159 ] A subsequence of a given sequence is the given sequence with some elements (possible none) left out. Given a sequence X = another sequence Z = is a subsequence of X if there exists a strictly increasing sequence of indices of X such that for all j = 1,2,…,k, xij = zj. For example, Z = is a subsequence of X = with index sequence . Given two sequences X and Y the problem is to find the length of the maximum-length common subsequence of X and Y.The program input is from a text file. Each data set in the file contains two strings representing the given sequences. The sequences are separated by any number of white spaces. The input data are correct. For each set of data the program prints on the standard output the length of the maximum-length common subsequence from the beginning of a separate line. Sample Input123abcfbc abfcabprogramming contest abcd mnp Sample Output123420 题解输入两个串s,t, 设dp(i,j)表示: s的左边i个字符形成的子串，与t左边的j个 字符形成的子串的最长公共子序列的长度(i,j从0 开始算)dp(i,j) 就是本题的“状态”假定 len1 = strlen(s),len2 = strlen(t）那么题目就是要求 dp[len1,len2] 显然：dp(n,0) = 0 ( n= 0…len1）dp(0,n) = 0 ( n= 0…len2） 递推公式：if ( s[i-1] == t[j-1] ) //s的最左边字符是s1[0]&emsp;dp(i,j) = dp(i-1,j-1) + 1;else&emsp;dp(i,j) = max(dp(i,j-1), dp(i-1,j) ); 时间复杂度O(mn) m,n是两个字串长度 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstdlib&gt;using namespace std;char s[1005], t[1005];int dp[1010][1010];int main(void)&#123; while(~scanf("%s%s" ,s ,t))&#123; int len1 = strlen(s); int len2 = strlen(t); for (int i = 0; i &lt;= len1; i++) dp[i][0] = 0; for (int i = 0; i &lt;= len2; i++) dp[0][i] = 0; for (int i = 0; i &lt; len1; i++)&#123; for (int j = 0; j &lt; len2; j++)&#123; if(s[i]==t[j]) dp[i + 1][j + 1] = dp[i][j] + 1; else dp[i + 1][j + 1] = max(dp[i][j + 1], dp[i + 1][j]); &#125; &#125; cout &lt;&lt; dp[len1][len2] &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>动态规划</category>
        <category>基本DP</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基本DP 背包 POJ - 3624 Charm Bracelet]]></title>
    <url>%2F2018%2F08%2F09%2FACM%2FDP%2FBase%20DP%2F%E5%9F%BA%E6%9C%ACDP%20%E8%83%8C%E5%8C%85%20POJ-3624%20Charm%20Bracelet%2F</url>
    <content type="text"><![CDATA[Charm Bracelet[ POJ - 3624 ] 题目大意：0-1背包 思路 用 F[i][j] 表示取前i种物品，使它们总体积不超过j的 最优取法取得的价值总和。要求F[N][M]边界: if (w[1] &lt;= j) F[1][j] = d[1]; else F[1][j] = 0; 用 F[i][j] 表示取前i种物品，使它们总体积不超过j的 最优取法取得的价值总和 递推: F[i][j] = max(F[i-1][j],F[i-1][j-w[i]]+d[i]) 取或不取第 i种物品，两者选优 (j-w[i] &gt;= 0才有第二项) F[i][j] = max(F[i-1][j],F[i-1][j-w[i]]+d[i]) 本题如用记忆型递归，需要一个很大的二维数组，会超内存。注意到这个二维数组的下一行的值，只用到了上一行的正上方及左边的值，因此可用滚动数组的思想，只要一行即可。即可以用一维数组，用“人人为我” 递推型动归实现。 题解代码123456789101112131415161718192021222324#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 4000;int dp[13000];int a[maxn], b[maxn];int main(void)&#123; int n, m; while (~scanf("%d%d", &amp;n, &amp;m)) &#123; memset(dp, 0, sizeof(dp)); for (int i = 1; i &lt;= n; i++) scanf("%d%d", &amp;a[i], &amp;b[i]); for (int i = 1; i &lt;= n; i++) for (int j = m; j &gt;= a[i]; j--) dp[j] = max(dp[j], dp[j-a[i]] + b[i]); cout &lt;&lt; dp[m] &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>动态规划</category>
        <category>基本DP</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基本DP POJ - 1458 Common Subsequence]]></title>
    <url>%2F2018%2F08%2F07%2FACM%2FDP%2FBase%20DP%2F%E5%9F%BA%E6%9C%ACDP%20POJ-1458%20Common%20Subsequence%2F</url>
    <content type="text"><![CDATA[Common Subsequence [ POJ - 1458 ] 题目大意：输入两个串s1,s2, 设MaxLen(i,j)表示: s1的左边i个字符形成的子串，与s2左边的j个字符形成的子串的最长公共子序列的长度(i,j从0 开始算) MaxLen(i,j) 就是本题的“状态” 假定 len1 = strlen(s1),len2 = strlen(s2) 那么题目就是要求 MaxLen(len1,len2) 思路 显然: MaxLen(n,0) = 0 ( n= 0…len1) MaxLen(0,n) = 0 ( n=0…len2) 递推公式:1234if ( s1[i-1] == s2[j-1] ) //s1的最左边字符是s1[0] MaxLen(i,j) = MaxLen(i-1,j-1) + 1; else MaxLen(i,j) = Max(MaxLen(i,j-1),MaxLen(i-1,j) ); 时间复杂度O(mn) m,n是两个字串长度 题解代码123456789101112131415161718192021222324#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1000 + 10;int dp[maxn][maxn];char a[maxn], b[maxn];int main(void)&#123; while (cin &gt;&gt; a &gt;&gt; b) &#123; memset(dp, 0, sizeof(dp)); int len1 = strlen(a); int len2 = strlen(b); for(int i = 0; i &lt; len1; i++) &#123; for(int j = 0; j &lt; len2; j++) &#123; if(a[i] == b[j]) dp[i+1][j+1] = dp[i][j] + 1; else dp[i+1][j+1] = max(dp[i][j+1], dp[i+1][j]); &#125; &#125; cout &lt;&lt; dp[len1][len2] &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>动态规划</category>
        <category>基本DP</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Github博客打开速度太慢利用Coding处理方法]]></title>
    <url>%2F2018%2F08%2F06%2FAbout%20blog%2FGithub%E5%8D%9A%E5%AE%A2%E6%89%93%E5%BC%80%E9%80%9F%E5%BA%A6%E5%A4%AA%E6%85%A2%E5%88%A9%E7%94%A8Coding%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[很多人都选择用github搭建个人博客，但是国内很多地方访问速度都很慢。因此可以选择将博客同时同步到coding和github然后二者绑定同一域名即可可以自己购买一个域名，或者不想花钱或嫌域名备案麻烦的可以直接绑定自己的github博客地址同理也可以选择在github中绑定自己的coding博客地址 具体操作如下： 博客设置文件更改如下：123456deploy: type: git repository: hithub: git@github.com:mfdy/mfdy.github.io.git coding: git@git.coding.net:mfdy/mfdy.git branch: master 在coding上建立项目等与github类似，所以省略……然后SSH可以直接用当时github生成的，建议直接添加到个人设置里。添加到项目设置中默认权限是只读的，可能会造成一系列的问题。 coding上要用户名在前的地址是需要启动 代码 - pages服务 的&nbsp;&nbsp;&nbsp;&nbsp;这里选择静态Pages即可。 之后在博客根目录右键Git Bash，输入1ssh -T git@git.coding.net 得到以下回复即为成功1Coding.net Tips : [Hello ! You've conected to Coding.net by SSH successfully! ] 下来CMD输入命令上传并发布1hexo d -g 截至到此，你的两个代码仓库都部署好博客了然后给二者绑定同一域名这里可以选择购买一个个人域名绑定但是个人域名需要花钱而且备案时间又有点长比较麻烦 这时候就——重点来了 在coding的pages自定义域名中直接绑定自己的github域名即可 同理也可以选择在github中绑定自己的coding博客地址]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基本DP HDU - 2069 Coin Change]]></title>
    <url>%2F2018%2F08%2F06%2FACM%2FDP%2FBase%20DP%2F%E5%9F%BA%E6%9C%ACDP%20HDU-2069%20Coin%20Change%2F</url>
    <content type="text"><![CDATA[Coin Change [ HDU - 2069 ] 题目大意：有五种面值的硬币，面值分别为v1, v2, …, vn, 数量无限。输入一个数，求这个价值所有可能的硬币组合 思路定义dp[i][j], 表示价格为i时用j枚硬币的方案数量 dp[i][j] = dp[i][j] + dp[1 - type[k]][j - 1]; 题解代码123456789101112131415161718192021222324252627282930313233#include&lt;bits/stdc++.h&gt;using namespace std;const int coin = 101;const int money = 251;int dp[money][coin];int ans[money];int type[5] = &#123;1, 5, 10, 25, 50&#125;;void solve(void)&#123; dp[0][0] = 1; for (int i = 0; i &lt; 5; i++) for (int j = 1; j &lt; coin; j++) for (int k = type[i]; k &lt; money; k++) dp[k][j] += dp[k - type[i]][j - 1];&#125;int main(void)&#123; int s; memset(dp, 0, sizeof(dp)); memset(ans, 0, sizeof(ans)); solve(); for (int i = 0; i &lt; money; i++) for (int j = 0; j &lt; coin; j++) ans[i] += dp[i][j]; while (cin &gt;&gt; s) cout &lt;&lt; ans[s] &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>动态规划</category>
        <category>基本DP</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[更换个人博客地址]]></title>
    <url>%2F2018%2F08%2F05%2FAbout%20blog%2F%E6%9B%B4%E6%8D%A2%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%9C%B0%E5%9D%80%2F</url>
    <content type="text"><![CDATA[博客搬家了！&lt;/br&gt;&emsp;从csdn搬过来了，同时原csdn博客基本不再更新（有时候嫌麻烦会更新，但这里会同步）&lt;/br&gt; &lt;/br&gt;原csdn博客地址：MFDY’s csdn blog&lt;/br&gt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[BFS:图的最短路径 &nbsp;Aizu-0558 &nbsp;​​​​​​​Cheese]]></title>
    <url>%2F2018%2F08%2F05%2FACM%2FThinking%2FBFS%20Aizu%20-%200558%20%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8BCheese%2F</url>
    <content type="text"><![CDATA[Cheese[ Aizu - 0558 ] 大意：在H * W的地图上有N个奶酪工厂，每个工厂分别生产硬度为1-N的奶酪。有一只老鼠准备从出发点吃遍每一个工厂的奶酪。老鼠有一个体力值，初始时为1，每吃一个工厂的奶酪体力值增加1（每个工厂只能吃一次），且老鼠只能吃硬度不大于当前体力值的奶酪。 老鼠从当前格到上下左右相邻的无障碍物的格需要时间1单位，有障碍物的格不能走。走到工厂上时即可吃到该工厂的奶酪，吃奶酪时间不计。问吃遍所有奶酪最少用时。 输入：第一行三个整数H(1 &lt;= H &lt;= 1000)、W(1 &lt;= W &lt;=1000)、N(1 &lt;= N &lt;= 9)，之后H行W列为地图， “.“为空地， ”X“为障碍物，”S“为老鼠洞， 1-N代表硬度为1-N的奶酪的工厂。输出最少用时。 今年も JOI 町のチーズ工場がチーズの生産を始め，ねずみが巣から顔を出した．JOI 町は東西南北に区画整理されていて，各区画は巣，チーズ工場，障害物，空き地のいずれかである．ねずみは巣から出発して全てのチーズ工場を訪れチーズを 1 個ずつ食べる． この町には，N 個のチーズ工場があり，どの工場も１種類のチーズだけを生産している．チーズの硬さは工場によって異なっており，硬さ 1 から N までのチーズを生産するチーズ工場がちょうど 1 つずつある． ねずみの最初の体力は 1 であり，チーズを 1 個食べるごとに体力が 1 増える．ただし，ねずみは自分の体力よりも硬いチーズを食べることはできない． ねずみは，東西南北に隣り合う区画に 1 分で移動することができるが，障害物の区画には入ることができない．チーズ工場をチーズを食べずに通り過ぎることもできる．すべてのチーズを食べ終えるまでにかかる最短時間を求めるプログラムを書け．ただし，ねずみがチーズを食べるのにかかる時間は無視できる． Input 入力は H+1 行ある．1 行目には 3 つの整数 H，W，N (1 ≤ H ≤ 1000，1 ≤ W ≤ 1000，1 ≤ N ≤ 9) がこの順に空白で区切られて書かれている．2 行目から H+1 行目までの各行には，’S’，’1’, ‘2’, …, ‘9’，’X’，’.’ からなる W 文字の文字列が書かれており，各々が各区画の状態を表している．北から i 番目，西から j 番目の区画を (i,j) と記述することにすると (1 ≤ i ≤ H, 1 ≤ j ≤ W)，第 i+1 行目の j 番目の文字は，区画 (i,j) が巣である場合は ‘S’ となり，障害物である場合は ‘X’ となり，空き地である場合は ‘.’ となり，硬さ 1, 2, …, 9 のチーズを生産する工場である場合はそれぞれ ‘1’, ‘2’, …, ‘9’ となる．入力には巣と硬さ 1, 2, …, N のチーズを生産する工場がそれぞれ 1 つずつある．他のマスは障害物または空き地であることが保証されている．ねずみは全てのチーズを食べられることが保証されている． Output すべてのチーズを食べ終えるまでにかかる最短時間（分）を表す整数を 1 行で出力せよ． Sample Input 112343 3 1S.......1 Sample Output 114 Sample Input 2123454 5 2.X..1....X.XX.S.2.X. Sample Output 2112 Sample Input 3123456789101110 10 9.X...X.S.X6..5X..X1X...XXXX..XX..9X...X.8.X2X..X3X...XX.X4..XX....7X..X..X..XX..X...X.XX....X....... Sample Output 3191 問題文と自動審判に使われるデータは、情報オリンピック日本委員会が作成し公開している問題文と採点用テストデータです。 BFS变下形就行，注意数组范围……123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;string&gt;#include&lt;cstdio&gt;#include&lt;cctype&gt;#include&lt;queue&gt;#include&lt;cmath&gt;#include&lt;map&gt;#include&lt;set&gt;using namespace std;const int INF = 100000000, maxn = 1005;//可以使用结构体typedef pair&lt;int, int&gt; P; char maze[maxn][maxn];int n, m, k, sx, sy, gx[10], gy[10];//到各个位置的最短距离的数组int d[maxn][maxn];//4个方向移动的向量int dx[4] = &#123;1, 0, -1, 0&#125;, dy[4] = &#123;0, 1, 0, -1&#125;; //求从(sx,sy)到(gx,gy)的最短距离//若无法到达则是INFint bfs(int sx, int sy, int gx, int gy)&#123; queue&lt;P&gt; que; //所有的位置都初始化为INF for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; m; j++) d[i][j] = INF; que.push(P(sx, sy)); //将起点加入队列中 d[sx][sy] = 0; //并把这一地点的距离设置为0 //不断循环直到队列的长度为0 while (que.size())&#123; P p = que.front(); // 从队列的最前段取出元素 que.pop(); //取出后从队列中删除该元素 if (p.first == gx &amp;&amp; p.second == gy) break; //四个方向的循环 for (int i = 0; i &lt; 4; i++)&#123; //移动后的位置标记为(nx,ny) int nx = p.first + dx[i], ny = p.second + dy[i]; //判断是否可以移动以及是否访问过(即d[nx][ny]!=INF） if (0 &lt;= nx &amp;&amp; nx &lt; n &amp;&amp; 0 &lt;= ny &amp;&amp; ny &lt; m &amp;&amp; maze[nx][ny] != 'X' &amp;&amp; d[nx][ny] == INF)&#123; que.push(P(nx, ny)); //可以移动，添加到队列 d[nx][ny] = d[p.first][p.second] + 1; //到该位置的距离为到p的距离+1 &#125; &#125; &#125; return d[gx][gy];&#125; int main()&#123; cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; int t; for (int i = 0; i &lt; n; i++)&#123; for (int j = 0; j &lt; m; j++)&#123; cin &gt;&gt; maze[i][j]; if(maze[i][j]=='S')&#123; gx[0] = i; gy[0] = j; &#125;else if (isdigit(maze[i][j]))&#123; t = maze[i][j] - '0'; gx[t] = i; gy[t] = j; &#125; &#125; &#125; int sum = 0; for (int i = 1; i &lt;= k; i++) sum += bfs(gx[i - 1], gy[i - 1], gx[i], gy[i]); cout &lt;&lt; sum &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>Thinking</category>
        <category>BFS</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>Thinking</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DFS:图的联通块 &nbsp;POJ-1979 &nbsp;Red and Black]]></title>
    <url>%2F2018%2F08%2F05%2FACM%2FThinking%2FDFS%20POJ-1979%20Red%20and%20Black%2F</url>
    <content type="text"><![CDATA[Red and Black[ POJ - 1979] &nbsp;&nbsp;Here is a rectangular room, covered with square tiles. Each tile is colored either red or black. A man is standing on a black tile. From a tile, he can move to one of four adjacent tiles. But he can’t move on red tiles, he can move only on black tiles.&nbsp;&nbsp;Write a program to count the number of black tiles which he can reach by repeating the moves described above. Input The input consists of multiple data sets. A data set starts with a line containing two positive integers W and H; W and H are the numbers of tiles in the x- and y- directions, respectively. W and H are not more than 20.There are H more lines in the data set, each of which includes W characters. Each character represents the color of a tile as follows.‘.’ - a black tile‘#’ - a red tile‘@’ - a man on a black tile(appears exactly once in a data set)The end of the input is indicated by a line consisting of two zeros. Output For each data set, your program should output a line which contains the number of tiles he can reach from the initial tile (including itself). Sample Input1234567891011121314151617181920212223242526272829303132333435366 9....#......#..............................#@...#.#..#.11 9.#..........#.#######..#.#.....#..#.#.###.#..#.#..@#.#..#.#####.#..#.......#..#########............11 6..#..#..#....#..#..#....#..#..###..#..#..#@...#..#..#....#..#..#..7 7..#.#....#.#..###.###...@...###.###..#.#....#.#..0 0 Sample Output12344559613 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstdlib&gt;using namespace std; int m, n, sum;char garden[105][105];int d[4][2] = &#123; &#123;0, -1&#125;, &#123;1, 0&#125;, &#123;0, 1&#125;, &#123;-1, 0&#125;,&#125;; void dfs(int x, int y)&#123; garden[x][y] = '#'; sum++; for (int i = 0; i &lt; 4; i++)&#123; int nx = x + d[i][1]; int ny = y + d[i][0]; if(0&lt;=nx &amp;&amp; nx&lt;n &amp;&amp; 0&lt;=ny &amp;&amp; ny&lt;m &amp;&amp; garden[nx][ny]=='.') dfs(nx, ny); &#125;&#125; int main(void)&#123; while(~scanf("%d%d", &amp;m, &amp;n) &amp;&amp; m+n)&#123; getchar(); memset(garden, 0, sizeof(garden)); for (int i = 0; i &lt; n; i++)&#123; for (int j = 0; j &lt; m; j++) scanf("%c", &amp;garden[i][j]); getchar(); &#125; sum = 0; for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; m; j++) if (garden[i][j] == '@') dfs(i, j); cout &lt;&lt; sum &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>Thinking</category>
        <category>DFS</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>Thinking</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DFS图的联通块 &nbsp;UVA-572 &nbsp;Oil Deposits]]></title>
    <url>%2F2018%2F08%2F05%2FACM%2FThinking%2FDFS%20UVA-572%20Oil%20Deposits%2F</url>
    <content type="text"><![CDATA[Oil Deposits[ UVA - 572 ]&nbsp;&nbsp;The GeoSurvComp geologic survey company is responsible for detecting underground oil deposits. GeoSurvComp works with one large rectangular region of land at a time, and creates a grid that divides the land into numerous square plots. It then analyzes each plot separately, using sensing equipment to determine whether or not the plot contains oil. &nbsp;&nbsp;A plot containing oil is called a pocket. If two pockets are adjacent, then they are part of the same oil deposit. Oil deposits can be quite large and may contain numerous pockets. Your job is to determine how many different oil deposits are contained in a grid. Input The input file contains one or more grids. Each grid begins with a line containing m and n, the number of rows and columns in the grid, separated by a single space. If m = 0 it signals the end of the input; otherwise 1 ≤ m ≤ 100 and 1 ≤ n ≤ 100. Following this are m lines of n characters each (not counting the end-of-line characters). Each character corresponds to one plot, and is either ‘*’, representing the absence of oil, or ‘@’, representing an oil pocket. Output For each grid, output the number of distinct oil deposits. Two different pockets are part of the same oil deposit if they are adjacent horizontally, vertically, or diagonally. An oil deposit will not contain more than 100 pockets. Sample Input1234567891011121314151 1*3 5*@*@***@***@*@*1 8@@****@*5 5****@*@@*@*@**@@@@*@@@**@0 0 Hint12340122 分析从每个”@”格子出发，递归遍历它周围的”@”格子。 每次访问就把他标记成”*”，即不通路（或者可以用数组表示是否访问过）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstdlib&gt;using namespace std; int m, n;char garden[105][105]; void dfs(int x, int y)&#123; //将当前点取消标记，避免重复查找 garden[x][y] = '*'; //遍历周围的八个点 for (int dx = -1; dx &lt;= 1; dx++)&#123; for (int dy = -1; dy &lt;= 1;dy++)&#123; int nx = x + dx; int ny = y + dy; if(0&lt;=nx &amp;&amp; nx&lt;n &amp;&amp; 0&lt;=ny &amp;&amp; ny&lt;m &amp;&amp; garden[nx][ny]=='@') dfs(nx, ny); &#125; &#125;&#125; int main(void)&#123; while(~scanf("%d%d", &amp;n, &amp;m) &amp;&amp; m+n)&#123; getchar(); //吸收两数字后的换行符 memset(garden, 0, sizeof(garden)); for (int i = 0; i &lt; n;i++)&#123; for (int j = 0; j &lt; m;j++) scanf("%c", &amp;garden[i][j]); getchar(); //吸收每次输入一行后的换行符 &#125; int sum = 0; for (int i = 0; i &lt; n; i++)&#123; for (int j = 0; j &lt; m; j++)&#123; if (garden[i][j] == '@')&#123; dfs(i, j); sum++; &#125; &#125; &#125; cout &lt;&lt; sum &lt;&lt; endl; &#125; system("pause"); return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>Thinking</category>
        <category>DFS</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>Thinking</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DFS:图的联通块&nbsp; AOJ-0118&nbsp; Property Distribution]]></title>
    <url>%2F2018%2F08%2F05%2FACM%2FThinking%2FDFS%20AOJ-0118%20Property%20Distribution%2F</url>
    <content type="text"><![CDATA[Property Distribution[ Aizu - 0118 ] 这道题类似于联通图问题，将联通的归成一个，数一下总共有几个即可。 因为题目告诉不会有空格，所以排除标记用空格表示即可。 タナカ氏が HW アールの果樹園を残して亡くなりました。果樹園は東西南北方向に H × W の区画に分けられ、区画ごとにリンゴ、カキ、ミカンが植えられています。タナカ氏はこんな遺言を残していました。 果樹園は区画単位でできるだけ多くの血縁者に分けること。ただし、ある区画の東西南北どれかの方向にとなりあう区画に同じ種類の果物が植えられていた場合は、区画の境界が分からないのでそれらは 1 つの大きな区画として扱うこと。 例えば次のような 3 × 10 の区画であれば (‘リ’はリンゴ、’カ’はカキ、’ミ’はミカンを表す) 同じ樹がある区画の間の境界を消すと次のようになり、 結局 10 個の区画、つまり 10 人で分けられることになります。 雪が降って区画の境界が見えなくなる前に分配を終えなくてはなりません。あなたの仕事は果樹園の地図をもとに分配する区画の数を決めることです。 果樹園の地図を読み込み、分配を受けられる血縁者の人数を出力するプログラムを作成してください。 Input 複数のデータセットが与えられます。各データセットは空白で区切られた H, W (H, W ≤ 100) を含む行から始まり、続いて H × W の文字からなる H 行の文字列が与えられます。この文字列には、リンゴを表す ‘@’、カキを表す ‘#’、ミカンを表す ‘*’、の 3 文字しか現れません。 入力はゼロが２つの行で終わります。データセットの数は 20 を超えません。 Output 複数のデータセットが与えられます。各データセットは空白で区切られた H, W (H, W ≤ 100) を含む行から始まり、続いて H × W の文字からなる H 行の文字列が与えられます。この文字列には、リンゴを表す ‘@’、カキを表す ‘#’、ミカンを表す ‘*’、の 3 文字しか現れません。 入力はゼロが２つの行で終わります。データセットの数は 20 を超えません。 Sample Input12345678910111210 10####*****@@#@@@@#*#*@##***@@@*#****#*@**##@*#@@*##*@@@@*@@@#***#@*@##**@@@*@@##@*@*#*@##**@****#@@#@0 0 Sample Output133 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstdlib&gt;using namespace std; int m, n;char garden[105][105];int d[4][2] = &#123; &#123;0, -1&#125;, &#123;1, 0&#125;, &#123;0, 1&#125;, &#123;-1, 0&#125;,&#125;; void dfs(int x, int y, char c)&#123; if(garden[x][y] == c)&#123; garden[x][y] = ' '; for (int i = 0; i &lt; 4; i++)&#123; int nx = x + d[i][1]; int ny = y + d[i][0]; if (0 &lt;= nx &amp;&amp; nx &lt; n &amp;&amp; 0 &lt;= ny &amp;&amp; ny &lt; m &amp;&amp; garden[nx][ny] != ' ') dfs(nx, ny, c); &#125; &#125;&#125; int main(void)&#123; while(~scanf("%d%d", &amp;n, &amp;m) &amp;&amp; m+n)&#123; getchar(); memset(garden, 0, sizeof(garden)); for (int i = 0; i &lt; n; i++)&#123; for (int j = 0; j &lt; m; j++) scanf("%c", &amp;garden[i][j]); getchar(); &#125; int sum = 0; for (int i = 0; i &lt; n; i++)&#123; for (int j = 0; j &lt; m; j++)&#123; if (garden[i][j] != ' ')&#123; dfs(i, j, garden[i][j]); sum++; &#125; &#125; &#125; cout &lt;&lt; sum &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>Thinking</category>
        <category>DFS</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>Thinking</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DFS深入优先搜索 &nbsp;POJ-2386 &nbsp;Lake Counting]]></title>
    <url>%2F2018%2F08%2F05%2FACM%2FThinking%2FDFS%20POJ-2386%20Lake%20Counting%2F</url>
    <content type="text"><![CDATA[Lake Counting[POJ - 2386] Due to recent rains, water has pooled in various places in Farmer John’s field, which is represented by a rectangle of N x M (1 &lt;= N &lt;= 100; 1 &lt;= M &lt;= 100) squares. Each square contains either water (‘W’) or dry land (‘.’). Farmer John would like to figure out how many ponds have formed in his field. A pond is a connected set of squares with water in them, where a square is considered adjacent to all eight of its neighbors.Given a diagram of Farmer John’s field, determine how many ponds he has. Input Line 1: Two space-separated integers: N and M Lines 2..N+1: M characters per line representing one row of Farmer John’s field. Each character is either ‘W’ or ‘.’. The characters do not have spaces between them. Output Line 1: The number of ponds in Farmer John’s field. Sample Input123456789101110 12W........WW..WWW.....WWW....WW...WW..........WW..........W....W......W...W.W.....WW.W.W.W.....W..W.W......W...W.......W. Sample Output13 HintOUTPUT DETAILS:There are three ponds: one in the upper left, one in the lower left,and one along the right side. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstdlib&gt;using namespace std; int m, n;char garden[105][105]; void dfs(int x, int y)&#123; //将当前点取消标记，避免重复查找 garden[x][y] = '.'; //遍历周围的八个点 for (int dx = -1; dx &lt;= 1; dx++)&#123; for (int dy = -1; dy &lt;= 1;dy++)&#123; int nx = x + dx; int ny = y + dy; if(0&lt;=nx &amp;&amp; nx&lt;n &amp;&amp; 0&lt;=ny &amp;&amp; ny&lt;m &amp;&amp; garden[nx][ny]=='W') dfs(nx, ny); &#125; &#125;&#125; int main(void)&#123; while(~scanf("%d%d", &amp;n,&amp;m))&#123; getchar(); //吸收两数字后的换行符 memset(garden, 0, sizeof(garden)); for (int i = 0; i &lt; n;i++)&#123; for (int j = 0; j &lt; m;j++) scanf("%c", &amp;garden[i][j]); getchar(); //吸收每次输入一行后的换行符 &#125; int sum = 0; for (int i = 0; i &lt; n; i++)&#123; for (int j = 0; j &lt; m; j++)&#123; if (garden[i][j] == 'W')&#123; dfs(i, j); sum++; &#125; &#125; &#125; cout &lt;&lt; sum &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>Thinking</category>
        <category>DFS</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>Thinking</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[贪心 &nbsp;POJ-2376 ​​​​​​​&nbsp;Cleaning Shifts]]></title>
    <url>%2F2018%2F08%2F05%2FACM%2FThinking%2F%E8%B4%AA%E5%BF%83%20POJ%20-%202376%20%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8BCleaning%20Shifts%2F</url>
    <content type="text"><![CDATA[Cleaning Shifts[ POJ - 2376 ] Farmer John is assigning some of his N (1 &lt;= N &lt;= 25,000) cows to do some cleaning chores around the barn. He always wants to have one cow working on cleaning things up and has divided the day into T shifts (1 &lt;= T &lt;= 1,000,000), the first being shift 1 and the last being shift T.Each cow is only available at some interval of times during the day for work on cleaning. Any cow that is selected for cleaning duty will work for the entirety of her interval.Your job is to help Farmer John assign some cows to shifts so that (i) every shift has at least one cow assigned to it, and (ii) as few cows as possible are involved in cleaning. If it is not possible to assign a cow to each shift, print -1. Input Line 1: Two space-separated integers: N and T Lines 2..N+1: Each line contains the start and end times of the interval during which a cow can work. A cow starts work at the start time and finishes after the end time. Output Line 1: The minimum number of cows Farmer John needs to hire or -1 if it is not possible to assign a cow to each shift. Sample Input12343 101 73 66 10 Sample Output12 HintThis problem has huge input data,use scanf() instead of cin to read data to avoid time limit exceed.INPUT DETAILS:There are 3 cows and 10 shifts. Cow #1 can work shifts 1..7, cow #2 can work shifts 3..6, and cow #3 can work shifts 6..10.OUTPUT DETAILS:By selecting cows #1 and #3, all shifts are covered. There is no way to cover all the shifts using fewer than 2 cows. 先对起始时间进行排序，然后对于没有取过的牛进行处理，判断即可。123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;queue&gt;using namespace std; const int maxn = 25050;pair&lt;int, int&gt; it[maxn]; int n, t; int main(void)&#123; cin &gt;&gt; n &gt;&gt; t; for (int i = 0; i &lt; n; i++) &#123; scanf("%d%d", &amp;it[i].first, &amp;it[i].second); &#125; sort(it, it + n); int sum = 0; int ju = 0, maxn = 0; while (maxn &lt; t) &#123; int ans = maxn + 1; for (int i = ju; i &lt; n; i++) &#123; if (it[i].first &lt;= ans &amp;&amp; it[i].second &gt;= ans) &#123; maxn = max(maxn, it[i].second); &#125;else if (it[i].first &gt; ans) &#123; ju = i; break; &#125; &#125; if(ans &gt; maxn) break; else sum++; &#125; if (maxn &gt;= t) cout &lt;&lt; sum &lt;&lt; endl; else cout &lt;&lt; "-1" &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>Thinking</category>
        <category>贪心</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>Thinking</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[贪心 &nbsp;POJ-3617 ​​​​​​​&nbsp;Best Cow Line]]></title>
    <url>%2F2018%2F08%2F05%2FACM%2FThinking%2F%E8%B4%AA%E5%BF%83%20POJ%20-%203617%20%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8BBest%20Cow%20Line%2F</url>
    <content type="text"><![CDATA[Best Cow Line[ POJ - 3617 ] &nbsp;&nbsp;FJ is about to take his N (1 ≤ N ≤ 2,000) cows to the annual”Farmer of the Year” competition. In this contest every farmer arranges his cows in a line and herds them past the judges.&nbsp;&nbsp;The contest organizers adopted a new registration scheme this year: simply register the initial letter of every cow in the order they will appear (i.e., If FJ takes Bessie, Sylvia, and Dora in that order he just registers BSD). After the registration phase ends, every group is judged in increasing lexicographic order according to the string of the initials of the cows’ names.&nbsp;&nbsp;FJ is very busy this year and has to hurry back to his farm, so he wants to be judged as early as possible. He decides to rearrange his cows, who have already lined up, before registering them.&nbsp;&nbsp;FJ marks a location for a new line of the competing cows. He then proceeds to marshal the cows from the old line to the new one by repeatedly sending either the first or last cow in the (remainder of the) original line to the end of the new line. When he’s finished, FJ takes his cows for registration in this new order.&nbsp;&nbsp;Given the initial order of his cows, determine the least lexicographic string of initials he can make this way. Input Line 1: A single integer: N Lines 2..N+1: Line i+1 contains a single initial (‘A’..’Z’) of the cow in the ith position in the original line Output The least lexicographic string he can make. Every line (except perhaps the last one) contains the initials of 80 cows (‘A’..’Z’) in the new line. Sample Input12345676ACDBCB Sample Output1ABCBCD 这道题就每次比较前后即可主要是细节方面的问题1.这道题字符串输入是一个一个输入……要么用getchar()收集，或者直接scanf(“ %c”, &amp;s[i])收集空白符2.注意每80个换一下行123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;iostream&gt;using namespace std; int par[1010];int ran[1010]; void init(int n)&#123; for(int i=1; i&lt;=n; i++)&#123; par[i]=i; ran[i]=0; &#125;&#125; int find(int x)&#123; if(par[x]==x) return x; else return par[x]=find(par[x]);&#125; void unite(int x, int y)&#123; x=find(x); y=find(y); if(x==y) return; if(ran[x]&lt;ran[y])&#123; par[x]=y; &#125;else&#123; par[y]=x; if(ran[x]==ran[y]) ran[x]++; &#125;&#125; int main(void)&#123; int t, m, n, a, b; cin &gt;&gt; t; while(t--)&#123; scanf("%d%d", &amp;n, &amp;m); init(n); for(int i=0; i&lt;m; i++)&#123; scanf("%d%d", &amp;a, &amp;b); if(a&lt;b) swap(a, b); unite(a, b); &#125; int sum=0; for(int i=1; i&lt;=n; i++)&#123; if(par[i]==i) sum++; &#125; printf("%d\n", sum); getchar(); &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>Thinking</category>
        <category>贪心</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>Thinking</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基本DP POJ - 1163 The Triangle]]></title>
    <url>%2F2018%2F08%2F05%2FACM%2FDP%2FBase%20DP%2F%E5%9F%BA%E6%9C%ACDP%20%E5%85%A5%E9%97%A8%20POJ-1163%20The%20Triangle%2F</url>
    <content type="text"><![CDATA[The Triangle [ POJ - 1163 ] 题目大意：用二维数组存放数字三角形。 D( r, j) : 第r行第 j 个数字(r, j从1开始算) MaxSum(r, j) : 从D(r, j)到底边的各条路径中，最佳路径的数字之和。问题:求 MaxSum(1, 1) 思路 典型的递归问题。 D(r, j)出发，下一步只能走D(r+1,j)或者D(r+1, j+1)。故对于N行的三角形: 1234if ( r == N) MaxSum(r,j) = D(r,j) else MaxSum( r, j) = Max&#123; MaxSum(r+1,j), MaxSum(r+1,j+1) &#125; + D(r,j) 但是！会超时! 如果每算出一个MaxSum(r,j)就保存起来，下次用到其值的时候直接取用，则可免去重复计算。 那么可以用O(n2)时间完成计算。因为三角形的数字总 数是 n(n+1)/2 然后我们将递归转化为递推即可，之后进行空间优化： 没必要用二维maxSum数组存储每一个MaxSum(r,j),只要从底层一行行向上递推， 那么只要一维数组maxSum[100]即可,即只要存储一行的MaxSum值就可以。 题解代码12345678910111213141516171819202122232425#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 100 + 10;int dp[maxn];int map[maxn][maxn];int main(void)&#123; int n; cin &gt;&gt; n; for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= i; j++) scanf("%d", &amp;map[i][j]); for(int i = 1; i &lt;= n; i++) dp[i] = map[n][i]; for(int i = n - 1; i &gt; 0; i--) for(int j = 1; j &lt;= i; j++) dp[j] = max(dp[j], dp[j+1]) + map[i][j]; cout &lt;&lt; dp[1] &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>动态规划</category>
        <category>基本DP</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线段树 &nbsp;HDU-1754 &nbsp;I Hate It]]></title>
    <url>%2F2018%2F08%2F05%2FACM%2FData%20Structure%2FSegment%20Tree%2F%E7%BA%BF%E6%AE%B5%E6%A0%91%20HDU-1754%2F</url>
    <content type="text"><![CDATA[I Hate It[HDU - 1754] 很多学校流行一种比较的习惯。老师们很喜欢询问，从某某到某某当中，分数最高的是多少。这让很多学生很反感。不管你喜不喜欢，现在需要你做的是，就是按照老师的要求，写一个程序，模拟老师的询问。当然，老师有时候需要更新某位同学的成绩。 Input 本题目包含多组测试，请处理到文件结束。在每个测试的第一行，有两个正整数 N 和 M ( 0&lt;N&lt;=200000,0&lt;M&lt;5000 )，分别代表学生的数目和操作的数目。学生ID编号分别从1编到N。第二行包含N个整数，代表这N个学生的初始成绩，其中第i个数代表ID为i的学生的成绩。接下来有M行。每一行有一个字符 C (只取’Q’或’U’) ，和两个正整数A，B。当C为’Q’的时候，表示这是一条询问操作，它询问ID从A到B(包括A,B)的学生当中，成绩最高的是多少。当C为’U’的时候，表示这是一条更新操作，要求把ID为A的学生的成绩更改为B。 Output 对于每一次询问操作，在一行里面输出最高成绩。 Sample Input123456785 61 2 3 4 5Q 1 5U 3 6Q 3 4Q 4 5U 2 9Q 1 5 Sample Output12345659 Hint1Huge input,the C function scanf() will work better than cin 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;string&gt;#include&lt;cstring&gt;using namespace std; struct node&#123; int l,r,max;&#125;t[810000]; int A[210000],max; int MAX(int a, int b)&#123; return a&gt;b ? a:b;&#125; void build(int l,int r,int k)&#123; t[k].l=l; t[k].r=r; if(l==r) t[k].max=A[r]; else&#123; build(l,(l+r)/2,k&lt;&lt;1); build((l+r)/2+1,r,k&lt;&lt;1|1); t[k].max=MAX(t[k&lt;&lt;1].max, t[k&lt;&lt;1|1].max); &#125;&#125; int query(int l,int r,int k)&#123; if(t[k].l&gt;=l &amp;&amp; t[k].r&lt;=r) return t[k].max; else&#123; int ans=0; int m=(t[k].l+t[k].r)/2; if(l&lt;=m) ans=query(l,r,k&lt;&lt;1); if(r&gt;m) ans=MAX(ans,query(l,r,k&lt;&lt;1|1)); return ans; &#125; &#125; void change(int a,int b,int k)&#123; if(t[k].l==a &amp;&amp; t[k].r==a)&#123; t[k].max=b; return; &#125; if(a&gt;(t[k].l+t[k].r)/2) change(a,b,2*k+1); else change(a,b,2*k); t[k].max=MAX(t[k*2].max, t[k*2+1].max);&#125; int main(void) &#123; int l,r,k,n,m; char command; while(scanf("%d%d",&amp;n,&amp;m)!=EOF)&#123; memset(t,0,sizeof(t)); memset(A,0,sizeof(A)); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;A[i]); build(1,n,1); getchar(); while(m--&gt;0)&#123; int a, b; scanf("%c%d%d",&amp;command,&amp;a,&amp;b); getchar(); if(command=='Q') cout &lt;&lt; query(a,b,1) &lt;&lt; endl; else if(command=='U') change(a,b,1); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>Data Structure</category>
        <category>线段树</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>Data Structure</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线段树 &nbsp;HDU-1166 &nbsp;敌兵布阵]]></title>
    <url>%2F2018%2F08%2F05%2FACM%2FData%20Structure%2FSegment%20Tree%2F%E7%BA%BF%E6%AE%B5%E6%A0%91%20HDU-1166%2F</url>
    <content type="text"><![CDATA[敌兵布阵[HDU - 1166] &nbsp;&nbsp;&nbsp;&nbsp;C国的死对头A国这段时间正在进行军事演习，所以C国间谍头子Derek和他手下Tidy又开始忙乎了。A国在海岸线沿直线布置了N个工兵营地,Derek和Tidy的任务就是要监视这些工兵营地的活动情况。由于采取了某种先进的监测手段，所以每个工兵营地的人数C国都掌握的一清二楚,每个工兵营地的人数都有可能发生变动，可能增加或减少若干人手,但这些都逃不过C国的监视。&nbsp;&nbsp;&nbsp;&nbsp;中央情报局要研究敌人究竟演习什么战术,所以Tidy要随时向Derek汇报某一段连续的工兵营地一共有多少人,例如Derek问:“Tidy,马上汇报第3个营地到第10个营地共有多少人!”Tidy就要马上开始计算这一段的总人数并汇报。但敌兵营地的人数经常变动，而Derek每次询问的段都不一样，所以Tidy不得不每次都一个一个营地的去数，很快就精疲力尽了，Derek对Tidy的计算速度越来越不满:”你个死肥仔，算得这么慢，我炒你鱿鱼!”Tidy想：“你自己来算算看，这可真是一项累人的工作!我恨不得你炒我鱿鱼呢!”无奈之下，Tidy只好打电话向计算机专家Windbreaker求救,Windbreaker说：“死肥仔，叫你平时做多点acm题和看多点算法书，现在尝到苦果了吧!”Tidy说：”我知错了。。。”但Windbreaker已经挂掉电话了。Tidy很苦恼，这么算他真的会崩溃的，聪明的读者，你能写个程序帮他完成这项工作吗？不过如果你的程序效率不够高的话，Tidy还是会受到Derek的责骂的. Input 第一行一个整数T，表示有T组数据。每组数据第一行一个正整数N（N&lt;=50000）,表示敌人有N个工兵营地，接下来有N个正整数,第i个正整数ai代表第i个工兵营地里开始时有ai个人（1&lt;=ai&lt;=50）。接下来每行有一条命令，命令有4种形式：(1) Add i j,i和j为正整数,表示第i个营地增加j个人（j不超过30）(2)Sub i j ,i和j为正整数,表示第i个营地减少j个人（j不超过30）;(3)Query i j ,i和j为正整数,i&lt;=j，表示询问第i到第j个营地的总人数;(4)End 表示结束，这条命令在每组数据最后出现;每组数据最多有40000条命令 Output 对第i组数据,首先输出“Case i:”和回车,对于每个Query询问，输出一个整数并回车,表示询问的段中的总人数,这个数保持在int以内。 Sample Input123456789101101 2 3 4 5 6 7 8 9 10Query 1 3Add 3 6Query 2 7Sub 10 2Add 6 3Query 3 10End Sample Output1234Case 1:63359 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;string&gt;using namespace std; struct Node&#123; int l, r, sum;&#125;t[210000]; int a[210000]; void build(int l, int r, int k) &#123; t[k].l=l; t[k].r=r; if(l==r)&#123; t[k].sum=a[r]; &#125;else&#123; build(l, (l+r)/2, k*2); build((l+r)/2+1, r, k*2+1); t[k].sum=t[k*2].sum+t[k*2+1].sum; &#125;&#125; int query(int l, int r, int k)&#123; if(t[k].l&gt;=l &amp;&amp; t[k].r&lt;=r) return t[k].sum; else&#123; int m=(t[k].l+t[k].r)/2; int ans=0; if(l&lt;=m) ans+=query(l, r, 2*k); if(r&gt;m) ans+=query(l, r, 2*k+1); return ans; &#125; &#125; void add(int a,int b,int k)&#123; t[k].sum+=b; if(t[k].l==a &amp;&amp; t[k].r==a) return; if(a&gt;(t[k].l+t[k].r)/2) add(a, b, 2*k+1); else add(a, b, 2*k);&#125; void sub(int a,int b,int k)&#123; t[k].sum-=b; if(t[k].l==a &amp;&amp; t[k].r==a) return; if(a&gt;(t[k].l+t[k].r)/2) sub(a, b, 2*k+1); else sub(a, b, 2*k);&#125; int main(void)&#123; int n,T; char command[6]; scanf("%d", &amp;T); for (int i=1; i&lt;=T; i++) &#123; scanf("%d", &amp;n); for (int j=1; j&lt;=n; j++) scanf("%d", &amp;a[j]); build(1, n, 1); cout &lt;&lt; "Case " &lt;&lt; i &lt;&lt; ":" &lt;&lt; endl; int a,b; while (scanf("%s", command)) &#123; if (strcmp(command,"End")==0) break; scanf("%d%d", &amp;a, &amp;b); if(strcmp(command,"Query")==0) cout &lt;&lt; query(a, b, 1) &lt;&lt; endl; else if(strcmp(command,"Add")==0) add(a, b, 1); else if(strcmp(command,"Sub")==0) sub(a, b, 1); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>Data Structure</category>
        <category>线段树</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>Data Structure</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并查集 &nbsp;HDU-1213 &nbsp;How Many Tables]]></title>
    <url>%2F2018%2F08%2F05%2FACM%2FData%20Structure%2FUnion-Find%20Set%2F%E5%B9%B6%E6%9F%A5%E9%9B%86%20HDU-1213%20How%20Many%20Tables%2F</url>
    <content type="text"><![CDATA[How Many Tables[ HDU - 1213 ] Today is Ignatius’ birthday. He invites a lot of friends. Now it’s dinner time. Ignatius wants to know how many tables he needs at least. You have to notice that not all the friends know each other, and all the friends do not want to stay with strangers.One important rule for this problem is that if I tell you A knows B, and B knows C, that means A, B, C know each other, so they can stay in one table.For example: If I tell you A knows B, B knows C, and D knows E, so A, B, C can stay in one table, and D, E have to stay in the other one. So Ignatius needs 2 tables at least. Input The input starts with an integer T(1&lt;=T&lt;=25) which indicate the number of test cases. Then T test cases follow. Each test case starts with two integers N and M(1&lt;=N,M&lt;=1000). N indicates the number of friends, the friends are marked from 1 to N. Then M lines follow. Each line consists of two integers A and B(A!=B), that means friend A and friend B know each other. There will be a blank line between two cases. Output For each test case, just output how many tables Ignatius needs at least. Do NOT print any blanks. Sample Input1234567825 31 22 34 5 5 12 5 Sample Output1224 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;iostream&gt;using namespace std; int par[1010];int ran[1010]; void init(int n)&#123; for(int i=1; i&lt;=n; i++)&#123; par[i]=i; ran[i]=0; &#125;&#125; int find(int x)&#123; if(par[x]==x) return x; else return par[x]=find(par[x]);&#125; void unite(int x, int y)&#123; x=find(x); y=find(y); if(x==y) return; if(ran[x]&lt;ran[y])&#123; par[x]=y; &#125;else&#123; par[y]=x; if(ran[x]==ran[y]) ran[x]++; &#125;&#125; int main(void)&#123; int t, m, n, a, b; cin &gt;&gt; t; while(t--)&#123; scanf("%d%d", &amp;n, &amp;m); init(n); for(int i=0; i&lt;m; i++)&#123; scanf("%d%d", &amp;a, &amp;b); if(a&lt;b) swap(a, b); unite(a, b); &#125; int sum=0; for(int i=1; i&lt;=n; i++)&#123; if(par[i]==i) sum++; &#125; printf("%d\n", sum); getchar(); &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>Data Structure</category>
        <category>并查集</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>Data Structure</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并查集 &nbsp;HDU-1232 &nbsp;畅通工程​​​​​​​]]></title>
    <url>%2F2018%2F08%2F05%2FACM%2FData%20Structure%2FUnion-Find%20Set%2F%E5%B9%B6%E6%9F%A5%E9%9B%86%20HDU-1232%20%E7%95%85%E9%80%9A%E5%B7%A5%E7%A8%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%2F</url>
    <content type="text"><![CDATA[畅通工程[ HDU - 1232 ] 某省调查城镇交通状况，得到现有城镇道路统计表，表中列出了每条道路直接连通的城镇。省政府“畅通工程”的目标是使全省任何两个城镇间都可以实现交通（但不一定有直接的道路相连，只要互相间接通过道路可达即可）。问最少还需要建设多少条道路？ Input 测试输入包含若干测试用例。每个测试用例的第1行给出两个正整数，分别是城镇数目N ( &lt; 1000 )和道路数目M；随后的M行对应M条道路，每行给出一对正整数，分别是该条道路直接连通的两个城镇的编号。为简单起见，城镇从1到N编号。注意:两个城市之间可以有多条道路相通,也就是说3 31 21 22 1这种输入也是合法的当N为0时，输入结束，该用例不被处理。 Output 对每个测试用例，在1行里输出最少还需要建设的道路数目。 Sample Input1234567891011124 21 34 33 31 21 32 35 21 23 5999 00 Sample Output1234102998 HintHuge input, scanf is recommended. 赤裸裸的并查集……12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;iostream&gt;using namespace std; int par[1010];int ran[1010]; void init(int n)&#123; for(int i=1; i&lt;=n; i++)&#123; par[i]=i; ran[i]=0; &#125;&#125; int find(int x)&#123; if(par[x]==x) return x; else return par[x]=find(par[x]);&#125; void unite(int x, int y)&#123; x=find(x); y=find(y); if(x==y) return; if(ran[x]&lt;ran[y])&#123; par[x]=y; &#125;else&#123; par[y]=x; if(ran[x]==ran[y]) ran[x]++; &#125;&#125; int main(void)&#123; int n, m, a, b; while(~scanf("%d", &amp;n) &amp;&amp; n!=0)&#123; init(n); scanf("%d", &amp;m); for(int i=0; i&lt;m; i++)&#123; scanf("%d%d", &amp;a, &amp;b); if(a&gt;b) swap(a,b); unite(a, b); &#125; int sum=0; for(int i=1; i&lt;=n; i++) if(par[i]==i) sum++; printf("%d\n", sum-1); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>Data Structure</category>
        <category>并查集</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>Data Structure</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络流—Edmonds-Karp最短增广路算法(最大流)]]></title>
    <url>%2F2018%2F08%2F05%2FACM%2FGraph%2FNetwork%20Flow%2F%E7%BD%91%E7%BB%9C%E6%B5%81%E2%80%94Edmonds-Karp%20%E6%9C%80%E7%9F%AD%E5%A2%9E%E5%B9%BF%E8%B7%AF%E7%AE%97%E6%B3%95(%E6%9C%80%E5%A4%A7%E6%B5%81)%2F</url>
    <content type="text"><![CDATA[网络流—Edmonds-Karp 最短增广路算法(最大流)思路 ■求最大流的过程，就是不断找到一条源到汇的路径，然后构建残余网络，再在残余网络上寻找新的路径，使总流量增加，然后形成新的残余网络，再寻找新路径…..直到某个残余网络上找不到从源到汇的路径为止，最大流就算出来了。 ■每次寻找新流量并构造新残余网络的过程，就叫做寻找流量的“增广路径”，也叫“增广” 现在假设每条边的容量都是整数，这个算法每次都能将流至少增加1 由于整个网络的流量最多不超过 图中所有的边的容量和C，从而算法会结束 复杂度 找增广路径的算法可以用dfs，复杂度为边数m+顶点数n ，Dfs 最多运行C次 ，所以时间复杂度为C*(m+n) =C* n^2 这个算法实现很简单 但是注意到在图中C可能会非常大 因此在每次增广的时候，选择从源到汇的具有最少边数的增广路径,即不是通过dfs寻找增广路径，而是通过bfs寻找增广路径。 这就是Edmonds-Karp 最短增广路算法 已经证明这种算法的复杂度上限为nm2 (n是点数，m是边数） --- 例题： Drainage Ditches [ POJ - 1273 ] Every time it rains on Farmer John's fields, a pond forms over Bessie's favorite clover patch. This means that the clover is covered by water for awhile and takes quite a long time to regrow. Thus, Farmer John has built a set of drainage ditches so that Bessie's clover patch is never covered in water. Instead, the water is drained to a nearby stream. Being an ace engineer, Farmer John has also installed regulators at the beginning of each ditch, so he can control at what rate water flows into that ditch. Farmer John knows not only how many gallons of water each ditch can transport per minute but also the exact layout of the ditches, which feed out of the pond and into each other and stream in a potentially complex network. Given all this information, determine the maximum rate at which water can be transported out of the pond and into the stream. For any given ditch, water flows in only one direction, but there might be a way that water can flow in a circle. Input The input includes several cases. For each case, the first line contains two space-separated integers, N (0 &lt;= N &lt;= 200) and M (2 &lt;= M &lt;= 200). N is the number of ditches that Farmer John has dug. M is the number of intersections points for those ditches. Intersection 1 is the pond. Intersection point M is the stream. Each of the following N lines contains three integers, Si, Ei, and Ci. Si and Ei (1 &lt;= Si, Ei &lt;= M) designate the intersections between which this ditch flows. Water will flow through this ditch from Si to Ei. Ci (0 &lt;= Ci &lt;= 10,000,000) is the maximum rate at which water will flow through the ditch. Output For each case, output a single integer, the maximum rate at which water may emptied from the pond. Sample Input1234565 41 2 401 4 202 4 202 3 303 4 10 Sample Output150 赤裸裸的网络流题目。给定点数，边数，每条边的容量，以及源点，汇点，求最大流。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;queue&gt;using namespace std; int G[300][300];int Prev[300]; //路径上每个节点的前驱节点bool Visited[300];int n, m; //m是顶点数目，顶点编号从1开始 1是源，m是汇, n是边数 unsigned Augment(void)&#123; int v; int i; deque&lt;int&gt; q; memset(Prev, 0, sizeof(Prev)); memset(Visited, 0, sizeof(Visited)); Prev[1] = 0; Visited[1] = 1; q.push_back(1); bool bFindPath = false; //用bfs寻找一条源到汇的可行路径 while (!q.empty())&#123; v = q.front(); q.pop_front(); for (i = 1; i &lt;= m; i++)&#123; if (G[v][i] &gt; 0 &amp;&amp; Visited[i] == 0)&#123; //必须是依然有容量的边，才可以走 Prev[i] = v; Visited[i] = 1; if (i == m)&#123; bFindPath = true; q.clear(); break; &#125;else q.push_back(i); &#125; &#125; &#125; if (!bFindPath) return 0; int nMinFlow = 999999999; v = m; //寻找源到汇路径上容量最小的边，其容量就是此次增加的总流量 while (Prev[v])&#123; nMinFlow = min(nMinFlow, G[Prev[v]][v]); v = Prev[v]; &#125; //沿此路径添加反向边，同时修改路径上每条边的容量 v = m; while (Prev[v])&#123; G[Prev[v]][v] -= nMinFlow; G[v][Prev[v]] += nMinFlow; v = Prev[v]; &#125; return nMinFlow;&#125; int main(void)&#123; while (~scanf("%d%d", &amp;n, &amp;m))&#123; //m是顶点数目，顶点编号从1开始 int i, j, k; int s, e, c; memset(G, 0, sizeof(G)); for (i = 0; i &lt; n; i++)&#123; scanf("%d%d%d", &amp;s, &amp;e, &amp;c); G[s][e] += c; //两点之间可能有多条边 &#125; unsigned int MaxFlow = 0; unsigned int aug; while (aug = Augment()) MaxFlow += aug; cout &lt;&lt; MaxFlow &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>Graph</category>
        <category>网络流</category>
        <category>最大流</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>Graph</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello Hexo]]></title>
    <url>%2F2018%2F08%2F04%2FOthers%2Fhello-hexo%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
