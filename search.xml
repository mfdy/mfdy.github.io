<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Github博客打开速度太慢利用Coding处理方法]]></title>
    <url>%2F2018%2F08%2F06%2FGithub%E5%8D%9A%E5%AE%A2%E6%89%93%E5%BC%80%E9%80%9F%E5%BA%A6%E5%A4%AA%E6%85%A2%E5%88%A9%E7%94%A8Coding%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[很多人都选择用github搭建个人博客，但是国内很多地方访问速度都很慢。因此可以选择将博客同时同步到coding和github然后二者绑定同一域名即可可以自己购买一个域名，或者不想花钱或嫌域名备案麻烦的可以直接绑定自己的github博客地址同理也可以选择在github中绑定自己的coding博客地址 具体操作如下： 博客设置文件更改如下：123456deploy: type: git repository: hithub: git@github.com:mfdy/mfdy.github.io.git coding: git@git.coding.net:mfdy/mfdy.git branch: master 在coding上建立项目等与github类似，所以省略……然后SSH可以直接用当时github生成的，建议直接添加到个人设置里。添加到项目设置中默认权限是只读的，可能会造成一系列的问题。 coding上要用户名在前的地址是需要启动 代码 - pages服务 的&nbsp;&nbsp;&nbsp;&nbsp;这里选择静态Pages即可。 之后在博客根目录右键Git Bash，输入1ssh -T git@git.coding.net 得到以下回复即为成功1Coding.net Tips : [Hello ! You've conected to Coding.net by SSH successfully! ] 下来CMD输入命令上传并发布1hexo d -g 截至到此，你的两个代码仓库都部署好博客了然后给二者绑定同一域名这里可以选择购买一个个人域名绑定但是个人域名需要花钱而且备案时间又有点长比较麻烦 这时候就——重点来了 在coding的pages自定义域名中直接绑定自己的github域名即可 同理也可以选择在github中绑定自己的coding博客地址]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[更换个人博客地址]]></title>
    <url>%2F2018%2F08%2F05%2F%E6%9B%B4%E6%8D%A2%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%9C%B0%E5%9D%80%2F</url>
    <content type="text"><![CDATA[博客搬家了！&emsp;从csdn搬过来了，同时原csdn博客基本不再更新（有时候嫌麻烦会更新，但这里会同步） 原csdn博客地址：MFDY’s csdn blog]]></content>
  </entry>
  <entry>
    <title><![CDATA[并查集 &nbsp;HDU-1213 &nbsp;How Many Tables]]></title>
    <url>%2F2018%2F08%2F05%2F%E5%B9%B6%E6%9F%A5%E9%9B%86%20HDU-1213%20How%20Many%20Tables%2F</url>
    <content type="text"><![CDATA[How Many Tables[ HDU - 1213 ] Today is Ignatius’ birthday. He invites a lot of friends. Now it’s dinner time. Ignatius wants to know how many tables he needs at least. You have to notice that not all the friends know each other, and all the friends do not want to stay with strangers.One important rule for this problem is that if I tell you A knows B, and B knows C, that means A, B, C know each other, so they can stay in one table.For example: If I tell you A knows B, B knows C, and D knows E, so A, B, C can stay in one table, and D, E have to stay in the other one. So Ignatius needs 2 tables at least. Input The input starts with an integer T(1&lt;=T&lt;=25) which indicate the number of test cases. Then T test cases follow. Each test case starts with two integers N and M(1&lt;=N,M&lt;=1000). N indicates the number of friends, the friends are marked from 1 to N. Then M lines follow. Each line consists of two integers A and B(A!=B), that means friend A and friend B know each other. There will be a blank line between two cases. Output For each test case, just output how many tables Ignatius needs at least. Do NOT print any blanks. Sample Input1234567825 31 22 34 5 5 12 5 Sample Output1224 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;iostream&gt;using namespace std; int par[1010];int ran[1010]; void init(int n)&#123; for(int i=1; i&lt;=n; i++)&#123; par[i]=i; ran[i]=0; &#125;&#125; int find(int x)&#123; if(par[x]==x) return x; else return par[x]=find(par[x]);&#125; void unite(int x, int y)&#123; x=find(x); y=find(y); if(x==y) return; if(ran[x]&lt;ran[y])&#123; par[x]=y; &#125;else&#123; par[y]=x; if(ran[x]==ran[y]) ran[x]++; &#125;&#125; int main(void)&#123; int t, m, n, a, b; cin &gt;&gt; t; while(t--)&#123; scanf("%d%d", &amp;n, &amp;m); init(n); for(int i=0; i&lt;m; i++)&#123; scanf("%d%d", &amp;a, &amp;b); if(a&lt;b) swap(a, b); unite(a, b); &#125; int sum=0; for(int i=1; i&lt;=n; i++)&#123; if(par[i]==i) sum++; &#125; printf("%d\n", sum); getchar(); &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>并查集</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DFS图的联通块 &nbsp;UVA-572 &nbsp;Oil Deposits]]></title>
    <url>%2F2018%2F08%2F05%2FDFS%20UVA-572%20Oil%20Deposits%2F</url>
    <content type="text"><![CDATA[Oil Deposits[ UVA - 572 ]&nbsp;&nbsp;The GeoSurvComp geologic survey company is responsible for detecting underground oil deposits. GeoSurvComp works with one large rectangular region of land at a time, and creates a grid that divides the land into numerous square plots. It then analyzes each plot separately, using sensing equipment to determine whether or not the plot contains oil. &nbsp;&nbsp;A plot containing oil is called a pocket. If two pockets are adjacent, then they are part of the same oil deposit. Oil deposits can be quite large and may contain numerous pockets. Your job is to determine how many different oil deposits are contained in a grid. Input The input file contains one or more grids. Each grid begins with a line containing m and n, the number of rows and columns in the grid, separated by a single space. If m = 0 it signals the end of the input; otherwise 1 ≤ m ≤ 100 and 1 ≤ n ≤ 100. Following this are m lines of n characters each (not counting the end-of-line characters). Each character corresponds to one plot, and is either ‘*’, representing the absence of oil, or ‘@’, representing an oil pocket. Output For each grid, output the number of distinct oil deposits. Two different pockets are part of the same oil deposit if they are adjacent horizontally, vertically, or diagonally. An oil deposit will not contain more than 100 pockets. Sample Input1234567891011121314151 1*3 5*@*@***@***@*@*1 8@@****@*5 5****@*@@*@*@**@@@@*@@@**@0 0 Hint12340122 分析从每个”@”格子出发，递归遍历它周围的”@”格子。 每次访问就把他标记成”*”，即不通路（或者可以用数组表示是否访问过）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstdlib&gt;using namespace std; int m, n;char garden[105][105]; void dfs(int x, int y)&#123; //将当前点取消标记，避免重复查找 garden[x][y] = '*'; //遍历周围的八个点 for (int dx = -1; dx &lt;= 1; dx++)&#123; for (int dy = -1; dy &lt;= 1;dy++)&#123; int nx = x + dx; int ny = y + dy; if(0&lt;=nx &amp;&amp; nx&lt;n &amp;&amp; 0&lt;=ny &amp;&amp; ny&lt;m &amp;&amp; garden[nx][ny]=='@') dfs(nx, ny); &#125; &#125;&#125; int main(void)&#123; while(~scanf("%d%d", &amp;n, &amp;m) &amp;&amp; m+n)&#123; getchar(); //吸收两数字后的换行符 memset(garden, 0, sizeof(garden)); for (int i = 0; i &lt; n;i++)&#123; for (int j = 0; j &lt; m;j++) scanf("%c", &amp;garden[i][j]); getchar(); //吸收每次输入一行后的换行符 &#125; int sum = 0; for (int i = 0; i &lt; n; i++)&#123; for (int j = 0; j &lt; m; j++)&#123; if (garden[i][j] == '@')&#123; dfs(i, j); sum++; &#125; &#125; &#125; cout &lt;&lt; sum &lt;&lt; endl; &#125; system("pause"); return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>DFS</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DFS深入优先搜索 &nbsp;POJ-2386 &nbsp;Lake Counting]]></title>
    <url>%2F2018%2F08%2F05%2FDFS%20POJ-2386%20Lake%20Counting%2F</url>
    <content type="text"><![CDATA[Lake Counting[POJ - 2386] Due to recent rains, water has pooled in various places in Farmer John’s field, which is represented by a rectangle of N x M (1 &lt;= N &lt;= 100; 1 &lt;= M &lt;= 100) squares. Each square contains either water (‘W’) or dry land (‘.’). Farmer John would like to figure out how many ponds have formed in his field. A pond is a connected set of squares with water in them, where a square is considered adjacent to all eight of its neighbors.Given a diagram of Farmer John’s field, determine how many ponds he has. Input Line 1: Two space-separated integers: N and M Lines 2..N+1: M characters per line representing one row of Farmer John’s field. Each character is either ‘W’ or ‘.’. The characters do not have spaces between them. Output Line 1: The number of ponds in Farmer John’s field. Sample Input123456789101110 12W........WW..WWW.....WWW....WW...WW..........WW..........W....W......W...W.W.....WW.W.W.W.....W..W.W......W...W.......W. Sample Output13 HintOUTPUT DETAILS:There are three ponds: one in the upper left, one in the lower left,and one along the right side. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstdlib&gt;using namespace std; int m, n;char garden[105][105]; void dfs(int x, int y)&#123; //将当前点取消标记，避免重复查找 garden[x][y] = '.'; //遍历周围的八个点 for (int dx = -1; dx &lt;= 1; dx++)&#123; for (int dy = -1; dy &lt;= 1;dy++)&#123; int nx = x + dx; int ny = y + dy; if(0&lt;=nx &amp;&amp; nx&lt;n &amp;&amp; 0&lt;=ny &amp;&amp; ny&lt;m &amp;&amp; garden[nx][ny]=='W') dfs(nx, ny); &#125; &#125;&#125; int main(void)&#123; while(~scanf("%d%d", &amp;n,&amp;m))&#123; getchar(); //吸收两数字后的换行符 memset(garden, 0, sizeof(garden)); for (int i = 0; i &lt; n;i++)&#123; for (int j = 0; j &lt; m;j++) scanf("%c", &amp;garden[i][j]); getchar(); //吸收每次输入一行后的换行符 &#125; int sum = 0; for (int i = 0; i &lt; n; i++)&#123; for (int j = 0; j &lt; m; j++)&#123; if (garden[i][j] == 'W')&#123; dfs(i, j); sum++; &#125; &#125; &#125; cout &lt;&lt; sum &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>DFS</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BFS:图的最短路径 &nbsp;Aizu-0558 &nbsp;​​​​​​​Cheese]]></title>
    <url>%2F2018%2F08%2F05%2FBFS%20Aizu%20-%200558%20%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8BCheese%2F</url>
    <content type="text"><![CDATA[Cheese[ Aizu - 0558 ] 大意：在H * W的地图上有N个奶酪工厂，每个工厂分别生产硬度为1-N的奶酪。有一只老鼠准备从出发点吃遍每一个工厂的奶酪。老鼠有一个体力值，初始时为1，每吃一个工厂的奶酪体力值增加1（每个工厂只能吃一次），且老鼠只能吃硬度不大于当前体力值的奶酪。 老鼠从当前格到上下左右相邻的无障碍物的格需要时间1单位，有障碍物的格不能走。走到工厂上时即可吃到该工厂的奶酪，吃奶酪时间不计。问吃遍所有奶酪最少用时。 输入：第一行三个整数H(1 &lt;= H &lt;= 1000)、W(1 &lt;= W &lt;=1000)、N(1 &lt;= N &lt;= 9)，之后H行W列为地图， “.“为空地， ”X“为障碍物，”S“为老鼠洞， 1-N代表硬度为1-N的奶酪的工厂。输出最少用时。 今年も JOI 町のチーズ工場がチーズの生産を始め，ねずみが巣から顔を出した．JOI 町は東西南北に区画整理されていて，各区画は巣，チーズ工場，障害物，空き地のいずれかである．ねずみは巣から出発して全てのチーズ工場を訪れチーズを 1 個ずつ食べる． この町には，N 個のチーズ工場があり，どの工場も１種類のチーズだけを生産している．チーズの硬さは工場によって異なっており，硬さ 1 から N までのチーズを生産するチーズ工場がちょうど 1 つずつある． ねずみの最初の体力は 1 であり，チーズを 1 個食べるごとに体力が 1 増える．ただし，ねずみは自分の体力よりも硬いチーズを食べることはできない． ねずみは，東西南北に隣り合う区画に 1 分で移動することができるが，障害物の区画には入ることができない．チーズ工場をチーズを食べずに通り過ぎることもできる．すべてのチーズを食べ終えるまでにかかる最短時間を求めるプログラムを書け．ただし，ねずみがチーズを食べるのにかかる時間は無視できる． Input 入力は H+1 行ある．1 行目には 3 つの整数 H，W，N (1 ≤ H ≤ 1000，1 ≤ W ≤ 1000，1 ≤ N ≤ 9) がこの順に空白で区切られて書かれている．2 行目から H+1 行目までの各行には，’S’，’1’, ‘2’, …, ‘9’，’X’，’.’ からなる W 文字の文字列が書かれており，各々が各区画の状態を表している．北から i 番目，西から j 番目の区画を (i,j) と記述することにすると (1 ≤ i ≤ H, 1 ≤ j ≤ W)，第 i+1 行目の j 番目の文字は，区画 (i,j) が巣である場合は ‘S’ となり，障害物である場合は ‘X’ となり，空き地である場合は ‘.’ となり，硬さ 1, 2, …, 9 のチーズを生産する工場である場合はそれぞれ ‘1’, ‘2’, …, ‘9’ となる．入力には巣と硬さ 1, 2, …, N のチーズを生産する工場がそれぞれ 1 つずつある．他のマスは障害物または空き地であることが保証されている．ねずみは全てのチーズを食べられることが保証されている． Output すべてのチーズを食べ終えるまでにかかる最短時間（分）を表す整数を 1 行で出力せよ． Sample Input 112343 3 1S.......1 Sample Output 114 Sample Input 2123454 5 2.X..1....X.XX.S.2.X. Sample Output 2112 Sample Input 3123456789101110 10 9.X...X.S.X6..5X..X1X...XXXX..XX..9X...X.8.X2X..X3X...XX.X4..XX....7X..X..X..XX..X...X.XX....X....... Sample Output 3191 問題文と自動審判に使われるデータは、情報オリンピック日本委員会が作成し公開している問題文と採点用テストデータです。 BFS变下形就行，注意数组范围……123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;string&gt;#include&lt;cstdio&gt;#include&lt;cctype&gt;#include&lt;queue&gt;#include&lt;cmath&gt;#include&lt;map&gt;#include&lt;set&gt;using namespace std;const int INF = 100000000, maxn = 1005;//可以使用结构体typedef pair&lt;int, int&gt; P; char maze[maxn][maxn];int n, m, k, sx, sy, gx[10], gy[10];//到各个位置的最短距离的数组int d[maxn][maxn];//4个方向移动的向量int dx[4] = &#123;1, 0, -1, 0&#125;, dy[4] = &#123;0, 1, 0, -1&#125;; //求从(sx,sy)到(gx,gy)的最短距离//若无法到达则是INFint bfs(int sx, int sy, int gx, int gy)&#123; queue&lt;P&gt; que; //所有的位置都初始化为INF for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; m; j++) d[i][j] = INF; que.push(P(sx, sy)); //将起点加入队列中 d[sx][sy] = 0; //并把这一地点的距离设置为0 //不断循环直到队列的长度为0 while (que.size())&#123; P p = que.front(); // 从队列的最前段取出元素 que.pop(); //取出后从队列中删除该元素 if (p.first == gx &amp;&amp; p.second == gy) break; //四个方向的循环 for (int i = 0; i &lt; 4; i++)&#123; //移动后的位置标记为(nx,ny) int nx = p.first + dx[i], ny = p.second + dy[i]; //判断是否可以移动以及是否访问过(即d[nx][ny]!=INF） if (0 &lt;= nx &amp;&amp; nx &lt; n &amp;&amp; 0 &lt;= ny &amp;&amp; ny &lt; m &amp;&amp; maze[nx][ny] != 'X' &amp;&amp; d[nx][ny] == INF)&#123; que.push(P(nx, ny)); //可以移动，添加到队列 d[nx][ny] = d[p.first][p.second] + 1; //到该位置的距离为到p的距离+1 &#125; &#125; &#125; return d[gx][gy];&#125; int main()&#123; cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; int t; for (int i = 0; i &lt; n; i++)&#123; for (int j = 0; j &lt; m; j++)&#123; cin &gt;&gt; maze[i][j]; if(maze[i][j]=='S')&#123; gx[0] = i; gy[0] = j; &#125;else if (isdigit(maze[i][j]))&#123; t = maze[i][j] - '0'; gx[t] = i; gy[t] = j; &#125; &#125; &#125; int sum = 0; for (int i = 1; i &lt;= k; i++) sum += bfs(gx[i - 1], gy[i - 1], gx[i], gy[i]); cout &lt;&lt; sum &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>BFS</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[贪心 &nbsp;POJ-2376 ​​​​​​​&nbsp;Cleaning Shifts]]></title>
    <url>%2F2018%2F08%2F05%2F%E8%B4%AA%E5%BF%83%20POJ%20-%202376%20%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8BCleaning%20Shifts%2F</url>
    <content type="text"><![CDATA[Cleaning Shifts[ POJ - 2376 ] Farmer John is assigning some of his N (1 &lt;= N &lt;= 25,000) cows to do some cleaning chores around the barn. He always wants to have one cow working on cleaning things up and has divided the day into T shifts (1 &lt;= T &lt;= 1,000,000), the first being shift 1 and the last being shift T.Each cow is only available at some interval of times during the day for work on cleaning. Any cow that is selected for cleaning duty will work for the entirety of her interval.Your job is to help Farmer John assign some cows to shifts so that (i) every shift has at least one cow assigned to it, and (ii) as few cows as possible are involved in cleaning. If it is not possible to assign a cow to each shift, print -1. Input Line 1: Two space-separated integers: N and T Lines 2..N+1: Each line contains the start and end times of the interval during which a cow can work. A cow starts work at the start time and finishes after the end time. Output Line 1: The minimum number of cows Farmer John needs to hire or -1 if it is not possible to assign a cow to each shift. Sample Input12343 101 73 66 10 Sample Output12 HintThis problem has huge input data,use scanf() instead of cin to read data to avoid time limit exceed.INPUT DETAILS:There are 3 cows and 10 shifts. Cow #1 can work shifts 1..7, cow #2 can work shifts 3..6, and cow #3 can work shifts 6..10.OUTPUT DETAILS:By selecting cows #1 and #3, all shifts are covered. There is no way to cover all the shifts using fewer than 2 cows. 先对起始时间进行排序，然后对于没有取过的牛进行处理，判断即可。123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;queue&gt;using namespace std; const int maxn = 25050;pair&lt;int, int&gt; it[maxn]; int n, t; int main(void)&#123; cin &gt;&gt; n &gt;&gt; t; for (int i = 0; i &lt; n; i++) &#123; scanf("%d%d", &amp;it[i].first, &amp;it[i].second); &#125; sort(it, it + n); int sum = 0; int ju = 0, maxn = 0; while (maxn &lt; t) &#123; int ans = maxn + 1; for (int i = ju; i &lt; n; i++) &#123; if (it[i].first &lt;= ans &amp;&amp; it[i].second &gt;= ans) &#123; maxn = max(maxn, it[i].second); &#125;else if (it[i].first &gt; ans) &#123; ju = i; break; &#125; &#125; if(ans &gt; maxn) break; else sum++; &#125; if (maxn &gt;= t) cout &lt;&lt; sum &lt;&lt; endl; else cout &lt;&lt; "-1" &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>贪心</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DFS:图的联通块&nbsp; AOJ-0118&nbsp; Property Distribution]]></title>
    <url>%2F2018%2F08%2F05%2FDFS%20AOJ-0118%20Property%20Distribution%2F</url>
    <content type="text"><![CDATA[Property Distribution[ Aizu - 0118 ] 这道题类似于联通图问题，将联通的归成一个，数一下总共有几个即可。 因为题目告诉不会有空格，所以排除标记用空格表示即可。 タナカ氏が HW アールの果樹園を残して亡くなりました。果樹園は東西南北方向に H × W の区画に分けられ、区画ごとにリンゴ、カキ、ミカンが植えられています。タナカ氏はこんな遺言を残していました。 果樹園は区画単位でできるだけ多くの血縁者に分けること。ただし、ある区画の東西南北どれかの方向にとなりあう区画に同じ種類の果物が植えられていた場合は、区画の境界が分からないのでそれらは 1 つの大きな区画として扱うこと。 例えば次のような 3 × 10 の区画であれば (‘リ’はリンゴ、’カ’はカキ、’ミ’はミカンを表す) 同じ樹がある区画の間の境界を消すと次のようになり、 結局 10 個の区画、つまり 10 人で分けられることになります。 雪が降って区画の境界が見えなくなる前に分配を終えなくてはなりません。あなたの仕事は果樹園の地図をもとに分配する区画の数を決めることです。 果樹園の地図を読み込み、分配を受けられる血縁者の人数を出力するプログラムを作成してください。 Input 複数のデータセットが与えられます。各データセットは空白で区切られた H, W (H, W ≤ 100) を含む行から始まり、続いて H × W の文字からなる H 行の文字列が与えられます。この文字列には、リンゴを表す ‘@’、カキを表す ‘#’、ミカンを表す ‘*’、の 3 文字しか現れません。 入力はゼロが２つの行で終わります。データセットの数は 20 を超えません。 Output 複数のデータセットが与えられます。各データセットは空白で区切られた H, W (H, W ≤ 100) を含む行から始まり、続いて H × W の文字からなる H 行の文字列が与えられます。この文字列には、リンゴを表す ‘@’、カキを表す ‘#’、ミカンを表す ‘*’、の 3 文字しか現れません。 入力はゼロが２つの行で終わります。データセットの数は 20 を超えません。 Sample Input12345678910111210 10####*****@@#@@@@#*#*@##***@@@*#****#*@**##@*#@@*##*@@@@*@@@#***#@*@##**@@@*@@##@*@*#*@##**@****#@@#@0 0 Sample Output133 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstdlib&gt;using namespace std; int m, n;char garden[105][105];int d[4][2] = &#123; &#123;0, -1&#125;, &#123;1, 0&#125;, &#123;0, 1&#125;, &#123;-1, 0&#125;,&#125;; void dfs(int x, int y, char c)&#123; if(garden[x][y] == c)&#123; garden[x][y] = ' '; for (int i = 0; i &lt; 4; i++)&#123; int nx = x + d[i][1]; int ny = y + d[i][0]; if (0 &lt;= nx &amp;&amp; nx &lt; n &amp;&amp; 0 &lt;= ny &amp;&amp; ny &lt; m &amp;&amp; garden[nx][ny] != ' ') dfs(nx, ny, c); &#125; &#125;&#125; int main(void)&#123; while(~scanf("%d%d", &amp;n, &amp;m) &amp;&amp; m+n)&#123; getchar(); memset(garden, 0, sizeof(garden)); for (int i = 0; i &lt; n; i++)&#123; for (int j = 0; j &lt; m; j++) scanf("%c", &amp;garden[i][j]); getchar(); &#125; int sum = 0; for (int i = 0; i &lt; n; i++)&#123; for (int j = 0; j &lt; m; j++)&#123; if (garden[i][j] != ' ')&#123; dfs(i, j, garden[i][j]); sum++; &#125; &#125; &#125; cout &lt;&lt; sum &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>DFS</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并查集 &nbsp;HDU-1232 &nbsp;畅通工程​​​​​​​]]></title>
    <url>%2F2018%2F08%2F05%2F%E5%B9%B6%E6%9F%A5%E9%9B%86%20HDU-1232%20%E7%95%85%E9%80%9A%E5%B7%A5%E7%A8%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%2F</url>
    <content type="text"><![CDATA[畅通工程[ HDU - 1232 ] 某省调查城镇交通状况，得到现有城镇道路统计表，表中列出了每条道路直接连通的城镇。省政府“畅通工程”的目标是使全省任何两个城镇间都可以实现交通（但不一定有直接的道路相连，只要互相间接通过道路可达即可）。问最少还需要建设多少条道路？ Input 测试输入包含若干测试用例。每个测试用例的第1行给出两个正整数，分别是城镇数目N ( &lt; 1000 )和道路数目M；随后的M行对应M条道路，每行给出一对正整数，分别是该条道路直接连通的两个城镇的编号。为简单起见，城镇从1到N编号。注意:两个城市之间可以有多条道路相通,也就是说3 31 21 22 1这种输入也是合法的当N为0时，输入结束，该用例不被处理。 Output 对每个测试用例，在1行里输出最少还需要建设的道路数目。 Sample Input1234567891011124 21 34 33 31 21 32 35 21 23 5999 00 Sample Output1234102998 HintHuge input, scanf is recommended. 赤裸裸的并查集……12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;iostream&gt;using namespace std; int par[1010];int ran[1010]; void init(int n)&#123; for(int i=1; i&lt;=n; i++)&#123; par[i]=i; ran[i]=0; &#125;&#125; int find(int x)&#123; if(par[x]==x) return x; else return par[x]=find(par[x]);&#125; void unite(int x, int y)&#123; x=find(x); y=find(y); if(x==y) return; if(ran[x]&lt;ran[y])&#123; par[x]=y; &#125;else&#123; par[y]=x; if(ran[x]==ran[y]) ran[x]++; &#125;&#125; int main(void)&#123; int n, m, a, b; while(~scanf("%d", &amp;n) &amp;&amp; n!=0)&#123; init(n); scanf("%d", &amp;m); for(int i=0; i&lt;m; i++)&#123; scanf("%d%d", &amp;a, &amp;b); if(a&gt;b) swap(a,b); unite(a, b); &#125; int sum=0; for(int i=1; i&lt;=n; i++) if(par[i]==i) sum++; printf("%d\n", sum-1); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>并查集</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DFS:图的联通块 &nbsp;POJ-1979 &nbsp;Red and Black]]></title>
    <url>%2F2018%2F08%2F05%2FDFS%20POJ-1979%20Red%20and%20Black%2F</url>
    <content type="text"><![CDATA[Red and Black[ POJ - 1979] &nbsp;&nbsp;Here is a rectangular room, covered with square tiles. Each tile is colored either red or black. A man is standing on a black tile. From a tile, he can move to one of four adjacent tiles. But he can’t move on red tiles, he can move only on black tiles.&nbsp;&nbsp;Write a program to count the number of black tiles which he can reach by repeating the moves described above. Input The input consists of multiple data sets. A data set starts with a line containing two positive integers W and H; W and H are the numbers of tiles in the x- and y- directions, respectively. W and H are not more than 20.There are H more lines in the data set, each of which includes W characters. Each character represents the color of a tile as follows.‘.’ - a black tile‘#’ - a red tile‘@’ - a man on a black tile(appears exactly once in a data set)The end of the input is indicated by a line consisting of two zeros. Output For each data set, your program should output a line which contains the number of tiles he can reach from the initial tile (including itself). Sample Input1234567891011121314151617181920212223242526272829303132333435366 9....#......#..............................#@...#.#..#.11 9.#..........#.#######..#.#.....#..#.#.###.#..#.#..@#.#..#.#####.#..#.......#..#########............11 6..#..#..#....#..#..#....#..#..###..#..#..#@...#..#..#....#..#..#..7 7..#.#....#.#..###.###...@...###.###..#.#....#.#..0 0 Sample Output12344559613 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstdlib&gt;using namespace std; int m, n, sum;char garden[105][105];int d[4][2] = &#123; &#123;0, -1&#125;, &#123;1, 0&#125;, &#123;0, 1&#125;, &#123;-1, 0&#125;,&#125;; void dfs(int x, int y)&#123; garden[x][y] = '#'; sum++; for (int i = 0; i &lt; 4; i++)&#123; int nx = x + d[i][1]; int ny = y + d[i][0]; if(0&lt;=nx &amp;&amp; nx&lt;n &amp;&amp; 0&lt;=ny &amp;&amp; ny&lt;m &amp;&amp; garden[nx][ny]=='.') dfs(nx, ny); &#125;&#125; int main(void)&#123; while(~scanf("%d%d", &amp;m, &amp;n) &amp;&amp; m+n)&#123; getchar(); memset(garden, 0, sizeof(garden)); for (int i = 0; i &lt; n; i++)&#123; for (int j = 0; j &lt; m; j++) scanf("%c", &amp;garden[i][j]); getchar(); &#125; sum = 0; for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; m; j++) if (garden[i][j] == '@') dfs(i, j); cout &lt;&lt; sum &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>DFS</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线段树 &nbsp;HDU-1166 &nbsp;敌兵布阵]]></title>
    <url>%2F2018%2F08%2F05%2F%E7%BA%BF%E6%AE%B5%E6%A0%91-HDU-1166%2F</url>
    <content type="text"><![CDATA[敌兵布阵[HDU - 1166] &nbsp;&nbsp;&nbsp;&nbsp;C国的死对头A国这段时间正在进行军事演习，所以C国间谍头子Derek和他手下Tidy又开始忙乎了。A国在海岸线沿直线布置了N个工兵营地,Derek和Tidy的任务就是要监视这些工兵营地的活动情况。由于采取了某种先进的监测手段，所以每个工兵营地的人数C国都掌握的一清二楚,每个工兵营地的人数都有可能发生变动，可能增加或减少若干人手,但这些都逃不过C国的监视。&nbsp;&nbsp;&nbsp;&nbsp;中央情报局要研究敌人究竟演习什么战术,所以Tidy要随时向Derek汇报某一段连续的工兵营地一共有多少人,例如Derek问:“Tidy,马上汇报第3个营地到第10个营地共有多少人!”Tidy就要马上开始计算这一段的总人数并汇报。但敌兵营地的人数经常变动，而Derek每次询问的段都不一样，所以Tidy不得不每次都一个一个营地的去数，很快就精疲力尽了，Derek对Tidy的计算速度越来越不满:”你个死肥仔，算得这么慢，我炒你鱿鱼!”Tidy想：“你自己来算算看，这可真是一项累人的工作!我恨不得你炒我鱿鱼呢!”无奈之下，Tidy只好打电话向计算机专家Windbreaker求救,Windbreaker说：“死肥仔，叫你平时做多点acm题和看多点算法书，现在尝到苦果了吧!”Tidy说：”我知错了。。。”但Windbreaker已经挂掉电话了。Tidy很苦恼，这么算他真的会崩溃的，聪明的读者，你能写个程序帮他完成这项工作吗？不过如果你的程序效率不够高的话，Tidy还是会受到Derek的责骂的. Input 第一行一个整数T，表示有T组数据。每组数据第一行一个正整数N（N&lt;=50000）,表示敌人有N个工兵营地，接下来有N个正整数,第i个正整数ai代表第i个工兵营地里开始时有ai个人（1&lt;=ai&lt;=50）。接下来每行有一条命令，命令有4种形式：(1) Add i j,i和j为正整数,表示第i个营地增加j个人（j不超过30）(2)Sub i j ,i和j为正整数,表示第i个营地减少j个人（j不超过30）;(3)Query i j ,i和j为正整数,i&lt;=j，表示询问第i到第j个营地的总人数;(4)End 表示结束，这条命令在每组数据最后出现;每组数据最多有40000条命令 Output 对第i组数据,首先输出“Case i:”和回车,对于每个Query询问，输出一个整数并回车,表示询问的段中的总人数,这个数保持在int以内。 Sample Input123456789101101 2 3 4 5 6 7 8 9 10Query 1 3Add 3 6Query 2 7Sub 10 2Add 6 3Query 3 10End Sample Output1234Case 1:63359 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;string&gt;using namespace std; struct Node&#123; int l, r, sum;&#125;t[210000]; int a[210000]; void build(int l, int r, int k) &#123; t[k].l=l; t[k].r=r; if(l==r)&#123; t[k].sum=a[r]; &#125;else&#123; build(l, (l+r)/2, k*2); build((l+r)/2+1, r, k*2+1); t[k].sum=t[k*2].sum+t[k*2+1].sum; &#125;&#125; int query(int l, int r, int k)&#123; if(t[k].l&gt;=l &amp;&amp; t[k].r&lt;=r) return t[k].sum; else&#123; int m=(t[k].l+t[k].r)/2; int ans=0; if(l&lt;=m) ans+=query(l, r, 2*k); if(r&gt;m) ans+=query(l, r, 2*k+1); return ans; &#125; &#125; void add(int a,int b,int k)&#123; t[k].sum+=b; if(t[k].l==a &amp;&amp; t[k].r==a) return; if(a&gt;(t[k].l+t[k].r)/2) add(a, b, 2*k+1); else add(a, b, 2*k);&#125; void sub(int a,int b,int k)&#123; t[k].sum-=b; if(t[k].l==a &amp;&amp; t[k].r==a) return; if(a&gt;(t[k].l+t[k].r)/2) sub(a, b, 2*k+1); else sub(a, b, 2*k);&#125; int main(void)&#123; int n,T; char command[6]; scanf("%d", &amp;T); for (int i=1; i&lt;=T; i++) &#123; scanf("%d", &amp;n); for (int j=1; j&lt;=n; j++) scanf("%d", &amp;a[j]); build(1, n, 1); cout &lt;&lt; "Case " &lt;&lt; i &lt;&lt; ":" &lt;&lt; endl; int a,b; while (scanf("%s", command)) &#123; if (strcmp(command,"End")==0) break; scanf("%d%d", &amp;a, &amp;b); if(strcmp(command,"Query")==0) cout &lt;&lt; query(a, b, 1) &lt;&lt; endl; else if(strcmp(command,"Add")==0) add(a, b, 1); else if(strcmp(command,"Sub")==0) sub(a, b, 1); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>线段树</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线段树 &nbsp;HDU-1754 &nbsp;I Hate It]]></title>
    <url>%2F2018%2F08%2F05%2F%E7%BA%BF%E6%AE%B5%E6%A0%91-HDU-1754%2F</url>
    <content type="text"><![CDATA[I Hate It[HDU - 1754] 很多学校流行一种比较的习惯。老师们很喜欢询问，从某某到某某当中，分数最高的是多少。这让很多学生很反感。不管你喜不喜欢，现在需要你做的是，就是按照老师的要求，写一个程序，模拟老师的询问。当然，老师有时候需要更新某位同学的成绩。 Input 本题目包含多组测试，请处理到文件结束。在每个测试的第一行，有两个正整数 N 和 M ( 0&lt;N&lt;=200000,0&lt;M&lt;5000 )，分别代表学生的数目和操作的数目。学生ID编号分别从1编到N。第二行包含N个整数，代表这N个学生的初始成绩，其中第i个数代表ID为i的学生的成绩。接下来有M行。每一行有一个字符 C (只取’Q’或’U’) ，和两个正整数A，B。当C为’Q’的时候，表示这是一条询问操作，它询问ID从A到B(包括A,B)的学生当中，成绩最高的是多少。当C为’U’的时候，表示这是一条更新操作，要求把ID为A的学生的成绩更改为B。 Output 对于每一次询问操作，在一行里面输出最高成绩。 Sample Input123456785 61 2 3 4 5Q 1 5U 3 6Q 3 4Q 4 5U 2 9Q 1 5 Sample Output12345659 Hint1Huge input,the C function scanf() will work better than cin 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;string&gt;#include&lt;cstring&gt;using namespace std; struct node&#123; int l,r,max;&#125;t[810000]; int A[210000],max; int MAX(int a, int b)&#123; return a&gt;b ? a:b;&#125; void build(int l,int r,int k)&#123; t[k].l=l; t[k].r=r; if(l==r) t[k].max=A[r]; else&#123; build(l,(l+r)/2,k&lt;&lt;1); build((l+r)/2+1,r,k&lt;&lt;1|1); t[k].max=MAX(t[k&lt;&lt;1].max, t[k&lt;&lt;1|1].max); &#125;&#125; int query(int l,int r,int k)&#123; if(t[k].l&gt;=l &amp;&amp; t[k].r&lt;=r) return t[k].max; else&#123; int ans=0; int m=(t[k].l+t[k].r)/2; if(l&lt;=m) ans=query(l,r,k&lt;&lt;1); if(r&gt;m) ans=MAX(ans,query(l,r,k&lt;&lt;1|1)); return ans; &#125; &#125; void change(int a,int b,int k)&#123; if(t[k].l==a &amp;&amp; t[k].r==a)&#123; t[k].max=b; return; &#125; if(a&gt;(t[k].l+t[k].r)/2) change(a,b,2*k+1); else change(a,b,2*k); t[k].max=MAX(t[k*2].max, t[k*2+1].max);&#125; int main(void) &#123; int l,r,k,n,m; char command; while(scanf("%d%d",&amp;n,&amp;m)!=EOF)&#123; memset(t,0,sizeof(t)); memset(A,0,sizeof(A)); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;A[i]); build(1,n,1); getchar(); while(m--&gt;0)&#123; int a, b; scanf("%c%d%d",&amp;command,&amp;a,&amp;b); getchar(); if(command=='Q') cout &lt;&lt; query(a,b,1) &lt;&lt; endl; else if(command=='U') change(a,b,1); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>线段树</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络流—Edmonds-Karp最短增广路算法(最大流)]]></title>
    <url>%2F2018%2F08%2F05%2F%E7%BD%91%E7%BB%9C%E6%B5%81%E2%80%94Edmonds-Karp%20%E6%9C%80%E7%9F%AD%E5%A2%9E%E5%B9%BF%E8%B7%AF%E7%AE%97%E6%B3%95(%E6%9C%80%E5%A4%A7%E6%B5%81)%2F</url>
    <content type="text"><![CDATA[网络流—Edmonds-Karp 最短增广路算法(最大流)思路■求最大流的过程，就是不断找到一条源到汇的路径，然后构建残余网络，再在残余网络上寻找新的路径，使总流量增加，然后形成新的残余网络，再寻找新路径…..直到某个残余网络上找不到从源到汇的路径为止，最大流就算出来了。■每次寻找新流量并构造新残余网络的过程，就叫做寻找流量的“增广路径”，也叫“增广”现在假设每条边的容量都是整数，这个算法每次都能将流至少增加1由于整个网络的流量最多不超过 图中所有的边的容量和C，从而算法会结束复杂度找增广路径的算法可以用dfs，复杂度为边数m+顶点数n ，Dfs 最多运行C次 ，所以时间复杂度为C(m+n) =C n^2这个算法实现很简单但是注意到在图中C可能会非常大因此在每次增广的时候，选择从源到汇的具有最少边数的增广路径,即不是通过dfs寻找增广路径，而是通过bfs寻找增广路径。这就是Edmonds-Karp 最短增广路算法 已经证明这种算法的复杂度上限为nm2 (n是点数，m是边数）—例题： Drainage Ditches[ POJ - 1273 ]Every time it rains on Farmer John’s fields, a pond forms over Bessie’s favorite clover patch. This means that the clover is covered by water for awhile and takes quite a long time to regrow. Thus, Farmer John has built a set of drainage ditches so that Bessie’s clover patch is never covered in water. Instead, the water is drained to a nearby stream. Being an ace engineer, Farmer John has also installed regulators at the beginning of each ditch, so he can control at what rate water flows into that ditch.Farmer John knows not only how many gallons of water each ditch can transport per minute but also the exact layout of the ditches, which feed out of the pond and into each other and stream in a potentially complex network.Given all this information, determine the maximum rate at which water can be transported out of the pond and into the stream. For any given ditch, water flows in only one direction, but there might be a way that water can flow in a circle.Input The input includes several cases. For each case, the first line contains two space-separated integers, N (0 &lt;= N &lt;= 200) and M (2 &lt;= M &lt;= 200). N is the number of ditches that Farmer John has dug. M is the number of intersections points for those ditches. Intersection 1 is the pond. Intersection point M is the stream. Each of the following N lines contains three integers, Si, Ei, and Ci. Si and Ei (1 &lt;= Si, Ei &lt;= M) designate the intersections between which this ditch flows. Water will flow through this ditch from Si to Ei. Ci (0 &lt;= Ci &lt;= 10,000,000) is the maximum rate at which water will flow through the ditch. Output For each case, output a single integer, the maximum rate at which water may emptied from the pond. Sample Input1234565 41 2 401 4 202 4 202 3 303 4 10 Sample Output150 赤裸裸的网络流题目。给定点数，边数，每条边的容量，以及源点，汇点，求最大流。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;queue&gt;using namespace std; int G[300][300];int Prev[300]; //路径上每个节点的前驱节点bool Visited[300];int n, m; //m是顶点数目，顶点编号从1开始 1是源，m是汇, n是边数 unsigned Augment(void)&#123; int v; int i; deque&lt;int&gt; q; memset(Prev, 0, sizeof(Prev)); memset(Visited, 0, sizeof(Visited)); Prev[1] = 0; Visited[1] = 1; q.push_back(1); bool bFindPath = false; //用bfs寻找一条源到汇的可行路径 while (!q.empty())&#123; v = q.front(); q.pop_front(); for (i = 1; i &lt;= m; i++)&#123; if (G[v][i] &gt; 0 &amp;&amp; Visited[i] == 0)&#123; //必须是依然有容量的边，才可以走 Prev[i] = v; Visited[i] = 1; if (i == m)&#123; bFindPath = true; q.clear(); break; &#125;else q.push_back(i); &#125; &#125; &#125; if (!bFindPath) return 0; int nMinFlow = 999999999; v = m; //寻找源到汇路径上容量最小的边，其容量就是此次增加的总流量 while (Prev[v])&#123; nMinFlow = min(nMinFlow, G[Prev[v]][v]); v = Prev[v]; &#125; //沿此路径添加反向边，同时修改路径上每条边的容量 v = m; while (Prev[v])&#123; G[Prev[v]][v] -= nMinFlow; G[v][Prev[v]] += nMinFlow; v = Prev[v]; &#125; return nMinFlow;&#125; int main(void)&#123; while (~scanf("%d%d", &amp;n, &amp;m))&#123; //m是顶点数目，顶点编号从1开始 int i, j, k; int s, e, c; memset(G, 0, sizeof(G)); for (i = 0; i &lt; n; i++)&#123; scanf("%d%d%d", &amp;s, &amp;e, &amp;c); G[s][e] += c; //两点之间可能有多条边 &#125; unsigned int MaxFlow = 0; unsigned int aug; while (aug = Augment()) MaxFlow += aug; cout &lt;&lt; MaxFlow &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>网络流</category>
        <category>最大流</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[贪心 &nbsp;POJ-3617 ​​​​​​​&nbsp;Best Cow Line]]></title>
    <url>%2F2018%2F08%2F05%2F%E8%B4%AA%E5%BF%83%20POJ%20-%203617%20%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8BBest%20Cow%20Line%2F</url>
    <content type="text"><![CDATA[Best Cow Line[ POJ - 3617 ] &nbsp;&nbsp;FJ is about to take his N (1 ≤ N ≤ 2,000) cows to the annual”Farmer of the Year” competition. In this contest every farmer arranges his cows in a line and herds them past the judges.&nbsp;&nbsp;The contest organizers adopted a new registration scheme this year: simply register the initial letter of every cow in the order they will appear (i.e., If FJ takes Bessie, Sylvia, and Dora in that order he just registers BSD). After the registration phase ends, every group is judged in increasing lexicographic order according to the string of the initials of the cows’ names.&nbsp;&nbsp;FJ is very busy this year and has to hurry back to his farm, so he wants to be judged as early as possible. He decides to rearrange his cows, who have already lined up, before registering them.&nbsp;&nbsp;FJ marks a location for a new line of the competing cows. He then proceeds to marshal the cows from the old line to the new one by repeatedly sending either the first or last cow in the (remainder of the) original line to the end of the new line. When he’s finished, FJ takes his cows for registration in this new order.&nbsp;&nbsp;Given the initial order of his cows, determine the least lexicographic string of initials he can make this way. Input Line 1: A single integer: N Lines 2..N+1: Line i+1 contains a single initial (‘A’..’Z’) of the cow in the ith position in the original line Output The least lexicographic string he can make. Every line (except perhaps the last one) contains the initials of 80 cows (‘A’..’Z’) in the new line. Sample Input12345676ACDBCB Sample Output1ABCBCD 这道题就每次比较前后即可主要是细节方面的问题1.这道题字符串输入是一个一个输入……要么用getchar()收集，或者直接scanf(“ %c”, &amp;s[i])收集空白符2.注意每80个换一下行123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;iostream&gt;using namespace std; int par[1010];int ran[1010]; void init(int n)&#123; for(int i=1; i&lt;=n; i++)&#123; par[i]=i; ran[i]=0; &#125;&#125; int find(int x)&#123; if(par[x]==x) return x; else return par[x]=find(par[x]);&#125; void unite(int x, int y)&#123; x=find(x); y=find(y); if(x==y) return; if(ran[x]&lt;ran[y])&#123; par[x]=y; &#125;else&#123; par[y]=x; if(ran[x]==ran[y]) ran[x]++; &#125;&#125; int main(void)&#123; int t, m, n, a, b; cin &gt;&gt; t; while(t--)&#123; scanf("%d%d", &amp;n, &amp;m); init(n); for(int i=0; i&lt;m; i++)&#123; scanf("%d%d", &amp;a, &amp;b); if(a&lt;b) swap(a, b); unite(a, b); &#125; int sum=0; for(int i=1; i&lt;=n; i++)&#123; if(par[i]==i) sum++; &#125; printf("%d\n", sum); getchar(); &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>贪心</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello Hexo]]></title>
    <url>%2F2018%2F08%2F04%2Fhello-hexo%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
